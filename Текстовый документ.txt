
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton, LabeledPrice, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ConversationHandler, CallbackQueryHandler, ContextTypes,  ApplicationBuilder, PreCheckoutQueryHandler, MessageHandler
import sqlite3
import logging
from num2words import num2words
from datetime import datetime, timedelta
from telegram.ext import JobQueue
import google.generativeai as genai
from PIL import Image, ImageDraw, ImageFont
from passport_recognition_gemini import setup_gemini_api, parse_custom_deal_with_gemini, get_buyout_plans_with_gemini
from datetime import datetime
import pytz # <-- Добавить этот импорт
from expense_reporter import generate_expense_report
from database_manager import db_execute, db_fetch_one, db_fetch_all, db_execute_lastrowid
AWAIT_CLIENT_SIGNATURE = range(1)
# Добавьте эти два состояния к вашему списку
AWAIT_BATTERY_COUNT, AWAIT_BATTERY_NUMS = range(600, 602)
from telegram.helpers import escape_markdown
from google.generativeai.types import HarmCategory, HarmBlockThreshold
import os
TEST_MODE = False# Настройка логирования 📝
# Замените старый список состояний на этот, более полный
# Вставьте этот блок в начало файла вместо всех старых определений
(
    # Ветка стандартной аренды
    AWAIT_BIKE_NUMBER_RENT,         # 500: Ожидание номера для аренды
    AWAIT_BATTERY_COUNT,            # 501: Ожидание кол-ва батарей
    AWAIT_BATTERY_NUMS,             # 502: Ожидание номеров батарей

    # Ветка стандартного выкупа
    AWAIT_BIKE_NUMBER_BUYOUT,       # 503: Ожидание номера для выкупа

    # Ветка кастомной сделки
    AWAIT_CUSTOM_DESC,              # 504: Ожидание описания кастомного комплекта
    AWAIT_CUSTOM_RENT_PRICE,        # 505: Ожидание цены для кастомной аренды
    AWAIT_CUSTOM_BUYOUT_PLAN,       # 506: Ожидание описания плана для кастомного выкупа
    AWAIT_CUSTOM_CONFIRM,           # 507: Ожидание финального подтверждения кастомной сделки
) = range(500, 508)

(EXP_SELECT_CATEGORY, EXP_SELECT_SUBCATEGORY, EXP_AWAIT_AMOUNT,
 EXP_AWAIT_ITEM_NAME, EXP_AWAIT_QUANTITY, EXP_AWAIT_COMMENT) = range(1000, 1006)

# Состояния для диалога генерации отчета
AWAIT_EXPENSE_REPORT_DATES = range(1006, 1007)

# Структурированный словарь для меню расходов
EXPENSE_CATEGORIES = {
    'fixed': {
        'label': '🏢 Постоянные расходы',
        'subcategories': {
            'rent': 'Аренда помещения',
            'salary': 'Зарплата',
            'taxes': 'Налоги',
            'bot_maint': 'Обслуживание бота',
            'gps_sub': 'Абонентка GPS',  # <-- ВОТ НОВАЯ КНОПКА
            'other': {'label': 'Другое', 'is_complex': True}
        }
    },
    'variable': {
        'label': '🚚 Переменные расходы',
        'subcategories': {
            'repair': 'Ремонт (внешний)', 'cleaning': 'Мойка', 'ads': 'Реклама', 'taxi': 'Такси/Логистика',
            'branding': 'Брендинг', 'misc': 'Прочие расходы',
            'other': {'label': 'Другое', 'is_complex': True} # <-- ДОБАВЛЕНО
        }
    },
    'inventory': {
        'label': '🔩 Закупка инвентаря',
        'subcategories': {
            'parts': {'label': 'Запчасти', 'is_complex': True},
            'accessories': {'label': 'Аксессуары', 'is_complex': True},
            'other': {'label': 'Другое', 'is_complex': True} # <-- ДОБАВЛЕНО
        }
    },
    'capital': {
        'label': '🚲 Крупные покупки',
        'subcategories': {
            'bike': 'Велосипед', 'battery': 'Аккумуляторы', 'tracker': 'Трекеры',
            'other': {'label': 'Другое', 'is_complex': True} # <-- ДОБАВЛЕНО
        }
    }
}
GEMINI_API_URL = "https://gemini-npxg.onrender.com"
DEAL_ENTER_BUYOUT_DESC = range(209, 210) # Добавляем новое состояние
GEMINI_API_KEY = "AIzaSyAUay_xvRT_gcMYs3-7i8Pcli680Or5Zwk   "
from yookassa import Configuration, Payment
import uuid # Для генерации ключа идемпотентности
SELECTING_DATE, SELECTING_TIME, CONFIRMING_BOOKING = range(3, 6) # Начинаем с 3, чтобы не пересекаться с другими
# Добавьте эти состояния к вашему списку
CUSTOM_EXTENSION_DAYS, AWAIT_CUSTOM_PRICE = range(100, 102)
USER_AWAIT_CUSTOM_DAYS = range(300, 301) # Используем большое число, чтобы не пересекаться с другими
# ...
# ВАШИ КЛЮЧИ ИЗ ЛИЧНОГО КАБИНЕТА ЮKASSA
YOOKASSA_SHOP_ID = "1095349"      # Вставьте сюда ваш shopId
YOOKASSA_SECRET_KEY = "live_jv9Fmr_2NGwri_EE4std8wgRb_dURL0bwtYrqhal3M0" # Вставьте сюда ваш секретный ключ
# Настраиваем SDK ЮKassa
Configuration.account_id = YOOKASSA_SHOP_ID
Configuration.secret_key = YOOKASSA_SECRET_KEY
import os
# Настройка логирования 📝
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# --- АДАПТАЦИЯ ПУТЕЙ ДЛЯ RAILWAY ---
VOLUME_PATH = os.environ.get('RAILWAY_VOLUME_MOUNT_PATH', '.')
DB_FILE = os.path.join(VOLUME_PATH, 'bikes.db')
PERSISTENCE_PATH = os.path.join(VOLUME_PATH, 'bot_persistence')
USER_PROFILES_PATH = os.path.join(VOLUME_PATH, 'user_profiles')
REPORTS_PATH = os.path.join(VOLUME_PATH, 'reports')
DOCUMENTS_PATH = os.path.join(VOLUME_PATH, 'user_documents') # <-- Добавил путь для документов

# Убедимся, что директории существуют
os.makedirs(os.path.dirname(DB_FILE), exist_ok=True)
os.makedirs(os.path.dirname(PERSISTENCE_PATH), exist_ok=True)
os.makedirs(USER_PROFILES_PATH, exist_ok=True)
os.makedirs(REPORTS_PATH, exist_ok=True)
os.makedirs(DOCUMENTS_PATH, exist_ok=True) # <-- Создаем папку для документов
# Список ID администраторов 👨‍💼
ADMIN_IDS = [752012766, 7999671823]  # Здесь нужно указать ID администраторов
MASTER_IDS = [752012766]
RENTAL_PRICES = {
    14: 6500,  # 2 недели = 6500 руб.
    30: 12600  # 30 дней = 15000 руб. (как 4 недели по старому тарифу)
}
SELECT_BUYOUT_PLAN, CONFIRM_BUYOUT = range(2)
# ### НОВАЯ ПРАВКА ### Тарифы на выкуп
# ### НОВАЯ, УЛУЧШЕННАЯ СТРУКТУРА ТАРИФОВ ###
# short_label - для кнопок, full_label - для экрана подтверждения
# ### ИЗМЕНЕНИЕ: Новая тарифная сетка для выкупа ###
# ### НОВАЯ, УЛУЧШЕННАЯ СТРУКТУРА ТАРИФОВ ###
# short_label - для кнопок, full_label - для экрана подтверждения
# ВСТАВЬТЕ ЭТОТ КОД В БЛОК С КОНСТАНТАМИ

# --- НОВЫЕ КОНСТАНТЫ ДЛЯ ТИПОВ ПРОДУКТОВ ---
# --- СТАРЫЕ КОНСТАНТЫ (остаются без изменений) ---
PRODUCT_TYPE_BIKE = 'bike'
PRODUCT_TYPE_BATTERY = 'battery'

# ШАГ 1: ПОЛНОСТЬЮ ЗАМЕНИТЕ СТАРЫЕ КОНСТАНТЫ НА ЭТИ

# Тарифы на АРЕНДУ (оставляем старую структуру, но добавляем разные сроки)
RENTAL_PRICES = {
    # Цены за неделю (7 дней)
    'kugoo_jl_7': 3500,      # <-- Ключ для Kugoo (по 'JL' в названии)
    'liming_esm_7': 3500,    # <-- Ключ для Liming (по 'ESM' в названии)
    'kugoo_2akb_7': 4500,
    'wenbox_7': 5000,
    'akb_7': 1000,

    # Цены за 2 недели (14 дней)
    'kugoo_jl_14': 7000,
    'liming_esm_14': 7000,
    'kugoo_2akb_14': 9000,
    'wenbox_14': 10000,

    # Цены за 30 дней
    'kugoo_jl_30': 13000,
    'liming_esm_30': 13000,
    'kugoo_2akb_30': 15000,
    'wenbox_30': 19000,
}

# Тарифы на ВЫКУП
BUYOUT_PLANS = {
    'kugoo_jl_buyout': {      # <-- Ключ для Kugoo
        "short_label": "15 нед. / 5000 ₽",
        "full_label": "Kugoo (JL): 15 платежей по 5 000 ₽ (раз в неделю)",
        "first_payment": 5000,
        "total_payments": 15,
        "period_days": 7
    },
    'liming_esm_buyout': {    # <-- Ключ для Liming
        "short_label": "15 нед. / 5000 ₽",
        "full_label": "Liming (ESM): 15 платежей по 5 000 ₽ (раз в неделю)",
        "first_payment": 5000,
        "total_payments": 15,
        "period_days": 7
    },
    'kugoo_2akb_buyout': {
        "short_label": "15 нед. / 6000 ₽",
        "full_label": "Kugoo 2АКБ: 15 платежей по 6 000 ₽ (раз в неделю)",
        "first_payment": 6000,
        "total_payments": 15,
        "period_days": 7
    },
    'wenbox_buyout': {
        "short_label": "20 нед. / 6000 ₽",
        "full_label": "Wenbox U3: 20 платежей по 6 000 ₽ (раз в неделю)",
        "first_payment": 6000,
        "total_payments": 20,
        "period_days": 7
    },
}

# Тарифы на АРЕНДУ АКБ
BATTERY_RENTAL_PRICES = {
    '60V21Ah': {
        'initial_months': 2,
        'initial_price': 3300 * 2,
        'monthly_price': 3300
    },
    '60V30Ah': {
        'initial_months': 2,
        'initial_price': 4500 * 2,
        'monthly_price': 4500
    }
}

# Тарифы на ВЫКУП (рассрочку) АКБ
BATTERY_BUYOUT_PLANS = {
    '60V21Ah': {
        'initial_payment': 7000,
        'plans': {
            '1m_biweekly': {"label": "1 мес (2 пл. по 6500р)", "payment": 6500, "count": 2, "period_days": 14},
            '2m_monthly':  {"label": "2 мес (2 пл. по 7300р)", "payment": 7300, "count": 2, "period_days": 30},
            '3m_monthly':  {"label": "3 мес (3 пл. по 5300р)", "payment": 5300, "count": 3, "period_days": 30},
            '4m_monthly':  {"label": "4 мес (4 пл. по 4300р)", "payment": 4300, "count": 4, "period_days": 30},
            '5m_monthly':  {"label": "5 мес (5 пл. по 3800р)", "payment": 3800, "count": 5, "period_days": 30},
        }
    },
    '60V30Ah': {
        'initial_payment': 10000,
        'plans': {
            '1m_biweekly': {"label": "1 мес (2 пл. по 8500р)", "payment": 8500, "count": 2, "period_days": 14},
            '2m_monthly':  {"label": "2 мес (2 пл. по 9500р)", "payment": 9500, "count": 2, "period_days": 30},
            '3m_monthly':  {"label": "3 мес (3 пл. по 7000р)", "payment": 7000, "count": 3, "period_days": 30},
            '4m_monthly':  {"label": "4 мес (4 пл. по 5500р)", "payment": 5500, "count": 4, "period_days": 30},
            '5m_monthly':  {"label": "5 мес (5 пл. по 4900р)", "payment": 4900, "count": 5, "period_days": 30},
        }
    }
}
API_TOKEN = '7393557373:AAFB6NTTd551raYDASM7d1XhvP9wAFlVmpY'
PROVIDER_TOKEN = '381764678:TEST:128374'
SHOP_ID = '357190'  # Ваш shop_id
CURRENCY = "RUB"
logging.basicConfig(level=logging.INFO)

class Config:
    def __init__(self, shop_id):
        self.provider_token = PROVIDER_TOKEN  # Убедитесь, что PROVIDER_TOKEN объявлён
        self.shop_id = shop_id
try:
    if GEMINI_API_KEY:
        setup_gemini_api(GEMINI_API_KEY)
        logger.info("Gemini API успешно настроен при запуске бота.")
    else:
        logger.critical("КРИТИЧЕСКАЯ ОШИБКА: GEMINI_API_KEY не указан.")
except Exception as e:
    logger.critical(f"КРИТИЧЕСКАЯ ОШИБКА при настройке Gemini API: {e}.")
# Создание конфигурации
config = Config(SHOP_ID)  # Передайте ваш конкретный идентификатор магазина

# Подключение базы данных 📚
# Подключение базы данных 📚
def setup_database():
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Создание таблицы для запчастей
        cursor.execute('''CREATE TABLE IF NOT EXISTS parts (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT,
                        description TEXT,
                        quantity REAL,
                        available INTEGER DEFAULT 1,
                        photo_url TEXT)''')
        cursor.execute('''CREATE TABLE IF NOT EXISTS discounts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                admin_id INTEGER NOT NULL,
                percentage INTEGER NOT NULL,
                reason TEXT,
                expiry_date TEXT NOT NULL,
                is_used INTEGER DEFAULT 0, -- 0 = не использована, 1 = использована
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id),
                FOREIGN KEY (admin_id) REFERENCES users(id)
                )''')

        # Создание таблицы для велосипедов
        cursor.execute('''CREATE TABLE IF NOT EXISTS bikes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT,
                    description TEXT,
                    price REAL,
                    available INTEGER DEFAULT 1,
                    photo_url TEXT,
                    repair_status TEXT,
                    repair_reason TEXT,
                    repair_date TEXT,
                    reserved_date TEXT DEFAULT NULL,
                    reserved_by INTEGER DEFAULT NULL)''')

        # ### ПРАВИЛЬНАЯ ВЕРСИЯ ### Создание таблицы для пользователей с колонкой is_new_user
        cursor.execute('''CREATE TABLE IF NOT EXISTS users (
         id INTEGER PRIMARY KEY,
         username TEXT,
         first_name TEXT,
         last_name TEXT,
         tg_username TEXT,
         phone_number TEXT,
         delivery_service TEXT,
         courier_app_screenshot TEXT,
         payment_plan TEXT,
         rental_period TEXT,
         experience TEXT,
         storage TEXT,
         passport_photo TEXT,
         source_of_info TEXT,
         verified INTEGER DEFAULT 0,
         is_new_user INTEGER DEFAULT 1,
         last_booking_date TEXT DEFAULT NULL,
         country TEXT,
         passport_data TEXT,  -- <--- ВОТ ЗДЕСЬ НУЖНА ЗАПЯТАЯ
         last_booking_date TEXT DEFAULT NULL
)''')

        # Создание таблицы для бронирований
        cursor.execute('''CREATE TABLE IF NOT EXISTS bookings (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            user_id INTEGER,
                            bike_id INTEGER,
                            booking_date TEXT,
                            end_date TEXT DEFAULT NULL,
                            status TEXT DEFAULT "pending",
                            booking_type TEXT DEFAULT "rent",
                            payment_plan_key TEXT,
                            payments_made INTEGER DEFAULT 0,
                            next_payment_date TEXT,
                            FOREIGN KEY(user_id) REFERENCES users(id),
                            FOREIGN KEY(bike_id) REFERENCES bikes(id))''')

        # Создание таблицы для вопросов
        cursor.execute('''CREATE TABLE IF NOT EXISTS questions (
                           id INTEGER PRIMARY KEY AUTOINCREMENT,
                           user_id INTEGER,
                           username TEXT,
                           question TEXT,
                           answer TEXT DEFAULT NULL,
                           FOREIGN KEY(user_id) REFERENCES users(id))''')

        cursor.execute('''CREATE TABLE IF NOT EXISTS notifications (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    message TEXT,
                    timestamp TEXT NOT NULL,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP)''')

        cursor.execute('''CREATE TABLE IF NOT EXISTS attendance (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    timestamp TEXT,
                    status TEXT,
                    latitude REAL,
                    longitude REAL,
                    FOREIGN KEY(user_id) REFERENCES users(id))''')

        cursor.execute('''CREATE TABLE IF NOT EXISTS bike_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    bike_id INTEGER,
                    user_id INTEGER,
                    action TEXT,
                    timestamp TEXT,
                    details TEXT,
                    FOREIGN KEY(bike_id) REFERENCES bikes(id),
                    FOREIGN KEY(user_id) REFERENCES users(id))''')

        # Создание таблицы для заявок на продление
        cursor.execute('''CREATE TABLE IF NOT EXISTS extension_requests (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    booking_id INTEGER,
                    photo TEXT,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    status TEXT DEFAULT NULL,
                    FOREIGN KEY(booking_id) REFERENCES bookings(id))''')

        cursor.execute('''CREATE TABLE IF NOT EXISTS queue (
                          id INTEGER PRIMARY KEY AUTOINCREMENT,
                          user_id INTEGER,
                          bike_id INTEGER,
                          queue INTEGER,
                          created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                          status TEXT DEFAULT "pending",
                          FOREIGN KEY(user_id) REFERENCES users(id))''')

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS repair_requests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                bike_id INTEGER,
                description TEXT,
                status TEXT DEFAULT "ozhidaet",
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                estimated_time TEXT DEFAULT NULL,
                estimated_price TEXT DEFAULT NULL,
                completed_at TEXT DEFAULT NULL,
                is_warranty INTEGER,
                delay_reason TEXT,
                left_at TEXT,
                expected_completion_date TEXT,
                FOREIGN KEY(user_id) REFERENCES users(id),
                FOREIGN KEY(bike_id) REFERENCES bikes(id)
            )''')

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS repair_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                bike_id INTEGER,
                repair_start_date TEXT,
                repair_end_date TEXT,
                repair_person TEXT,
                reason TEXT,
                is_warranty INTEGER,
                warranty_amount REAL,
                estimated_completion_date TEXT,
                delay_reason TEXT,
                FOREIGN KEY (bike_id) REFERENCES bikes(id)
            )''')

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS fines (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                admin_id INTEGER NOT NULL,
                amount REAL NOT NULL,
                reason TEXT NOT NULL,
                status TEXT CHECK(status IN ('unpaid', 'paid', 'disputed', 'cancelled')) DEFAULT 'unpaid',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                due_date TEXT,
                payment_date TEXT,
                dispute_photo TEXT,
                dispute_video TEXT,
                dispute_comment TEXT,
                dispute_status TEXT CHECK(dispute_status IN ('none', 'pending', 'approved', 'rejected')) DEFAULT 'none',
                FOREIGN KEY (user_id) REFERENCES users(id),
                FOREIGN KEY (admin_id) REFERENCES users(id)
            )''')

        # Создание индексов для повышения производительности
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_user_id ON bookings (user_id);")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_bike_id ON bookings (bike_id);")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_username ON questions (username);")

        conn.commit()
        logger.info("База данных успешно настроена.")
    except sqlite3.Error as e:
        logger.error(f"Ошибка при настройке базы данных: {e}")
    finally:
        if conn:
            conn.close()

# Проверка, является ли пользователь администратором 🏅
def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
)
from datetime import datetime, timedelta
import sqlite3
import logging
(
    BEXP_AWAIT_BIKE_NAME,
    BEXP_AWAIT_EXPENSE_NAME,
    BEXP_AWAIT_AMOUNT,
    BEXP_AWAIT_COMMENT
) = range(1100, 1104)
# === КОНЕЦ НОВОГО БЛОКА ===


async def start_bike_specific_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1 (для велика): Запрашивает название/номер велосипеда."""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Введите название и номер велосипеда (например, 'Монстр 312123213'):")
    return BEXP_AWAIT_BIKE_NAME

async def get_bike_name_for_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (для велика): Получает имя, запрашивает расход."""
    context.user_data['bike_expense_bike_name'] = update.message.text
    await update.message.reply_text("Введите наименование расхода (например, 'Замена тормозов'):")
    return BEXP_AWAIT_EXPENSE_NAME

async def get_expense_name_for_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 3 (для велика): Получает расход, запрашивает сумму."""
    context.user_data['bike_expense_name'] = update.message.text
    await update.message.reply_text("Введите сумму расхода в рублях:")
    return BEXP_AWAIT_AMOUNT

async def get_amount_for_bike_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 4 (для велика): Получает сумму, запрашивает комментарий."""
    try:
        amount = float(update.message.text.replace(',', '.'))
        if amount <= 0: raise ValueError
        context.user_data['bike_expense_amount'] = amount
        keyboard = [[InlineKeyboardButton("Пропустить", callback_data="bexp_skip_comment")]]
        await update.message.reply_text(
            "При необходимости, добавьте комментарий. Или нажмите 'Пропустить'.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return BEXP_AWAIT_COMMENT
    except ValueError:
        await update.message.reply_text("❌ Введите корректную сумму (положительное число).")
        return BEXP_AWAIT_AMOUNT

async def save_bike_specific_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Финальный шаг: Собирает все вместе и сохраняет в БД, не меняя её структуру."""
    user_comment = update.message.text if update.message else ""
    data = context.user_data
    
    # --- ГЛАВНЫЙ ФОКУС: Пихаем имя велика в комментарий ---
    final_comment = f"Велосипед: {data['bike_expense_bike_name']}. {user_comment}".strip()

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            # Записываем в существующую таблицу, используя стандартные категории
            await conn.execute(
                """INSERT INTO expenses (admin_id, category, subcategory, item_name, amount, comment)
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    update.effective_user.id,
                    'variable',  # Логично, что расход на велик - переменный
                    'repair',    # Чаще всего это ремонт или запчасти
                    data['bike_expense_name'],
                    data['bike_expense_amount'],
                    final_comment # Здесь и имя велика, и опциональный коммент админа
                )
            )
            await conn.commit()
        
        final_message = f"✅ Расход на сумму {data['bike_expense_amount']} ₽ для велосипеда '{data['bike_expense_bike_name']}' успешно записан!"
        if update.callback_query:
            await update.callback_query.edit_message_text(final_message)
        else:
            await update.message.reply_text(final_message)
            
    except Exception as e:
        logger.error(f"Ошибка сохранения расхода на велосипед: {e}", exc_info=True)
        await update.effective_message.reply_text("❌ Произошла ошибка при сохранении данных.")
    
    context.user_data.clear()
    return ConversationHandler.END
async def start_expense_logging(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Показывает главные категории расходов."""
    if not is_admin(update.message.from_user.id):
        await update.message.reply_text("🚫 Доступ запрещен.")
        return ConversationHandler.END

    context.user_data.clear()
    context.user_data['expense_data'] = {'admin_id': update.message.from_user.id}

    keyboard = [
        [InlineKeyboardButton(details['label'], callback_data=f"exp_cat_{cat}")]
        for cat, details in EXPENSE_CATEGORIES.items()
    ]
    keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="exp_cancel")])

    await update.message.reply_text(
        "💰 *Учет расходов*\n\nВыберите основную категорию:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return EXP_SELECT_CATEGORY

async def select_main_category(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Принимает главную категорию и показывает подкатегории ИЛИ запускает ветку для велосипедов."""
    query = update.callback_query
    await query.answer()

    if query.data == "exp_cancel":
        await query.edit_message_text("Действие отменено.")
        return ConversationHandler.END

    category_key = '_'.join(query.data.split('_')[2:])
    
    # <<< ВОТ ЭТА ПРОВЕРКА >>>
    if category_key == 'bike_specific':
        # Если выбрали "Велосипеды", запускаем наш новый диалог
        return await start_bike_specific_expense(update, context)
    # <<< КОНЕЦ ПРОВЕРКИ >>>

    context.user_data['expense_data']['category'] = category_key
    category_info = EXPENSE_CATEGORIES[category_key]

    keyboard = []
    for sub_key, sub_details in category_info['subcategories'].items():
        label = sub_details['label'] if isinstance(sub_details, dict) else sub_details
        keyboard.append([InlineKeyboardButton(label, callback_data=f"exp_sub_{sub_key}")])

    keyboard.append([InlineKeyboardButton("⬅️ Назад", callback_data="exp_back_to_main")])

    await query.edit_message_text(
        f"Выбрано: *{category_info['label']}*\n\nТеперь выберите подкатегорию:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return EXP_SELECT_SUBCATEGORY
(
    EXP_SELECT_CATEGORY, EXP_SELECT_SUBCATEGORY, EXP_AWAIT_AMOUNT,
    EXP_AWAIT_ITEM_NAME, EXP_AWAIT_QUANTITY, EXP_AWAIT_COMMENT
) = range(1000, 1006)

(
    BEXP_AWAIT_BIKE_NAME,
    BEXP_AWAIT_EXPENSE_NAME,
    BEXP_AWAIT_AMOUNT,
    BEXP_AWAIT_COMMENT
) = range(1100, 1104)

# --- Структура категорий с новой кнопкой ---
EXPENSE_CATEGORIES = {
    'fixed': {
        'label': '🏢 Постоянные расходы',
        'subcategories': { 'rent': 'Аренда помещения', 'salary': 'Зарплата', 'taxes': 'Налоги', 'bot_maint': 'Обслуживание бота', 'gps_sub': 'Абонентка GPS', 'other': {'label': 'Другое', 'is_complex': True} }
    },
    'variable': {
        'label': '🚚 Переменные расходы',
        'subcategories': { 'repair': 'Ремонт (внешний)', 'cleaning': 'Мойка', 'ads': 'Реклама', 'taxi': 'Такси/Логистика', 'branding': 'Брендинг', 'misc': 'Прочие расходы', 'other': {'label': 'Другое', 'is_complex': True} }
    },
    'inventory': {
        'label': '🔩 Закупка инвентаря',
        'subcategories': { 'parts': {'label': 'Запчасти', 'is_complex': True}, 'accessories': {'label': 'Аксессуары', 'is_complex': True}, 'other': {'label': 'Другое', 'is_complex': True} }
    },
    'capital': {
        'label': '🚲 Крупные покупки',
        'subcategories': { 'bike': 'Велосипед', 'battery': 'Аккумуляторы', 'tracker': 'Трекеры', 'other': {'label': 'Другое', 'is_complex': True} }
    },
    'bike_specific': {
        'label': '🚲 Велосипеды (расходы)',
        'subcategories': {} # Пустой, потому что дальше своя логика
    }
}

# --- ОБЩИЕ РАСХОДЫ (старый функционал) ---

async def start_expense_logging(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Показывает главные категории расходов."""
    if not is_admin(update.message.from_user.id):
        await update.message.reply_text("🚫 Доступ запрещен.")
        return ConversationHandler.END

    context.user_data.clear()
    context.user_data['expense_data'] = {'admin_id': update.message.from_user.id}

    keyboard = [
        [InlineKeyboardButton(details['label'], callback_data=f"exp_cat_{cat}")]
        for cat, details in EXPENSE_CATEGORIES.items()
    ]
    keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="exp_cancel")])

    await update.message.reply_text(
        "💰 *Учет расходов*\n\nВыберите основную категорию:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return EXP_SELECT_CATEGORY

async def select_main_category(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Принимает главную категорию, показывает подкатегории ИЛИ запускает ветку для велосипедов."""
    query = update.callback_query
    await query.answer()

    if query.data == "exp_cancel":
        await query.edit_message_text("Действие отменено.")
        return ConversationHandler.END

    category_key = '_'.join(query.data.split('_')[2:])
    
    # <<< ВОТ ГЛАВНАЯ ПРОВЕРКА >>>
    if category_key == 'bike_specific':
        return await start_bike_specific_expense(update, context)

    context.user_data['expense_data']['category'] = category_key
    category_info = EXPENSE_CATEGORIES[category_key]

    keyboard = []
    for sub_key, sub_details in category_info['subcategories'].items():
        label = sub_details['label'] if isinstance(sub_details, dict) else sub_details
        keyboard.append([InlineKeyboardButton(label, callback_data=f"exp_sub_{sub_key}")])
    keyboard.append([InlineKeyboardButton("⬅️ Назад", callback_data="exp_back_to_main")])

    await query.edit_message_text(
        f"Выбрано: *{category_info['label']}*\n\nТеперь выберите подкатегорию:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return EXP_SELECT_SUBCATEGORY

# ... (все остальные функции для общих расходов: select_subcategory, get_item_name, get_quantity, get_amount, save_expense) ...
# ВАЖНО: Убедись, что ты скопировал их из своего старого кода, если удалил. Если нет - вот они:
async def select_subcategory(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    if query.data == "exp_back_to_main":
        await query.message.delete()
        return await start_expense_logging(query, context)
    subcategory_key = '_'.join(query.data.split('_')[2:])
    expense_data = context.user_data['expense_data']
    expense_data['subcategory'] = subcategory_key
    main_category = EXPENSE_CATEGORIES[expense_data['category']]
    subcategory_info = main_category['subcategories'][subcategory_key]
    is_complex = isinstance(subcategory_info, dict) and subcategory_info.get('is_complex', False)
    if is_complex:
        await query.edit_message_text("Введите наименование товара/расхода:")
        return EXP_AWAIT_ITEM_NAME
    else:
        await query.edit_message_text("Введите сумму расхода в рублях:")
        return EXP_AWAIT_AMOUNT
async def get_item_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['expense_data']['item_name'] = update.message.text
    await update.message.reply_text("Введите количество (шт.):")
    return EXP_AWAIT_QUANTITY
async def get_quantity(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        context.user_data['expense_data']['quantity'] = int(update.message.text)
        await update.message.reply_text("Введите ОБЩУЮ сумму:")
        return EXP_AWAIT_AMOUNT
    except ValueError:
        await update.message.reply_text("Введите корректное количество.")
        return EXP_AWAIT_QUANTITY
async def get_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        context.user_data['expense_data']['amount'] = float(update.message.text.replace(',', '.'))
        keyboard = [[InlineKeyboardButton("Пропустить", callback_data="exp_skip_comment")]]
        await update.message.reply_text("Добавьте комментарий или пропустите.", reply_markup=InlineKeyboardMarkup(keyboard))
        return EXP_AWAIT_COMMENT
    except ValueError:
        await update.message.reply_text("Введите корректную сумму.")
        return EXP_AWAIT_AMOUNT
async def save_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    comment = update.message.text if update.message else None
    expense_data = context.user_data['expense_data']
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute(
                "INSERT INTO expenses (admin_id, category, subcategory, item_name, quantity, amount, comment) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (expense_data['admin_id'], expense_data['category'], expense_data['subcategory'], expense_data.get('item_name'), expense_data.get('quantity'), expense_data['amount'], comment)
            )
            await conn.commit()
        msg = f"✅ Расход на сумму {expense_data['amount']} ₽ записан!"
        if update.callback_query: await update.callback_query.edit_message_text(msg)
        else: await update.message.reply_text(msg)
    except Exception as e:
        logger.error(f"Ошибка сохранения расхода: {e}")
        await update.effective_message.reply_text("❌ Ошибка сохранения.")
    context.user_data.clear()
    return ConversationHandler.END

MOSCOW_TZ = pytz.timezone('Europe/Moscow')
# --- РАСХОДЫ НА КОНКРЕТНЫЙ ВЕЛОСИПЕД (новый функционал) ---

async def start_bike_specific_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1 (для велика): Запрашивает название/номер велосипеда."""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Введите название и номер велосипеда (например, 'Монстр 312123213'):")
    return BEXP_AWAIT_BIKE_NAME

async def get_bike_name_for_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (для велика): Получает имя, запрашивает расход."""
    context.user_data['bike_expense_bike_name'] = update.message.text
    await update.message.reply_text("Введите наименование расхода (например, 'Замена тормозов'):")
    return BEXP_AWAIT_EXPENSE_NAME

async def get_expense_name_for_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 3 (для велика): Получает расход, запрашивает сумму."""
    context.user_data['bike_expense_name'] = update.message.text
    await update.message.reply_text("Введите сумму расхода в рублях:")
    return BEXP_AWAIT_AMOUNT

async def get_amount_for_bike_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 4 (для велика): Получает сумму, запрашивает комментарий."""
    try:
        amount = float(update.message.text.replace(',', '.'))
        if amount <= 0: raise ValueError
        context.user_data['bike_expense_amount'] = amount
        keyboard = [[InlineKeyboardButton("Пропустить", callback_data="bexp_skip_comment")]]
        await update.message.reply_text(
            "При необходимости, добавьте комментарий. Или нажмите 'Пропустить'.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return BEXP_AWAIT_COMMENT
    except ValueError:
        await update.message.reply_text("❌ Введите корректную сумму (положительное число).")
        return BEXP_AWAIT_AMOUNT

async def save_bike_specific_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Финальный шаг: Собирает все вместе и сохраняет в БД, не меняя её структуру."""
    user_comment = update.message.text if update.message else ""
    data = context.user_data
    
    # --- ГЛАВНЫЙ ФОКУС: Пихаем имя велика в комментарий ---
    final_comment = f"Велосипед: {data['bike_expense_bike_name']}. {user_comment}".strip()

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute(
                """INSERT INTO expenses (admin_id, category, subcategory, item_name, amount, comment)
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    update.effective_user.id,
                    'variable',  # Расход на велик всегда переменный
                    'repair',    # Чаще всего это ремонт или запчасти
                    data['bike_expense_name'],
                    data['bike_expense_amount'],
                    final_comment
                )
            )
            await conn.commit()
        
        final_message = f"✅ Расход {data['bike_expense_amount']} ₽ на '{data['bike_expense_bike_name']}' записан!"
        if update.callback_query:
            await update.callback_query.edit_message_text(final_message)
        else:
            await update.message.reply_text(final_message)
            
    except Exception as e:
        logger.error(f"Ошибка сохранения расхода на велик: {e}", exc_info=True)
        await update.effective_message.reply_text("❌ Ошибка сохранения.")
    
    context.user_data.clear()
    return ConversationHandler.END
async def select_subcategory(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 3: Принимает подкатегорию и решает, что запрашивать дальше."""
    query = update.callback_query
    await query.answer()

    if query.data == "exp_back_to_main":
        # --- НАЧАЛО ИСПРАВЛЕНИЯ ---
        # Правильно возвращаемся на первый шаг, редактируя сообщение
        context.user_data.pop('expense_data', None) # Чистим старый выбор
        context.user_data['expense_data'] = {'admin_id': query.from_user.id}

        keyboard = [
            [InlineKeyboardButton(details['label'], callback_data=f"exp_cat_{cat}")]
            for cat, details in EXPENSE_CATEGORIES.items()
        ]
        keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="exp_cancel")])
        await query.edit_message_text(
            "💰 *Учет расходов*\n\nВыберите основную категорию:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return EXP_SELECT_CATEGORY
        # --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    subcategory_key = '_'.join(query.data.split('_')[2:])
    expense_data = context.user_data['expense_data']
    expense_data['subcategory'] = subcategory_key
    
    main_category = EXPENSE_CATEGORIES[expense_data['category']]
    subcategory_info = main_category['subcategories'][subcategory_key]
    is_complex = isinstance(subcategory_info, dict) and subcategory_info.get('is_complex', False)
    
    if is_complex:
        await query.edit_message_text("Введите наименование товара/расхода (например, 'Замок Kryptonite' или 'Канцтовары'):")
        return EXP_AWAIT_ITEM_NAME
    else:
        await query.edit_message_text("Введите сумму расхода в рублях (например, 5000):")
        return EXP_AWAIT_AMOUNT

async def get_item_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 4 (для сложных): Принимает наименование, запрашивает количество."""
    context.user_data['expense_data']['item_name'] = update.message.text
    await update.message.reply_text("Введите количество (целое число, например, 10):")
    return EXP_AWAIT_QUANTITY

async def get_quantity(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 5 (для сложных): Принимает количество, запрашивает ОБЩУЮ сумму."""
    try:
        quantity = int(update.message.text)
        if quantity <= 0: raise ValueError
        context.user_data['expense_data']['quantity'] = quantity
        await update.message.reply_text(f"Введите ОБЩУЮ сумму за {quantity} шт.:")
        return EXP_AWAIT_AMOUNT
    except ValueError:
        await update.message.reply_text("❌ Введите корректное количество (целое положительное число).")
        return EXP_AWAIT_QUANTITY

async def get_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 6: Принимает сумму, запрашивает комментарий."""
    try:
        amount = float(update.message.text.replace(',', '.'))
        if amount <= 0: raise ValueError
        context.user_data['expense_data']['amount'] = amount
        keyboard = [[InlineKeyboardButton("Пропустить", callback_data="exp_skip_comment")]]
        await update.message.reply_text(
            "При необходимости, добавьте комментарий. Или нажмите 'Пропустить'.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return EXP_AWAIT_COMMENT
    except ValueError:
        await update.message.reply_text("❌ Введите корректную сумму (положительное число).")
        return EXP_AWAIT_AMOUNT

async def save_expense(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Финальный шаг: Сохраняет все данные в БД и завершает диалог."""
    comment = update.message.text if update.message else None
    expense_data = context.user_data['expense_data']
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute(
                """INSERT INTO expenses (admin_id, category, subcategory, item_name, quantity, amount, comment)
                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
                (
                    expense_data['admin_id'], expense_data['category'], expense_data['subcategory'],
                    expense_data.get('item_name'), expense_data.get('quantity'),
                    expense_data['amount'], comment
                )
            )
            await conn.commit()
        
        final_message = f"✅ Расход на сумму {expense_data['amount']} ₽ успешно записан!"
        if update.callback_query:
            await update.callback_query.edit_message_text(final_message)
        else:
            await update.message.reply_text(final_message)
            
    except Exception as e:
        logger.error(f"Ошибка сохранения расхода: {e}", exc_info=True)
        await update.effective_message.reply_text("❌ Произошла ошибка при сохранении данных.")
    
    context.user_data.clear()
    return ConversationHandler.END

# ==============================================================================
#           НОВЫЙ МОДУЛЬ: ГЕНЕРАЦИЯ ОТЧЕТА ПО РАСХОДАМ
# ==============================================================================

async def start_report_generation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Начинает диалог генерации отчета, запрашивая даты."""
    if not is_admin(update.message.from_user.id):
        await update.message.reply_text("🚫 Доступ запрещен.")
        return ConversationHandler.END

    # --- ИЗМЕНЕНИЕ: Добавлена клавиатура с кнопкой отмены ---
    cancel_keyboard = ReplyKeyboardMarkup([["❌ Отмена"]], resize_keyboard=True)

    await update.message.reply_text(
        "📅 *Отчет по расходам*\n\n"
        "Введите период для отчета в формате `ДД.ММ.ГГГГ-ДД.ММ.ГГГГ`\n"
        "Например: `01.05.2024-31.05.2024`\n\n"
        "Или введите `сегодня`, `неделя`, `месяц` для быстрого отчета.",
        parse_mode="Markdown",
        reply_markup=cancel_keyboard  # <-- Добавлено
    )
    return AWAIT_EXPENSE_REPORT_DATES

async def process_date_range_for_report(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает ввод дат, генерирует и отправляет отчет."""
    user_input = update.message.text.strip().lower()
    today = datetime.now()
    start_date, end_date = None, None
    user_id = update.effective_user.id

    try:
        if user_input == 'сегодня':
            start_date = end_date = today
        elif user_input == 'неделя':
            start_date = today - timedelta(days=today.weekday())
            end_date = today
        elif user_input == 'месяц':
            start_date = today.replace(day=1)
            end_date = today
        else:
            start_str, end_str = user_input.split('-')
            start_date = datetime.strptime(start_str.strip(), '%d.%m.%Y')
            end_date = datetime.strptime(end_str.strip(), '%d.%m.%Y')
    except (ValueError, IndexError):
        await update.message.reply_text(
            "❌ Неверный формат. Пожалуйста, используйте `ДД.ММ.ГГГГ-ДД.ММ.ГГГГ` или ключевые слова."
        )
        return AWAIT_EXPENSE_REPORT_DATES

    status_message = await update.message.reply_text("⏳ Формирую отчет, пожалуйста, подождите...")

    report_filename = generate_expense_report(start_date, end_date)

    if report_filename and os.path.exists(report_filename):
        await status_message.delete()
        with open(report_filename, 'rb') as report_file:
            await update.message.reply_document(
                document=report_file,
                caption=f"📊 Отчет по расходам за период с {start_date.strftime('%d.%m.%Y')} по {end_date.strftime('%d.%m.%Y')}"
            )
        os.remove(report_filename)
    else:
        await status_message.edit_text("😔 За выбранный период расходов не найдено.")

    # --- ИЗМЕНЕНИЕ: Возвращаем пользователя в главное меню ---
    await update.message.reply_text(
        "Вы вернулись в главное меню.",
        reply_markup=get_main_menu(user_id)
    )
    return ConversationHandler.END

def parse_bike_name_and_vin(full_name: str) -> dict:
    """
    Разбирает полное имя велосипеда на модель и VIN.
    Пример: "Kugoo JL20241012781" -> {'model': 'Kugoo', 'vin': 'JL20241012781'}
    """
    vin_starters = ['JL', 'ESM', 'CNHC'] # Префиксы, с которых может начинаться VIN
    model = full_name.strip()
    vin = '(не присвоен)'

    for prefix in vin_starters:
        if prefix in full_name:
            # Разделяем строку по первому вхождению префикса
            parts = full_name.split(prefix, 1)
            model = parts[0].strip()
            vin = prefix + parts[1].strip()
            break # Нашли VIN, выходим из цикла
            
    return {'model': model, 'vin': vin}
# Определяем состояния для нового диалога
SELECT_USER_FOR_DISCOUNT, ENTER_DISCOUNT_PERCENT, ENTER_DISCOUNT_REASON, ENTER_DISCOUNT_DURATION = range(4)
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ### ИЗМЕНЕНИЕ: Функция для применения скидки ###
# ШАГ 2: ВСТАВЬТЕ ЭТУ НОВУЮ ВСПОМОГАТЕЛЬНУЮ ФУНКЦИЮ

# ШАГ 1: ПОЛНОСТЬЮ ЗАМЕНИТЕ ЭТУ ФУНКЦИЮ

import os

def select_document_template(deal_type: str, price: float) -> str | None:
    """
    Выбирает путь к файлу шаблона на основе типа сделки и суммы первого платежа.
    """
    template_dir = "contract_templates"
    filename = ""
    
    # Округляем цену до целого числа для надежного сравнения
    price_int = int(price)

    if deal_type == 'rent':
        filename = f"act_rent_{price_int}.docx"
    elif deal_type == 'buyout':
        filename = f"agreement_buyout_{price_int}.docx"
    else:
        # Если тип сделки неизвестен, возвращаем None
        return None

    full_path = os.path.join(template_dir, filename)
    
    # Проверяем, существует ли такой файл, чтобы избежать ошибок
    if os.path.exists(full_path):
        return full_path
    else:
        # Если шаблон для такой цены не найден, возвращаем None
        logging.error(f"Шаблон документа не найден: {full_path}")
        return None

def get_bike_model_key(bike_name: str) -> str | None:
    """
    ФИНАЛЬНАЯ ВЕРСИЯ: Корректно определяет ключ модели, учитывая иерархию.
    """
    bike_name_lower = bike_name.lower()

    # Сначала проверяем самые уникальные и специфичные случаи

    # 1. Проверка на отдельный аккумулятор для аренды
    if 'дополнительный акб' in bike_name_lower:
        return 'akb'

    # 2. Проверка на Wenbox
    if 'wenbox' in bike_name_lower or 'cnhc' in bike_name_lower:
        return 'wenbox'

    # 3. Проверка на Kugoo с ДВУМЯ батареями. Эта проверка должна быть ПЕРЕД
    #    проверкой на обычный Kugoo (JL), так как название может содержать и '2-акб', и 'jl'.
    if '2-акб' in bike_name_lower or '2 акб' in bike_name_lower:
        return 'kugoo_2akb'

    # 4. Проверка на Liming по идентификатору ESM
    if 'esm' in bike_name_lower:
        return 'liming_esm'

    # 5. Проверка на стандартный Kugoo по идентификатору JL
    if 'jl' in bike_name_lower:
        return 'kugoo_jl'

    # Если ничего не подошло, логируем и возвращаем None
    logger.warning(f"Не удалось определить ключ модели для: '{bike_name}'. Проверьте, содержит ли название уникальный идентификатор (Wenbox, CNHC, 2-АКБ, ESM, JL).")
    return None
def apply_discount(original_price: float, discount_amount: float) -> float:
    """
    Применяет скидку в рублях к цене.
    Возвращает новую цену, но не меньше 1.00 рубля.
    """
    if discount_amount <= 0:
        return original_price

    # Вычитаем сумму скидки
    discounted_price = original_price - discount_amount

    # Цена не может быть меньше 1 рубля (ограничение многих платежных систем)
    return max(1.00, round(discounted_price, 2))
# ### ИЗМЕНЕНИЕ: Внедрение логики скидок в создание платежа ###
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ### ИЗМЕНЕНИЕ: Внедрение логики скидок в создание платежа ###
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
# ### НОВАЯ, ОБНОВЛЕННАЯ ФУНКЦИЯ ###
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ create_yookassa_payment НА ЭТУ ВЕРСИЮ

### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
async def create_yookassa_payment(amount: int, description: str, metadata: dict, items: list, customer_info: dict, payment_method: str | None = None, bot_username: str = "@BFbikebot") -> dict | None:
    try:
        user_id = metadata.get('user_id')
        original_amount = float(amount)
        final_amount_for_payment = original_amount

        if TEST_MODE:
            final_amount_for_payment = 1.00
            logger.warning(f"ТЕСТОВЫЙ РЕЖИМ АКТИВЕН! Сумма {original_amount} заменена на {final_amount_for_payment} руб.")

        if user_id and not TEST_MODE:
            async with aiosqlite.connect(DB_FILE) as conn:
                cursor = await conn.execute(
                    "SELECT id, amount FROM discounts WHERE user_id = ? AND is_used = 0 AND expiry_date > date('now') ORDER BY created_at DESC LIMIT 1",
                    (user_id,)
                )
                active_discount = await cursor.fetchone()

            if active_discount:
                discount_id, discount_amount = active_discount
                final_amount_for_payment = apply_discount(original_amount, discount_amount)
                description += f" (с учетом скидки {discount_amount} ₽)"
                metadata['discount_id'] = discount_id
                logger.info(f"Применена скидка {discount_amount} ₽ для пользователя {user_id}. Новая сумма: {final_amount_for_payment:.2f}")

        if items and len(items) > 0:
            items[0]['amount']['value'] = f"{final_amount_for_payment:.2f}"

            # <<< ГЛАВНОЕ ИСПРАВЛЕНИЕ ЗДЕСЬ >>>
            # Проверяем, есть ли payment_subject, и если нет, или он невалидный, ставим "service" по умолчанию.
            # Это универсальное значение, которое подходит для аренды, ремонта и т.д.
            if 'payment_subject' not in items[0] or not items[0]['payment_subject']:
                items[0]['payment_subject'] = 'service'

            if 'payment_mode' not in items[0] or not items[0]['payment_mode']:
                 items[0]['payment_mode'] = 'full_payment'
            # <<< КОНЕЦ ИСПРАВЛЕНИЯ >>>

        payment_data = {
            "amount": {"value": f"{final_amount_for_payment:.2f}", "currency": "RUB"},
            "confirmation": {"type": "redirect", "return_url": f"https://t.me/{bot_username}"},
            "capture": True,
            "description": description,
            "metadata": metadata,
            "receipt": {
                "customer": customer_info,
                "items": items,
                # Убедитесь, что код системы налогообложения соответствует вашему в личном кабинете ЮKassa
                # 1 - ОСН, 2 - УСН Доход, 3 - УСН Доход-Расход, 4 - ЕСХН, 5 - Патент
                "tax_system_code": 2
            }
        }
        if payment_method:
            payment_data["payment_method_data"] = {"type": payment_method}

        payment = Payment.create(payment_data, uuid.uuid4())

        return {
            "id": payment.id,
            "url": payment.confirmation.confirmation_url,
            "final_amount": final_amount_for_payment
        }

    except BadRequestError as e:
        # Логируем полный ответ от ЮKassa для легкой отладки
        logger.error(f"Ошибка BadRequestError от ЮKassa: {e.response_body}", exc_info=True)
        return None
    except Exception as e:
        logger.error(f"Ошибка при создании платежа в ЮKassa: {e}", exc_info=True)
        return None


async def start_discount_process(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Начинает процесс выдачи скидки. Запускается кнопкой в меню."""
    admin_id = update.message.from_user.id
    if not is_admin(admin_id):
        await update.message.reply_text("🚫 Доступ запрещен.")
        return ConversationHandler.END

    context.user_data.clear()
    context.user_data['admin_id'] = admin_id
    context.user_data['discount_page'] = 0

    await show_users_for_discount(update, context)
    return SELECT_USER_FOR_DISCOUNT

async def show_users_for_discount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отображает список пользователей для выбора с пагинацией."""
    page = context.user_data.get('discount_page', 0)

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM users")
    total_users = cursor.fetchone()[0]

    cursor.execute("SELECT id, first_name, last_name FROM users ORDER BY last_name, first_name LIMIT 5 OFFSET ?", (page * 5,))
    users = cursor.fetchall()
    conn.close()

    if not users and page == 0:
        await update.effective_message.reply_text("Нет зарегистрированных пользователей.")
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton(f"{last_name or ''} {first_name or ''} (ID:{user_id})", callback_data=f"discount_user_{user_id}")]
        for user_id, first_name, last_name in users
    ]

    pagination_buttons = []
    if page > 0:
        pagination_buttons.append(InlineKeyboardButton("⬅️ Назад", callback_data="discount_prev_page"))
    if (page + 1) * 5 < total_users:
        pagination_buttons.append(InlineKeyboardButton("Вперед ➡️", callback_data="discount_next_page"))

    if pagination_buttons:
        keyboard.append(pagination_buttons)
    keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="discount_cancel")])

    message_text = f"🎁 Выберите пользователя для выдачи скидки (Стр. {page + 1}):"

    if update.callback_query:
        await update.callback_query.edit_message_text(message_text, reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await update.message.reply_text(message_text, reply_markup=InlineKeyboardMarkup(keyboard))

    return SELECT_USER_FOR_DISCOUNT

async def handle_user_selection_for_discount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает выбор пользователя или пагинацию."""
    query = update.callback_query
    await query.answer()

    if query.data == "discount_prev_page":
        context.user_data['discount_page'] = context.user_data.get('discount_page', 1) - 1
        return await show_users_for_discount(update, context)

    if query.data == "discount_next_page":
        context.user_data['discount_page'] = context.user_data.get('discount_page', 0) + 1
        return await show_users_for_discount(update, context)

    if query.data == "discount_cancel":
        await query.edit_message_text("Выдача скидки отменена.")
        context.user_data.clear()
        return ConversationHandler.END

    user_id = int(query.data.split('_')[-1])
    context.user_data['discount_user_id'] = user_id

    # ### ИЗМЕНЕНИЕ: Новый текст запроса ###
    await query.edit_message_text(f"Выбран пользователь с ID {user_id}.\n\nВведите сумму скидки в рублях (например, 500):")
    return ENTER_DISCOUNT_PERCENT # Состояние остается тем же, но теперь оно для ввода суммы

# ### ИЗМЕНЕНИЕ: Логика этой функции полностью заменена ###
async def process_discount_percent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает ввод суммы скидки в рублях."""
    try:
        # Заменяем запятую на точку для правильного преобразования в float
        amount = float(update.message.text.replace(',', '.'))
        if amount <= 0:
            raise ValueError
        context.user_data['discount_amount'] = amount # Сохраняем сумму
        await update.message.reply_text("Отлично. Теперь введите причину выдачи скидки (например, 'Бонус за лояльность'):")
        return ENTER_DISCOUNT_REASON
    except ValueError:
        await update.message.reply_text("❌ Введите корректную сумму (положительное число, например, 500 или 250.5).")
        return ENTER_DISCOUNT_PERCENT

# Эта функция остается без изменений
async def process_discount_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает ввод причины."""
    reason = update.message.text.strip()
    if not reason:
        await update.message.reply_text("❌ Причина не может быть пустой.")
        return ENTER_DISCOUNT_REASON
    context.user_data['discount_reason'] = reason
    await update.message.reply_text("Введите срок действия скидки в днях (например, 7):")
    return ENTER_DISCOUNT_DURATION

# ### ИЗМЕНЕНИЕ: Сохранение в БД и тексты уведомлений ###
async def process_discount_duration(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает срок действия, сохраняет скидку в рублях и завершает диалог."""
    try:
        duration_days = int(update.message.text)
        if duration_days <= 0:
            raise ValueError
    except ValueError:
        await update.message.reply_text("❌ Введите корректное количество дней (положительное число).")
        return ENTER_DISCOUNT_DURATION

    expiry_date = datetime.now() + timedelta(days=duration_days)
    expiry_date_str = expiry_date.strftime('%Y-%m-%d %H:%M:%S')

    user_id = context.user_data['discount_user_id']
    admin_id = context.user_data['admin_id']
    amount = context.user_data['discount_amount'] # Используем amount вместо percentage
    reason = context.user_data['discount_reason']

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    # ### ИЗМЕНЕНИЕ: Вставляем `amount` вместо `percentage` ###
    cursor.execute("""
        INSERT INTO discounts (user_id, admin_id, amount, reason, expiry_date)
        VALUES (?, ?, ?, ?, ?)
    """, (user_id, admin_id, amount, reason, expiry_date_str))
    conn.commit()
    conn.close()

    # ### ИЗМЕНЕНИЕ: Обновлен текст подтверждения ###
    await update.message.reply_text(
        f"✅ Скидка в размере {amount} ₽ успешно выдана пользователю ID {user_id}!\n"
        f"Она будет действовать {duration_days} дней.",
        reply_markup=get_main_menu(update.message.from_user.id)
    )

    try:
        # ### ИЗМЕНЕНИЕ: Обновлен текст уведомления для пользователя ###
        await context.bot.send_message(
            chat_id=user_id,
            text=f"🎉 Поздравляем! Вам начислена единоразовая скидка на сумму **{amount} ₽**!\n\n"
                 f"**Причина:** {reason}\n"
                 f"**Срок действия:** до {expiry_date.strftime('%d.%m.%Y')}\n\n"
                 "Скидка будет автоматически применена к вашему следующему платежу.",
            parse_mode="Markdown"
        )
    except Exception as e:
        logging.error(f"Не удалось отправить уведомление о скидке пользователю {user_id}: {e}")

    context.user_data.clear()
    return ConversationHandler.END

# Эта функция остается без изменений
async def cancel_discount_process(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет процесс выдачи скидки."""
    await update.message.reply_text(
        "Выдача скидки отменена.",
        reply_markup=get_main_menu(update.message.from_user.id)
    )
    context.user_data.clear()
    return ConversationHandler.END
def get_notifications_count() -> int:
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM notifications")
    count = cursor.fetchone()[0]
    conn.close()
    return count
# ### НОВАЯ, АСИНХРОННАЯ ФУНКЦИЯ ###
import aiosqlite
### НОВАЯ, АСИНХРОННАЯ ФУНКЦИЯ ###
async def log_bike_action(conn: aiosqlite.Connection, bike_id: int | None, user_id: int, action: str, details: str = None, amount: float = None):
    """
    АСИНХРОННАЯ ВЕРСИЯ ДЛЯ ЗАПИСИ В ИСТОРИЮ В РАМКАХ СУЩЕСТВУЮЩЕЙ ТРАНЗАКЦИИ.
    Принимает объект соединения `conn` и не создает новый.
    """
    try:
        details_text = details if details else ""
        if amount is not None:
            # Используем неразрывный пробел для рублей
            details_text += f", сумма: {amount:.2f}\u00A0₽"

        # Используем полный формат времени для точной сортировки
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        # Выполняем запрос на переданном соединении, не коммитим здесь
        await conn.execute(
            "INSERT INTO bike_history (bike_id, user_id, action, timestamp, details) VALUES (?, ?, ?, ?, ?)",
            (bike_id, user_id, action, timestamp, details_text) # <<< ИЗМЕНЕНИЕ: передаем details_text
        )
    except Exception as e:
        # Логируем ошибку, но не прерываем основную транзакцию
        logger.error(f"Ошибка при логировании действия в bike_history (внутри транзакции): {e}", exc_info=True)

# Основное меню 🎛️
# Основное меню 🎛️
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ get_main_menu НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ get_main_menu НА ЭТУ ВЕРСИЮ
def get_main_menu(user_id: int):
    """
    ФИНАЛЬНАЯ ИСПРАВЛЕННАЯ ВЕРСИЯ:
    Возвращает ReplyKeyboardMarkup в зависимости от роли пользователя.
    """
    if is_admin(user_id):
        notifications_count = get_notifications_count()
        keyboard = [
            ["📋 Велосипеды", "👥 Пользователи"],
            # <<< ИЗМЕНЕНИЕ: Кнопка "Отчеты по расходам" удалена отсюда >>>
            ["📩 Вопросы от пользователей", "📢 Рассылка новостей"],
            ["🗓️ Управление арендами", "📈 Инвестиции"],
            ["🚴‍ Сдать в аренду велосипед", "💰 Расходы"],
            ["🛠️ Просмотр заявок", "🔧 Ремонт"],
            ["💰 Назначить штраф", "📋 Список штрафов"],
            ["🎁 Выдать скидку", "📊 Статистика"],
            ["📊 Статистика за день"],
        ]
        notifications_button_text = f"🔔 Уведомления ({notifications_count})"
        keyboard.append([notifications_button_text])
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    # --- Пользовательская часть (без изменений) ---
    # ... (остальной код функции без изменений)
    keyboard = [
        ["👤 Личный кабинет", "💰Аренда/Выкуп"],
        ["📋 Тарифы", "🛠️ Ремонт"],
        ["📜 Правила пользования", "📞 Контакты"]
    ]
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id FROM users WHERE id=?", (user_id,))
    is_registered = cursor.fetchone() is not None
    conn.close()
    if not is_registered:
        keyboard.insert(0, ["📝 Зарегистрироваться"])
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

# --- Обработчики для статичных разделов меню ---
# <<< НАЧАЛО НОВОГО БЛОКА КОДА ДЛЯ УПРАВЛЕНИЯ ИНВЕСТИЦИЯМИ >>>
INV_SELECT_USER, INV_AWAIT_USER_SEARCH, INV_SELECT_BIKE, INV_AWAIT_BIKE_SEARCH = range(910, 914)
# Определяем состояния для диалога
# ==============================================================================
#           МОДУЛЬ УПРАВЛЕНИЯ ИНВЕСТИЦИЯМИ (ВЕРСИЯ 2.0)
# ==============================================================================

# --- Главное меню раздела "Инвестиции" ---
# ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ В ВАШ КОД

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ show_daily_stats НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ show_daily_stats НА ЭТУ ФИНАЛЬНУЮ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ show_daily_stats НА ЭТУ ВЕРСИЮ
async def show_daily_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Собирает и отображает статистику за сегодня и добавляет кнопку для выбора другой даты."""
    status_message = await update.message.reply_text("⏳ Собираю статистику за сегодня, пожалуйста, подождите...")
    
    def escape(text: str) -> str:
        return escape_markdown(str(text or ''), version=2)

    try:
        today_start_str = datetime.now().strftime('%Y-%m-%d 00:00:00')
        today = datetime.now().date()
        
        # --- Блок сбора данных (остается без изменений) ---
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            total_own = (await (await conn.execute("SELECT COUNT(*) FROM bikes WHERE investor_id IS NULL AND type='bike'")).fetchone())[0]
            total_investor = (await (await conn.execute("SELECT COUNT(*) FROM bikes WHERE investor_id IS NOT NULL AND type='bike'")).fetchone())[0]
            rented_own = (await (await conn.execute("SELECT COUNT(b.id) FROM bookings b JOIN bikes bk ON b.bike_id = bk.id WHERE b.status='rented' AND b.booking_type='rent' AND bk.investor_id IS NULL")).fetchone())[0]
            rented_investor = (await (await conn.execute("SELECT COUNT(b.id) FROM bookings b JOIN bikes bk ON b.bike_id = bk.id WHERE b.status='rented' AND b.booking_type='rent' AND bk.investor_id IS NOT NULL")).fetchone())[0]
            buyout_own = (await (await conn.execute("SELECT COUNT(b.id) FROM bookings b JOIN bikes bk ON b.bike_id = bk.id WHERE b.status='rented' AND b.booking_type='buyout' AND bk.investor_id IS NULL")).fetchone())[0]
            buyout_investor = (await (await conn.execute("SELECT COUNT(b.id) FROM bookings b JOIN bikes bk ON b.bike_id = bk.id WHERE b.status='rented' AND b.booking_type='buyout' AND bk.investor_id IS NOT NULL")).fetchone())[0]
            daily_activity = { "rent_own": 0, "rent_investor": 0, "buyout_own": 0, "buyout_investor": 0, "return_own": 0, "return_investor": 0, "income": 0.0 }
            cursor = await conn.execute("SELECT bh.action, bh.details, bk.investor_id FROM bike_history bh JOIN bikes bk ON bh.bike_id = bk.id WHERE bh.timestamp >= ?",(today_start_str,))
            async for row in cursor:
                is_investor = row['investor_id'] is not None
                if row['action'] in ('Оплата аренды', 'Аренда', 'Аренда доп. АКБ'):
                    if is_investor: daily_activity['rent_investor'] += 1
                    else: daily_activity['rent_own'] += 1
                elif row['action'] == 'Выкуп (1-й взнос)':
                    if is_investor: daily_activity['buyout_investor'] += 1
                    else: daily_activity['buyout_own'] += 1
                elif row['action'] == 'Возврат принят':
                    if is_investor: daily_activity['return_investor'] += 1
                    else: daily_activity['return_own'] += 1
                daily_activity['income'] += _get_income_from_details(row['details'])
            exp_cursor = await conn.execute("SELECT SUM(amount) FROM expenses WHERE created_at >= ?", (today_start_str,))
            daily_expenses = (await exp_cursor.fetchone())[0] or 0.0
            upcoming_payments = []
            cursor = await conn.execute("SELECT u.first_name, u.last_name, u.phone_number, u.username, b.end_date, b.next_payment_date, b.booking_type FROM bookings b JOIN users u ON b.user_id = u.id WHERE b.status='rented'")
            async for row in cursor:
                date_str = row['end_date'] if row['booking_type'] == 'rent' else row['next_payment_date']
                if not date_str: continue
                payment_date = datetime.strptime(date_str, "%d.%m.%Y").date()
                days_remaining = (payment_date - today).days
                if days_remaining <= 2:
                    upcoming_payments.append({**row, 'days_remaining': days_remaining})
        
        # --- Блок форматирования сообщения (остается без изменений) ---
        message_parts = [f"📊 *Статистика за {escape(today.strftime('%d.%m.%Y'))}*"]
        message_parts.append(f"*Велосипеды в аренде:*\n\\- наши {rented_own}/{total_own}\n\\- инвесторские {rented_investor}/{total_investor}")
        message_parts.append(f"*Велосипеды в выкупе:*\n\\- наши {buyout_own}\n\\- инвесторские {buyout_investor}")
        message_parts.append(f"*Выдано в аренду за день:*\n\\- наши {daily_activity['rent_own']}\n\\- инвесторские {daily_activity['rent_investor']}")
        message_parts.append(f"*Выдано под выкуп за день:*\n\\- наши {daily_activity['buyout_own']}\n\\- инвесторские {daily_activity['buyout_investor']}")
        message_parts.append(f"*Вернули из аренды:*\n\\- наши {daily_activity['return_own']}\n\\- инвесторские {daily_activity['return_investor']}")
        income_str = f"{daily_activity['income']:,.2f}".replace(",", " "); expenses_str = f"{daily_expenses:,.2f}".replace(",", " ")
        message_parts.append(f"💰 *Доход за день:* `{escape(income_str)}` рублей\n💸 *Расходы за день:* `{escape(expenses_str)}` рублей")
        message_parts.append("*Ближайшие оплаты \\(до 2 дней\\):*")
        if not upcoming_payments:
            message_parts.append("_Нет клиентов с подходящим сроком оплаты\\._")
        else:
            upcoming_payments.sort(key=lambda x: x['days_remaining'])
            def get_day_suffix(days):
                days = abs(days);
                if days % 10 == 1 and days % 100 != 11: return "день"
                elif 2 <= days % 10 <= 4 and (days % 100 < 10 or days % 100 >= 20): return "дня"
                return "дней"
            payment_list = []
            for p in upcoming_payments:
                days = p['days_remaining']; status = f"🔴 *Просрочка {abs(days)} {escape(get_day_suffix(days))}*" if days < 0 else f"🟢 Осталось {days} {escape(get_day_suffix(days))}"
                client_name = escape(f"{p['first_name']} {p['last_name']}"); phone = escape(p['phone_number']); username = escape(p['username'])
                client_info = f"*{client_name}*\n📞 `{phone}` \\| @{username}\nСтатус: {status}"
                payment_list.append(client_info)
            message_parts.append("\n\n".join(payment_list))
        
        # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
        # Добавляем инлайн-кнопку к сообщению
        keyboard = [[InlineKeyboardButton("📈 Доход/расход за другую дату", callback_data="stats_date_select")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await status_message.edit_text("\n\n".join(message_parts), parse_mode="MarkdownV2", reply_markup=reply_markup)
        # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

    except Exception as e:
        logger.error(f"Ошибка при сборе статистики за день: {e}", exc_info=True)
        await status_message.edit_text(f"❌ Произошла критическая ошибка при сборе статистики: {e}")

# ДОБАВЬТЕ ЭТОТ БЛОК КОДА В ВАШ ОСНОВНОЙ ФАЙЛ
import calendar

# Состояния для нового диалога
STATS_AWAIT_DATE = range(970, 971)

def _create_stats_calendar(year: int, month: int) -> InlineKeyboardMarkup:
    """Создает инлайн-календарь для выбора даты."""
    keyboard = []
    # Заголовок с названием месяца и года
    keyboard.append([InlineKeyboardButton(f"{calendar.month_name[month]} {year}", callback_data="noop")])
    # Дни недели
    keyboard.append([InlineKeyboardButton(day, callback_data="noop") for day in ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]])

    month_calendar = calendar.monthcalendar(year, month)
    for week in month_calendar:
        row = [InlineKeyboardButton(str(day) if day != 0 else " ", callback_data=f"stats_date_{year}-{month:02d}-{day:02d}") for day in week]
        keyboard.append(row)
    
    # Кнопки навигации
    prev_month = (datetime(year, month, 1) - timedelta(days=1)).strftime('%Y-%m')
    next_month = (datetime(year, month, 28) + timedelta(days=4)).strftime('%Y-%m')
    keyboard.append([
        InlineKeyboardButton("< Назад", callback_data=f"stats_nav_{prev_month}"),
        InlineKeyboardButton("Отмена", callback_data="stats_cancel"),
        InlineKeyboardButton("Вперед >", callback_data=f"stats_nav_{next_month}")
    ])
    return InlineKeyboardMarkup(keyboard)

async def start_stats_date_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Показывает календарь для выбора даты."""
    query = update.callback_query
    await query.answer()

    # Определяем, это первый вход или навигация по месяцам
    if query.data.startswith("stats_nav_"):
        year, month = map(int, query.data.split('_')[-1].split('-'))
    else:
        today = datetime.now()
        year, month = today.year, today.month
    
    await query.edit_message_text(
        "📅 Выберите дату для просмотра доходов и расходов:",
        reply_markup=_create_stats_calendar(year, month)
    )
    return STATS_AWAIT_DATE

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ process_stats_date_selection НА ЭТУ ВЕРСИЮ
async def process_stats_date_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Принимает дату, считает финансы и выводит ПОДРОБНУЮ детализацию."""
    query = update.callback_query
    await query.answer()

    if query.data == "stats_cancel":
        await query.edit_message_text("Действие отменено.")
        return ConversationHandler.END

    def escape(text: str) -> str:
        return escape_markdown(str(text or ''), version=2)

    try:
        date_str = query.data.split('_')[-1]
        selected_date = datetime.strptime(date_str, '%Y-%m-%d')
        
        start_of_day = selected_date.strftime('%Y-%m-%d 00:00:00')
        end_of_day = selected_date.strftime('%Y-%m-%d 23:59:59')

        await query.edit_message_text(f"⏳ Считаю финансы и готовлю детализацию за {selected_date.strftime('%d.%m.%Y')}...")

        total_income = 0.0
        income_details = []
        total_expenses = 0.0
        expense_details = []

        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row

            # --- Сбор и детализация ДОХОДОВ ---
            sql_income = """
                SELECT bh.action, bh.details, u.first_name, u.last_name, b.name as bike_name
                FROM bike_history bh
                JOIN users u ON bh.user_id = u.id
                JOIN bikes b ON bh.bike_id = b.id
                WHERE bh.timestamp BETWEEN ? AND ?
            """
            async with conn.execute(sql_income, (start_of_day, end_of_day)) as cursor:
                async for row in cursor:
                    income = _get_income_from_details(row['details'])
                    if income > 0:
                        total_income += income
                        client_name = escape(f"{row['first_name']} {row['last_name'] or ''}".strip())
                        action = escape(row['action'])
                        bike_name = escape(row['bike_name'])
                        income_details.append(f"\\- `{income:,.2f} ₽`: {action} \\({bike_name}\\) от {client_name}")

            # --- Сбор и детализация РАСХОДОВ ---
            sql_expenses = "SELECT item_name, amount, comment, category, subcategory FROM expenses WHERE created_at BETWEEN ? AND ?"
            async with conn.execute(sql_expenses, (start_of_day, end_of_day)) as cursor:
                async for row in cursor:
                    amount = row['amount']
                    total_expenses += amount
                    # Собираем наиболее полное описание расхода
                    item = row['item_name']
                    if not item:
                        try:
                            cat_details = EXPENSE_CATEGORIES[row['category']]
                            sub_details = cat_details['subcategories'][row['subcategory']]
                            item = sub_details['label'] if isinstance(sub_details, dict) else sub_details
                        except KeyError:
                            item = f"{row['category']}/{row['subcategory']}"
                    
                    expense_details.append(f"\\- `{amount:,.2f} ₽`: {escape(item)}")

        # --- Формирование итогового сообщения ---
        message_parts = [
            f"💰 *Финансы за {escape(selected_date.strftime('%d.%m.%Y'))}*",
            f"📈 *Общий доход:* `{total_income:,.2f} ₽`".replace(",", " "),
            f"📉 *Общий расход:* `{total_expenses:,.2f} ₽`".replace(",", " "),
            "\\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\- \\-",
            "*Детализация доходов:*"
        ]
        if income_details:
            message_parts.extend(income_details)
        else:
            message_parts.append("_Доходов за этот день не было\\._")
            
        message_parts.append("\n*Детализация расходов:*")
        if expense_details:
            message_parts.extend(expense_details)
        else:
            message_parts.append("_Расходов за этот день не было\\._")

        await query.edit_message_text(
            "\n".join(message_parts),
            parse_mode="MarkdownV2"
        )

    except Exception as e:
        logger.error(f"Ошибка при подсчете финансов за дату: {e}", exc_info=True)
        await query.edit_message_text("❌ Произошла ошибка при обработке даты.")
    
    return ConversationHandler.END

async def investment_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Показывает главное меню управления инвестициями с тремя кнопками."""
    keyboard = [
        [InlineKeyboardButton("📊 Список Инвесторов и их активы", callback_data="inv_list_investors_0")],
        [InlineKeyboardButton("➕ Привязать велосипед к инвестору", callback_data="inv_assign_start")],
        [InlineKeyboardButton("📈 Статистика", callback_data="inv_show_stats")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    message_text = "📈 *Панель управления инвестициями*\n\nВыберите действие:"
    
    if update.callback_query:
        await update.callback_query.edit_message_text(message_text, reply_markup=reply_markup, parse_mode="Markdown")
    else:
        await update.message.reply_text(message_text, reply_markup=reply_markup, parse_mode="Markdown")

# --- 1. Функция "Статистика" ---

async def show_investment_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Собирает и показывает краткую статистику по инвесторам."""
    query = update.callback_query
    await query.answer()

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("SELECT COUNT(DISTINCT investor_id) FROM bikes WHERE investor_id IS NOT NULL")
            total_investors = (await cursor.fetchone())[0]
            cursor = await conn.execute("SELECT COUNT(*) FROM bikes WHERE investor_id IS NOT NULL")
            total_investor_bikes = (await cursor.fetchone())[0]
            cursor = await conn.execute(
                """SELECT COUNT(b.id) FROM bikes b
                   JOIN bookings bk ON b.id = bk.bike_id
                   WHERE b.investor_id IS NOT NULL AND bk.status = 'rented'"""
            )
            rented_investor_bikes = (await cursor.fetchone())[0]
    except Exception as e:
        logger.error(f"Ошибка при сборе статистики по инвестициям: {e}", exc_info=True)
        await query.edit_message_text("❌ Ошибка базы данных при сборе статистики.")
        return

    stats_text = (
        f"📈 *Краткая статистика по инвестициям:*\n\n"
        f"▪️ *Всего инвесторов:* {total_investors}\n"
        f"▪️ *Всего инвесторских велосипедов:* {total_investor_bikes}\n"
        f"▪️ *Сейчас в аренде:* {rented_investor_bikes} из {total_investor_bikes}"
    )
    keyboard = [[InlineKeyboardButton("⬅️ Назад в меню инвестиций", callback_data="inv_back_to_main")]]
    await query.edit_message_text(stats_text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")

# --- 2. Функция "Список инвесторов" ---

async def show_investor_list_details(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Показывает детализированный список инвесторов и их активов с пагинацией."""
    query = update.callback_query
    await query.answer()

    page = int(query.data.split('_')[-1])
    PAGE_SIZE = 3  # Показываем по 3 инвестора на странице, чтобы не перегружать сообщение

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            # Находим всех уникальных инвесторов
            cursor = await conn.execute("SELECT DISTINCT investor_id FROM bikes WHERE investor_id IS NOT NULL")
            investor_ids_rows = await cursor.fetchall()
            investor_ids = [row['investor_id'] for row in investor_ids_rows]

            if not investor_ids:
                await query.edit_message_text(
                    "На данный момент нет инвесторов с привязанными велосипедами.",
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Назад", callback_data="inv_back_to_main")]])
                )
                return

            total_pages = (len(investor_ids) + PAGE_SIZE - 1) // PAGE_SIZE
            page = max(0, min(page, total_pages - 1))
            
            investors_on_page_ids = investor_ids[page * PAGE_SIZE : (page + 1) * PAGE_SIZE]
            
            message_parts = [f"📊 *Список инвесторов и их активы (Стр. {page + 1}/{total_pages})*\n"]
            
            for inv_id in investors_on_page_ids:
                # Получаем имя инвестора
                cursor = await conn.execute("SELECT first_name, last_name FROM users WHERE id = ?", (inv_id,))
                inv_info = await cursor.fetchone()
                inv_name = f"{inv_info['first_name'] or ''} {inv_info['last_name'] or ''}".strip()
                message_parts.append(f"\n👤 *{inv_name} (ID: {inv_id})*")

                # Получаем все его велосипеды и информацию об их аренде
                cursor = await conn.execute(
                    """SELECT
                           b.name,
                           bk.end_date,
                           bk.booking_type,
                           u_rent.first_name as renter_fname,
                           u_rent.last_name as renter_lname
                       FROM bikes b
                       LEFT JOIN bookings bk ON b.id = bk.bike_id AND bk.status = 'rented'
                       LEFT JOIN users u_rent ON bk.user_id = u_rent.id
                       WHERE b.investor_id = ?""",
                    (inv_id,)
                )
                bikes = await cursor.fetchall()
                
                if not bikes:
                    message_parts.append("  _Нет привязанных велосипедов._")
                else:
                    for bike in bikes:
                        status_text = ""
                        if bike['end_date']: # Если есть аренда
                            renter_name = f"{bike['renter_fname'] or ''} {bike['renter_lname'] or ''}".strip()
                            status_text = f"->  rented by *{renter_name}* until {bike['end_date']}"
                        else:
                            status_text = "-> ✅ *Свободен*"
                        message_parts.append(f"  🚲 `{bike['name']}` {status_text}")
            
            keyboard = []
            nav_row = []
            if page > 0:
                nav_row.append(InlineKeyboardButton("⬅️", callback_data=f"inv_list_investors_{page - 1}"))
            if page < total_pages - 1:
                nav_row.append(InlineKeyboardButton("➡️", callback_data=f"inv_list_investors_{page + 1}"))
            if nav_row:
                keyboard.append(nav_row)
            
            keyboard.append([InlineKeyboardButton("⬅️ Назад в меню инвестиций", callback_data="inv_back_to_main")])

            await query.edit_message_text(
                "\n".join(message_parts),
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )

    except Exception as e:
        logger.error(f"Ошибка при показе списка инвесторов: {e}", exc_info=True)
        await query.edit_message_text("❌ Произошла ошибка при загрузке списка.")

# --- 3. Функции для "Привязки велосипеда к инвестору" (ConversationHandler) ---

async def assign_asset_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Запрашивает поиск инвестора."""
    query = update.callback_query
    await query.answer()
    context.user_data.clear()
    await query.edit_message_text("🔍 *Шаг 1/2: Выбор инвестора*\n\nВведите фамилию или ID пользователя для поиска:")
    return INV_AWAIT_USER_SEARCH

async def search_user_for_assign(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Принимает поисковый запрос и показывает найденных пользователей."""
    search_term = update.message.text.strip()
    
    async with aiosqlite.connect(DB_FILE) as conn:
        cursor = await conn.execute(
            "SELECT id, first_name, last_name FROM users WHERE last_name LIKE ? OR id LIKE ?",
            (f"%{search_term}%", f"%{search_term}%")
        )
        users = await cursor.fetchall()

    if not users:
        await update.message.reply_text("❌ Пользователь не найден. Попробуйте еще раз или введите /cancel для отмены.")
        return INV_AWAIT_USER_SEARCH

    keyboard = [[InlineKeyboardButton(
        f"{user[2] or ''} {user[1] or ''} (ID: {user[0]})",
        callback_data=f"inv_assign_user_{user[0]}"
    )] for user in users]
    await update.message.reply_text("Найденные пользователи:", reply_markup=InlineKeyboardMarkup(keyboard))
    return INV_SELECT_USER

async def select_user_for_assign(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Сохраняет инвестора и запрашивает поиск велосипеда."""
    query = update.callback_query
    await query.answer()
    
    investor_id = int(query.data.split('_')[-1])
    context.user_data['assign_investor_id'] = investor_id
    
    await query.edit_message_text("✅ Инвестор выбран.\n\n"
                                  "🔍 *Шаг 2/2: Выбор велосипеда*\n\n"
                                  "Теперь введите название или VIN свободного велосипеда:")
    return INV_AWAIT_BIKE_SEARCH

async def search_bike_for_assign(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Принимает поисковый запрос и показывает найденные свободные велосипеды."""
    search_term = update.message.text.strip()

    async with aiosqlite.connect(DB_FILE) as conn:
        cursor = await conn.execute(
            "SELECT id, name FROM bikes WHERE name LIKE ? AND investor_id IS NULL AND type = 'bike'",
            (f"%{search_term}%",)
        )
        bikes = await cursor.fetchall()
        
    if not bikes:
        await update.message.reply_text("❌ Свободный велосипед не найден. Попробуйте еще раз или введите /cancel для отмены.")
        return INV_AWAIT_BIKE_SEARCH
        
    keyboard = [[InlineKeyboardButton(
        bike[1], callback_data=f"inv_assign_bike_{bike[0]}"
    )] for bike in bikes]
    await update.message.reply_text("Найденные свободные велосипеды:", reply_markup=InlineKeyboardMarkup(keyboard))
    return INV_SELECT_BIKE

async def finalize_assign(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Финал: Привязывает выбранный велосипед к инвестору."""
    query = update.callback_query
    await query.answer()

    bike_id = int(query.data.split('_')[-1])
    investor_id = context.user_data['assign_investor_id']
    
    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        await conn.execute("UPDATE bikes SET investor_id = ? WHERE id = ?", (investor_id, bike_id))
        await conn.commit()
        
        # Получаем имена для красивого сообщения
        cursor = await conn.execute("SELECT name FROM bikes WHERE id = ?", (bike_id,))
        bike_name = (await cursor.fetchone())['name']
        cursor = await conn.execute("SELECT first_name, last_name FROM users WHERE id = ?", (investor_id,))
        inv_info = await cursor.fetchone()
        inv_name = f"{inv_info['first_name'] or ''} {inv_info['last_name'] or ''}".strip()

    await query.edit_message_text(f"✅ Успешно!\nВелосипед «{bike_name}» привязан к инвестору «{inv_name}».")
    
    context.user_data.clear()
    await investment_main_menu(update, context) # Возвращаемся в главное меню инвестиций
    return ConversationHandler.END

async def cancel_assign(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет диалог привязки."""
    context.user_data.clear()
    message = update.message or update.callback_query.message
    
    # Сначала отправляем текстовое подтверждение
    await context.bot.send_message(chat_id=message.chat_id, text="Действие отменено.")
    
    # Затем показываем главное меню инвестиций
    if update.callback_query:
         update.callback_query.message.text = "" # хак, чтобы мы могли отправить новое сообщение
    await investment_main_menu(update, context)
    return ConversationHandler.END
    
# ==============================================================================
#           КОНЕЦ МОДУЛЯ УПРАВЛЕНИЯ ИНВЕСТИЦИЯМИ
# ==============================================================================



# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>
async def show_tariffs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Показывает актуальные тарифы на аренду и выкуп."""
    text = """
💰 *Наши тарифы*

*АРЕНДА (цена за неделю):*
- Kugoo / Liming: *3 500 ₽*
- Kugoo с 2 АКБ: *4 500 ₽*
- Wenbox: *5 000 ₽*
- Дополнительный АКБ: *1 000 ₽*

*ВЫКУП (еженедельный платеж):*
- Kugoo / Liming (1 АКБ): *5 000 ₽ / 15 недель*
- Kugoo (2 АКБ): *6 000 ₽ / 15 недель*
- Wenbox U3: *10 000 ₽ / 12 недель*

🎁 *Акции:*
- «Первый заказ без залога» для новых клиентов.
- «Приведи друга» и получи 1 день аренды бесплатно.

🔹*Как оплатить?*
- Оплата происходит через бота по СБП.
    """
    await update.message.reply_text(text, parse_mode="Markdown")

async def show_rules(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Показывает правила пользования сервисом."""
    text = """
📜 *Правила пользования*

📌 *Основные положения:*
• Аренда доступна только для лиц старше 18 лет.
• Требуется паспорт (для граждан РФ/СНГ) или документ, удостоверяющий личность (для иностранцев).
• Залог 0 ₽ по акции для новых клиентов (при первом обращении).

📌 *Обязанности арендатора:*
• Использовать велосипед только в рабочих целях (доставка).
• Не передавать третьим лицам без уведомления компании.
• Сообщать о поломках в течение 24 часов.

📌 *Возврат велосипеда:*
• В чистом состоянии.
• При повреждениях — удерживается стоимость ремонта.

📌 *Санкции:*
• При утере — штраф в размере рыночной стоимости.
• При нарушении сроков аренды — 700 ₽ за каждый день просрочки.
• Передача третьим лицам без уведомления компании — штраф в размере 10 000 ₽.
• Публичная оферта - https://badfoxbike.ru/oferta.html
• Положение об обработке персональных данных https://badfoxbike.ru/privacy-policy.html
    """
    # Здесь можно добавить кнопку на PDF с офертой
    # keyboard = [[InlineKeyboardButton("Скачать публичную оферту (PDF)", url="https://...")]]
    # await update.message.reply_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    await update.message.reply_text(text, parse_mode="Markdown")


async def show_repair_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Показывает инструкцию, как сообщить о поломке."""
    text = """
🛠️ *Как сообщить о поломке или неисправности:*

Свяжитесь с нами в мессенджере: @BFbike

1. Укажите модель и VIN номер велосипеда.
2. Отправьте фото/видео повреждения.
3. Опишите проблему (например: «не работает тормоз», «быстро разряжается батарея»).
    """
    await update.message.reply_text(text, parse_mode="Markdown")


async def show_contacts(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Показывает контактную информацию."""
    text = """
📞 *Наши контакты*

🌐 *Сайт:* http://badfoxbike.ru/

📲 *Связь:*
• Поддержка клиентов: @BFbike (Telegram)
• Новостной канал: @badfoxbike (Telegram)
• Телефон: `+79175705479`

📍 *Адрес пункта выдачи:*
Москва, м. Новокосино, ул. Салтыковская, д. 53

🕒 *График работы:*
• Пн–Пт: 10:00–23:00
• Сб–Вс: 11:00–22:00

*Важно!*
- Бронируйте велосипед заранее через бота, чтобы забрать его без очереди.
- Для оформления договора при себе необходимо иметь паспорт.
    """
    await update.message.reply_text(text, parse_mode="Markdown")

# Глобальный список для хранения уведомлений
notifications = []

# Словарь для перевода месяцев на русский язык
MONTHS_RU = {
    1: "января",
    2: "февраля",
    3: "марта",
    4: "апреля",
    5: "мая",
    6: "июня",
    7: "июля",
    8: "августа",
    9: "сентября",
    10: "октября",
    11: "ноября",
    12: "декабря"
}
# Поместите этот список в начало вашего файла, где у вас константы
PAYMENT_ANIMATIONS = [
    ["🚲", "💨", "🏢", "✅"], # Велосипед едет к зданию
    ["💵", "➡️", "🏦", "👍"], # Деньги идут в банк
    ["📄", "✍️", "➡️", "🎉"], # Документ подписывается
    ["🔑", "➡️", "🚲", "🤝"]  # Ключи передаются
]

# ### НОВАЯ, АСИНХРОННАЯ ФУНКЦИЯ ###
async def add_notification(message: str):
    """
    АСИНХРОННАЯ ВЕРСИЯ: Добавляет уведомление в базу данных, не блокируя ее.
    """
    now = datetime.now()
    day = now.day
    month = MONTHS_RU.get(now.month, "??") # Добавил .get для безопасности
    time = now.strftime('%H:%M')
    timestamp = f"{day} {month} {time}"

    try:
        async with aiosqlite.connect(DB_FILE, timeout=10) as conn:
            await conn.execute(
                "INSERT INTO notifications (timestamp, message) VALUES (?, ?)",
                (timestamp, message)
            )
            await conn.commit()
    except Exception as e:
        logger.error(f"Ошибка при асинхронном добавлении уведомления в БД: {e}", exc_info=True)

KEYWORD_CATEGORIES = {
    # Категория: [список ключевых слов]
    "бронь": ["бронь", "бронирование", "подтвержден", "отмена брони"],
    "аренда": ["аренда", "аренду", "аренды", "оплата аренды"],
    "ремонт": ["ремонт", "диагностика", "починка", "принят в работу"],
    "согласие": ["согласие", "условия аренды", "договор"],
    "сдача": ["сдача", "возврат", "завершение аренды"],
    'штраф': ['штраф', 'оплата', 'назначен', 'пени', 'санкция'],
    "продление": ["продление", "продлен", "автопродление"]
}

SELECT_DATE, CHOOSE_HISTORY_TYPE = range(2)
INPUT_SURNAME, INPUT_BIKE_NAME = range(2, 4)
INPUT_KEYWORD = 4
async def search_by_keyword(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    # Формируем текст с подсказками
    help_text = """🔍 *Поиск по ключевым словам*\n
Доступные категории:
- Бронь (`бронь`, `подтверждение`, `отмена`)
- Аренда (`аренда`, `оплата`, `сдача`)
- Ремонт (`ремонт`, `диагностика`)
- Продление (`продление`, `автопродление`)
- Согласие (`согласие`, `договор`)

Примеры:
- `аренда продление`
- `ремонт 15.07`
- `бронь отмена`"""

    await query.message.reply_text(help_text, parse_mode="Markdown")
    await query.message.reply_text("✏️ Введите поисковый запрос:")
    return INPUT_KEYWORD

class SearchLogger:
    @staticmethod
    async def log_search_context(context: dict, user_id: int):
        try:
            search_params = context.get('search_params', {})
            log_message = [
                f"🔍 [Search Log] User: {user_id}",
                f"📝 Raw query: {context.get('search_keyword', '')}",
                f"🔑 Keywords: {', '.join(search_params.get('keywords', []))}",
                f"🚲 Bikes: {', '.join(search_params.get('bike_names', []))}",
                f"👤 Surnames: {', '.join(search_params.get('surnames', []))}",
                f"📅 Date range: {search_params.get('date_from', 'N/A')} - {search_params.get('date_to', 'N/A')}",
                f"🔢 Results: {len(context.get('search_results', []))} items"
            ]
            logger.info("\n".join(log_message))
        except Exception as e:
            logger.error(f"Error in search logging: {str(e)}")
import json
import re
from datetime import datetime, timedelta
import logging
from telegram import Update
from telegram.ext import ContextTypes
import json

logger = logging.getLogger(__name__)

async def execute_query(query, params):
    """Заглушка для выполнения SQL-запросов."""
    # В реальном коде здесь будет подключение к базе данных
    return []

import os
import logging
import sys
from datetime import datetime
from telegram import Update
from telegram.error import TelegramError
from telegram.ext import ContextTypes

# Добавляем текущую директорию в путь поиска модулей
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.append(current_dir)

from admin_reports import generate_daily_report, is_admin

# Настраиваем логирование
logger = logging.getLogger(__name__)
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

import os
import logging
from datetime import datetime
from telegram import Update, BotCommand
from telegram.ext import Application, CommandHandler, ContextTypes
from admin_reports import generate_daily_report, is_admin

# Настраиваем логирование
logger = logging.getLogger(__name__)
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

async def generate_report_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Обработчик команды /otchet для генерации отчета.
    Использование: /otchet [DD.MM.YYYY]
    """
    user_id = update.effective_user.id

    # Проверяем, является ли пользователь администратором
    if not is_admin(user_id):
        await update.message.reply_text("⛔️ У вас нет прав для выполнения этой команды.")
        return

    # Получаем дату из аргументов команды или используем текущую дату
    try:
        if context.args and len(context.args) > 0:
            report_date = datetime.strptime(context.args[0], '%d.%m.%Y').strftime('%d.%m.%Y')
        else:
            report_date = datetime.now().strftime('%d.%m.%Y')

        # Отправляем сообщение о начале генерации отчета
        status_message = await update.message.reply_text("⏳ Генерация отчета...")

        try:
            # Определяем путь к директории reports
            reports_dir = os.path.join(os.path.dirname(__file__), 'reports')
            os.makedirs(reports_dir, exist_ok=True)

            # Генерируем отчет
            report_filename = generate_daily_report(report_date)
            excel_filename = report_filename.replace('.txt', '.xlsx')

            # Проверяем существование файлов
            if not os.path.exists(report_filename):
                raise FileNotFoundError(f"Не удалось найти файл отчета: {report_filename}")
            if not os.path.exists(excel_filename):
                raise FileNotFoundError(f"Не удалось найти Excel файл: {excel_filename}")

            # Отправляем Excel файл
            with open(excel_filename, 'rb') as excel_file:
                await update.message.reply_document(
                    document=excel_file,
                    filename=f"report_{report_date.replace('.', '')}.xlsx",
                    caption=f"📊 Отчет за {report_date}"
                )

            # Отправляем текстовый отчет
            with open(report_filename, 'rb') as text_file:
                await update.message.reply_document(
                    document=text_file,
                    filename=f"report_{report_date.replace('.', '')}.txt",
                    caption=f"📝 Текстовый отчет за {report_date}"
                )

            # Удаляем сообщение о генерации
            await status_message.delete()

        except Exception as e:
            error_msg = f"❌ Ошибка при генерации отчета: {str(e)}"
            logger.error(error_msg)
            await status_message.edit_text(error_msg)

    except ValueError:
        await update.message.reply_text(
            "❌ Неверный формат даты. Используйте формат ДД.ММ.ГГГГ\n"
            "Например: /otchet 18.02.2025"
        )

from datetime import datetime, timedelta
import re
import logging
from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
import json

logger = logging.getLogger(__name__)

from datetime import datetime, date  # Добавляем импорт date
import re
import logging
from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
import json

logger = logging.getLogger(__name__)

from datetime import datetime, date
import re
import logging

logger = logging.getLogger(__name__)

def parse_date(date_str: str) -> date:
    """
    Парсинг даты из строки в формате DD.MM[.YY[YY]].
    Возвращает объект date или None, если дата некорректна.
    """
    # Регулярное выражение для формата DD.MM[.YY[YY]]
    date_pattern = re.compile(r'^(\d{1,2})\.(\d{1,2})(?:\.(\d{2,4}))?$')
    match = date_pattern.match(date_str)

    if not match:
        logger.warning(f"Неверный формат даты: {date_str}")
        return None

    try:
        # Извлечение дня, месяца и года
        day = int(match.group(1))
        month = int(match.group(2))
        year_part = match.group(3)

        # Определение года
        if year_part:
            if len(year_part) == 2:
                # Преобразование двухзначного года в четырехзначный (например, 25 -> 2025)
                year = 2000 + int(year_part)
            else:
                # Четырехзначный год
                year = int(year_part)
        else:
            # Если год не указан, используем текущий год
            year = datetime.now().year

        # Создание объекта date
        return date(year, month, day)

    except ValueError as e:
        logger.warning(f"Ошибка парсинга даты {date_str}: {str(e)}")
        return None

import re
from datetime import datetime, timedelta
import json
from typing import Any


import re
from datetime import datetime, timedelta
import json
from typing import Any

# Предполагаемые функции и константы


import re
from datetime import datetime, timedelta, date
import json
import logging
from typing import Any

logger = logging.getLogger(__name__)


async def handle_keyword_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        user = update.message.from_user
        raw_query = update.message.text.strip().lower()
        logger.info(f"🔎 New search from {user.full_name} (ID: {user.id}): '{raw_query}'")

        # Инициализация параметров поиска
        search_params = {
            'keywords': [],
            'surnames': [],
            'bike_names': [],
            'date_from': None,
            'date_to': None
        }
        used_parts = set()

        # Обработка диапазонов дат с пробелами вокруг дефиса
        date_range_pattern = re.compile(
            r'(\d{1,2}\.\d{1,2}(?:\.\d{2,4})?)\s*-\s*(\d{1,2}\.\d{1,2}(?:\.\d{2,4})?)'
        )
        date_ranges = date_range_pattern.findall(raw_query)

        # Очищаем запрос от диапазонов дат
        cleaned_query = date_range_pattern.sub('', raw_query).strip()

        # Обработка найденных диапазонов
        for start_str, end_str in date_ranges:
            start_date = parse_date(start_str)
            end_date = parse_date(end_str)
            if start_date and end_date:
                search_params['date_from'] = start_date
                search_params['date_to'] = end_date + timedelta(days=1)  # Включаем конечную дату

        # Разбиваем ОЧИЩЕННЫЙ запрос на части
        parts = re.split(r'\s+', cleaned_query)

        # Регулярное выражение для проверки формата даты
        date_pattern = re.compile(r'^\d{1,2}\.\d{1,2}(?:\.\d{2,4})?$')

        # Обработка одиночных дат (если остались)
        for part in parts:
            if part in used_parts:
                continue
            if date_pattern.match(part):  # Проверяем, является ли часть датой
                current_date = parse_date(part)
                if current_date:
                    # Если уже есть диапазон, игнорируем одиночные даты
                    if not search_params['date_from']:
                        search_params['date_from'] = current_date
                        search_params['date_to'] = current_date + timedelta(days=1)
                    used_parts.add(part)
            else:
                logger.debug(f"⚠️ Не является датой: {part}")

        # Поиск названий велосипедов
        remaining_terms = [p for p in parts if p not in used_parts]
        if remaining_terms:
            bike_phrases = []
            # Сначала проверим всю фразу целиком
            full_phrase = ' '.join(remaining_terms)
            bikes = await execute_query(
                "SELECT name FROM bikes WHERE LOWER(name) LIKE ?",
                (f"%{full_phrase}%",)
            )
            if bikes:
                search_params['bike_names'].append(full_phrase)
                used_parts.update(remaining_terms)
                bike_phrases.append(full_phrase)
            else:
                # Ищем комбинации слов с сохранением порядка
                max_terms = 3
                for length in range(len(remaining_terms), 0, -1):
                    for start in range(0, len(remaining_terms) - length + 1):
                        phrase = ' '.join(remaining_terms[start:start+length])
                        if any(term in used_parts for term in phrase.split()):
                            continue
                        bikes = await execute_query(
                            "SELECT name FROM bikes WHERE LOWER(name) LIKE ?",
                            (f"%{phrase}%",)
                        )
                        if bikes:
                            search_params['bike_names'].append(phrase)
                            used_parts.update(phrase.split())
                            bike_phrases.append(phrase)
                            # Пропускаем обработанные термины
                            remaining_terms = [t for t in remaining_terms if t not in used_parts]
                            break

        # Обработка фамилий с учетом регистра
        original_parts = [p.strip() for p in update.message.text.split()]  # Сохраняем оригинальный регистр
        for part in original_parts:
            if part.lower() in used_parts:
                continue
            part_lower = part.lower()
            if part_lower != '-' and len(part_lower) > 1:
                # Нормализуем ввод: "патрушев" -> "Патрушев"
                capitalized_part = part.capitalize()

                # Поиск по точному совпадению с учетом регистра
                surnames = await execute_query(
                    "SELECT last_name FROM users WHERE last_name = ?",
                    (capitalized_part,)
                )

                if surnames:
                    search_params['surnames'].append(capitalized_part)
                    used_parts.add(part_lower)
                    logger.debug(f"✅ Найдена фамилия: {capitalized_part}")

        # Обработка ключевых слов
        for part in parts:
            if part in used_parts:
                continue
            for category, keywords in KEYWORD_CATEGORIES.items():
                if part in keywords or any(kw in part for kw in keywords):
                    search_params['keywords'].extend(keywords)
                    used_parts.add(part)
                    logger.debug(f"✅ Найдено ключевое слово: {part}")
                    break

        # Логирование параметров поиска
        logger.debug(f"Parsed search params: {json.dumps(search_params, default=str)}")

        # Формирование SQL запроса
        query_params = []
        conditions = []
        joins = []

        # Ключевые слова
        if search_params['keywords']:
            keyword_conditions = []
            for keyword in set(search_params['keywords']):
                keyword_conditions.extend([
                    "LOWER(bh.action) LIKE ?",
                    "LOWER(bh.details) LIKE ?"
                ])
                query_params.extend([f"%{keyword}%", f"%{keyword}%"])
            conditions.append(f"({' OR '.join(keyword_conditions)})")

        # Названия велосипедов
        if search_params['bike_names']:
            joins.append("JOIN bikes b ON bh.bike_id = b.id")
            bike_conditions = []
            for name in search_params['bike_names']:
                bike_conditions.append("LOWER(b.name) LIKE ?")
                query_params.append(f"%{name}%")
            conditions.append(f"({' OR '.join(bike_conditions)})")

        # Фамилии (регистрозависимый поиск)
        if search_params['surnames']:
            joins.append("JOIN users u ON bh.user_id = u.id")
            surname_conditions = []
            for surname in search_params['surnames']:
                surname_conditions.append("u.last_name LIKE ?")  # Регистрозависимый поиск
                query_params.append(f"%{surname}%")  # Используем оригинальную (с заглавной) фамилию
            conditions.append(f"({' OR '.join(surname_conditions)})")

        # Даты (с учетом формата DD.MM.YY)
        if search_params['date_from'] and search_params['date_to']:
            date_from_str = search_params['date_from'].strftime('%d.%m.%y')
            date_to_str = search_params['date_to'].strftime('%d.%m.%y')
            conditions.append(
                "bh.timestamp BETWEEN ? AND ?"
            )
            query_params.extend([date_from_str, date_to_str])

        # Сборка запроса
        base_query = f"""
            SELECT bh.id, bh.action, bh.details,
                    bh.timestamp as date,  -- Оригинальный формат DD.MM.YY
                   bh.user_id, bh.bike_id
            FROM bike_history bh
            {' '.join(joins)}
            {f"WHERE {' AND '.join(conditions)}" if conditions else ""}
            ORDER BY
                 substr(bh.timestamp, 7, 2) ||  -- Год (YY)
                 substr(bh.timestamp, 4, 2) ||  -- Месяц (MM)
                 substr(bh.timestamp, 1, 2) DESC  -- День (DD)
        """

        # Выполнение запроса
        results = await execute_query(base_query, query_params)
        logger.debug(f"Found {len(results)} results")

        # Сохранение результатов
        context.user_data.update({
            'search_results': results,
            'current_search_page': 0,
            'search_keyword': raw_query,
            'search_params': search_params
        })

        # Отображение результатов
        await show_search_results(update, context, 'keyword')
        return ConversationHandler.END

    except Exception as e:
        logger.error(f"Error in handle_keyword_input: {str(e)}", exc_info=True)
        await update.message.reply_text("⚠️ Ошибка при обработке запроса")
        return ConversationHandler.END


async def show_action_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data

    def escape_md(text):
        return re.sub(r"([_*\[\]()~`>#+\-=|.!{}])", r"\\\1", str(text))

    # Обработка пагинации полной истории
    if data.startswith('full_history_page_'):
        page = int(data.split('_')[-1])
        results = context.user_data.get('search_results', [])
        page_size = 5
        total_pages = (len(results) + page_size - 1) // page_size
        start_idx = page * page_size
        end_idx = (page + 1) * page_size

        if page < 0 or start_idx >= len(results):
            await query.answer("Нет данных для отображения")
            return

        message_text = (
            "📜 *ПОЛНАЯ ИСТОРИЯ ДЕЙСТВИЙ*\n\n"
            "╔══════════════════════════╗\n"
        )

        for action in results[start_idx:end_idx]:
            action_id, action_name, details, date, user_id, bike_id = action

            # Получаем информацию о пользователе с проверкой на пустоту
            user = await execute_query(
                "SELECT first_name, last_name FROM users WHERE id = ?",
                (user_id,)
            ) if user_id else None

            # Форматируем имя пользователя
            user_name = "Неизвестен"
            if user and len(user) > 0:
                first_name = user[0][0] or ""
                last_name = user[0][1] or ""
                user_name = f"{first_name} {last_name}".strip()

            # Получаем информацию о велосипеде с проверкой на пустоту
            bike_name = "–"
            if bike_id and bike_id != 0:
                bike = await execute_query(
                    "SELECT name FROM bikes WHERE id = ?",
                    (bike_id,)
                )
                if bike and len(bike) > 0:
                    bike_name = bike[0][0] or "–"

            entry = (
                f"║ 🆔 *ID действия:* \\#{escape_md(action_id)}\n"
                f"║ 🏷️ *Тип:* {escape_md(action_name)}\n"
                f"║ 👤 *Пользователь:* {escape_md(user_name)}\n"
                f"║ 🚴 *Велосипед:* {escape_md(bike_name)}\n"
                f"║ 📅 *Дата:* `{escape_md(date)}`\n"
                f"║ 📋 *Детали:*\n> `{escape_md(details) or '–'}`\n"
                f"╟──────────────────────────────╢\n"
            )
            message_text += entry

        message_text = message_text.rstrip("╟──────────────────────────────╢\n") + "\n╚══════════════════════════╝"
        message_text += f"\n\n📃 Страница {page + 1} из {total_pages}"

        keyboard = []
        pagination = []
        if page > 0:
            pagination.append(InlineKeyboardButton("<", callback_data=f"full_history_page_{page-1}"))
        if end_idx < len(results):
            pagination.append(InlineKeyboardButton(">", callback_data=f"full_history_page_{page+1}"))

        if pagination:
            keyboard.append(pagination)

        keyboard.append([
            InlineKeyboardButton("🔙 Обратно", callback_data="back_to_results"),
            InlineKeyboardButton("❌ Закрыть", callback_data="close_details")
        ])

        await query.message.edit_text(
            message_text,
            parse_mode="MarkdownV2",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return

    # Обработка отдельного действия
    if data.startswith('action_detail_'):
        action_id = data.split('_')[-1]

        result = await execute_query(
            """SELECT action, details, timestamp, user_id, bike_id
               FROM bike_history
               WHERE id = ?""",
            (int(action_id),)
        )

        if not result:
            await query.message.reply_text("⚠️ Действие не найдено")
            return

        action, details, date, user_id, bike_id = result[0]

        # Получаем информацию о пользователе с проверкой
        user_name = "Неизвестен"
        if user_id:
            user_info = await execute_query(
                "SELECT first_name, last_name FROM users WHERE id = ?",
                (user_id,)
            )
            if user_info and len(user_info) > 0:
                first_name = user_info[0][0] or ""
                last_name = user_info[0][1] or ""
                user_name = f"{first_name} {last_name}".strip()

        # Получаем информацию о велосипеде с проверкой
        bike_name = "–"
        if bike_id and bike_id != 0:
            bike_info = await execute_query(
                "SELECT name FROM bikes WHERE id = ?",
                (bike_id,)
            )
            if bike_info and len(bike_info) > 0:
                bike_name = bike_info[0][0] or "–"

        text = (
            f"📄 *ПОДРОБНАЯ ИНФОРМАЦИЯ О ДЕЙСТВИИ*\n\n"
            f"╔══════════════════════════╗\n"
            f"║ 🆔 *ID действия:* \\#{escape_md(action_id)}\n"
            f"╟──────────────────────────╢\n"
            f"║ 🏷️ *Тип действия:*\n> `{escape_md(action)}`\n"
            f"╟──────────────────────────╢\n"
            f"║ 👤 *Пользователь:*\n> `{escape_md(user_name)}`\n"
            f"╟──────────────────────────╢\n"
            f"║ 🚲 *Велосипед:*\n> `{escape_md(bike_name)}`\n"
            f"╟──────────────────────────╢\n"
            f"║ 📅 *Дата и время:*\n> `{escape_md(date)}`\n"
            f"╟──────────────────────────╢\n"
            f"║ 📝 *Подробности:*\n> `{escape_md(details) or 'нет дополнительной информации'}`\n"
            f"╚══════════════════════════╝"
        )

        keyboard = [[
            InlineKeyboardButton("🔙 К результатам", callback_data="back_to_results"),
            InlineKeyboardButton("❌ Закрыть", callback_data="close_details")
        ]]

        await query.message.reply_text(
            text,
            parse_mode="MarkdownV2",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
# Общая функция для работы с базой данных
async def execute_query(query: str, params: tuple) -> list:
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            return cursor.fetchall()
    except Exception as e:
        logger.error(f"Database error: {e}")
        return []

def generate_history_menu(context: ContextTypes.DEFAULT_TYPE) -> tuple:
    # Текст меню остается прежним
    menu_text = "📜 Нажмите на кнопку 'Поиск', чтобы найти нужную информацию."

    # <<< ГЛАВНОЕ ИЗМЕНЕНИЕ >>>
    # Оставляем только одну кнопку "Поиск"
    keyboard = [
        [InlineKeyboardButton("🔎 Поиск", callback_data="search_by_keyword")]
    ]
    # <<< КОНЕЦ ИЗМЕНЕНИЯ >>>

    # Возвращаем текст меню и новую, урезанную клавиатуру
    return menu_text, InlineKeyboardMarkup(keyboard)

async def view_history_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    try:
        query = update.callback_query
        message = update.message if not query else query.message
        original_text = message.text if query else None
        original_markup = message.reply_markup if query else None

        if query:
            await query.answer()

        menu_text, reply_markup = generate_history_menu(context)

        if (menu_text != original_text) or (str(reply_markup) != str(original_markup)):
            if query:
                await message.edit_text(menu_text, reply_markup=reply_markup)
            else:
                await message.reply_text(menu_text, reply_markup=reply_markup)

    except BadRequest as e:
        if "Message is not modified" not in str(e):
            logger.error(f"Telegram API Error: {e}", exc_info=True)
    except Exception as e:
        logger.error(f"Error in view_history_menu: {e}", exc_info=True)
        if not query:
            await update.message.reply_text("⚠️ Ошибка отображения меню")

# Общий обработчик поиска
async def handle_search_request(update: Update, text: str, state: int) -> int:
    query = update.callback_query
    await query.answer()
    await query.message.reply_text(text)
    return state

async def search_by_surname(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    return await handle_search_request(update, "🔍 Введите фамилию пользователя:", INPUT_SURNAME)

async def search_by_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    return await handle_search_request(update, "🚲 Введите название велосипеда:", INPUT_BIKE_NAME)



# Общий обработчик результатов поиска
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CallbackQueryHandler, ContextTypes
import re
import logging
from datetime import datetime

# Логирование
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Функция для экранирования MarkdownV2
def escape_md(text):
    return re.sub(r"([_*\[\]()~`>#+\-=|.!{}])", r"\\\1", str(text))

# Обработчик кнопки "❌ Закрыть"
async def close_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.message.delete()  # Удаляем сообщение с кнопками

# Обработчик кнопки "🔙 К результатам"
async def back_to_results(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # Восстанавливаем параметры поиска из контекста
    search_params = context.user_data.get('search_params', {})
    result_type = context.user_data.get('result_type', 'default')  # Тип результатов

    # Показываем результаты с первой страницы
    context.user_data["current_search_page"] = 0
    await show_search_results(update, context, result_type)

# Функция для отображения результатов поиска
async def show_search_results(update: Update, context: ContextTypes.DEFAULT_TYPE, result_type: str) -> None:
    try:
        query = update.callback_query
        message = update.message if not query else query.message

        # Получаем отсортированные результаты
        results = context.user_data.get('search_results', [])
        page = context.user_data.get('current_search_page', 0)
        search_params = context.user_data.get('search_params', {})
        page_size = 5
        total_pages = (len(results) + page_size - 1) // page_size
        start_idx = page * page_size
        end_idx = (page + 1) * page_size

        # Формируем заголовок
        header = f"✨ *🔍 РЕЗУЛЬТАТЫ ПОИСКА* ✨\n▫️▫️▫️\n🪄 Найдено действий: _{escape_md(len(results))}_\n"

        if search_params:
            header += "\n📋 *Параметры поиска:*\n"
            if search_params.get('keywords'):
                keywords = [f"🔸 `{escape_md(kw)}`" for kw in set(search_params['keywords'])]
                header += f"🎯 Ключевые слова:\n{', '.join(keywords)}\n"
            if search_params.get('surnames'):
                surnames = [f"👤 `{escape_md(s)}`" for s in search_params['surnames']]
                header += f"\n📇 Фамилии:\n{', '.join(surnames)}\n"
            if search_params.get('date_from'):
                date_str = f"📆 `{escape_md(search_params['date_from'].strftime('%d.%m.%Y'))}"
                if search_params.get('date_to'):
                    date_str += f" ➔ {escape_md(search_params['date_to'].strftime('%d.%m.%Y'))}`"
                else:
                    date_str += "`"
                header += f"\n⏳ Период:\n{date_str}\n"
            header += "⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯\n"

        # Формируем текст действий
        actions_text = ""
        for idx, action in enumerate(results[start_idx:end_idx], start=1):
            action_id, action_name, details, date, user_id, bike_id = action
            emoji = "🔄"
            if "создан" in action_name.lower(): emoji = "🆕"
            elif "изменен" in action_name.lower(): emoji = "✏️"
            elif "удален" in action_name.lower(): emoji = "🗑"

            actions_text += (
                f"\n{emoji} *Действие \\#{escape_md(start_idx + idx)}*\n"
                f"▫️ *Тип:* `{escape_md(action_name)}`\n"
                f"▫️ *Дата:* `{escape_md(date)}`\n"
                f"📋 *Детали:*\n"
                f"> ∘ `{escape_md(details) or 'без дополнительных комментариев'}`\n"
                f"⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯"
            )

        # Формируем пагинацию
        pagination = []
        if page > 0:
            pagination.append(InlineKeyboardButton("⏪ Предыдущие", callback_data=f"search_{result_type}_page_{page-1}"))
        if len(results) > page_size:
            pagination.append(InlineKeyboardButton("📜 Вся история", callback_data="full_history_page_0"))
        if end_idx < len(results):
            pagination.append(InlineKeyboardButton("Следующие ⏩", callback_data=f"search_{result_type}_page_{page+1}"))

        # Формируем клавиатуру
        keyboard = []
        if actions_text:
            keyboard.extend([[InlineKeyboardButton(f"🔍 Подробно (Действие {start_idx+i+1})",
                                                  callback_data=f"action_detail_{a[0]}")]
                             for i, a in enumerate(results[start_idx:end_idx])])
        if pagination:
            keyboard.append(pagination)
        keyboard.append([InlineKeyboardButton("❌ Закрыть", callback_data="close_search")])

        # Формируем текст сообщения
        message_text = f"{header}\n{actions_text}" if actions_text else f"{header}\n\n😔 Ничего не найдено"
        reply_markup = InlineKeyboardMarkup(keyboard)

        # Отправляем или редактируем сообщение
        if query:
            await message.edit_text(message_text,
                                   parse_mode="MarkdownV2",
                                   reply_markup=reply_markup)
        else:
            await message.reply_text(message_text,
                                    parse_mode="MarkdownV2",
                                    reply_markup=reply_markup)

    except Exception as e:
        logger.error(f"Error in show_search_results: {str(e)}")
        await update.message.reply_text("⚠️ Произошла ошибка при отображении результатов")

def get_matching_categories(keyword: str) -> list:
    return [cat for cat, keywords in KEYWORD_CATEGORIES.items() if any(kw in keyword for kw in keywords)]

def get_action_categories(action: str, details: str) -> list:
    found = []
    for category, keywords in KEYWORD_CATEGORIES.items():
        if any(kw in action.lower() or kw in details.lower() for kw in keywords):
            found.append(category)
    return found

def escape_sql_like(keyword: str) -> str:
    escape_char = '\\'
    special_chars = ['%', '_', '#', escape_char]
    return ''.join([f'{escape_char}{char}' if char in special_chars else char for char in keyword])

async def handle_surname_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data.update({
        'search_results': await execute_query(
            "SELECT id, first_name, last_name FROM users WHERE LOWER(last_name) LIKE ? ORDER BY last_name",
            (f"%{update.message.text.strip().lower()}%",)
        ),
        'current_search_page': 0
    })
    await show_search_results(update, context, 'user')
    return ConversationHandler.END

async def handle_bike_name_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data.update({
        'search_results': await execute_query(
            "SELECT id, name FROM bikes WHERE LOWER(name) LIKE ? ORDER BY name",
            (f"%{update.message.text.strip().lower()}%",)
        ),
        'current_search_page': 0
    })
    await show_search_results(update, context, 'bike')
    return ConversationHandler.END

# Общий обработчик пагинации
async def handle_search_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    try:
        match = re.match(r"^search_(\w+)_page_(\d+)$", query.data)
        if not match:
            logger.error(f"Invalid callback data: {query.data}")
            return

        result_type = match.group(1)
        page = int(match.group(2))

        # Проверка на отрицательные страницы
        if page < 0:
            page = 0

        context.user_data['current_search_page'] = page
        await show_search_results(update, context, result_type)

    except Exception as e:
        logger.error(f"Pagination error: {str(e)}", exc_info=True)
        await query.message.reply_text("⚠️ Ошибка переключения страницы")

async def select_day(update: Update, context) -> None:
    await update.callback_query.answer()
    await update.callback_query.message.reply_text("📅 Введите дату (ДД.ММ или ДД.ММ.ГГГГ):")
    return SELECT_DATE


async def handle_date_input(update: Update, context) -> None:
    """Обрабатывает ввод даты от пользователя и сохраняет её в контексте."""
    user_input = update.message.text.strip()  # Получаем текст сообщения

    # Возможные форматы даты
    date_formats = [
        ('%d.%m', False),  # ДД.ММ (год не указан)
        ('%d.%m.%y', True),  # ДД.ММ.ГГ
        ('%d.%m.%Y', True),  # ДД.ММ.ГГГГ
    ]

    parsed_date = None
    year_specified = False

    # Пытаемся распарсить ввод разными форматами
    for fmt, has_year in date_formats:
        try:
            parsed_date = datetime.strptime(user_input, fmt)
            year_specified = has_year
            break
        except ValueError:
            continue

    # Если дата не распознана
    if not parsed_date:
        await update.message.reply_text(
            "🚫 Неверный формат. Используйте:\n"
            "• 25.01\n• 25.01.25\n• 25.01.2025"
        )
        return SELECT_DATE  # Возвращаемся в состояние ожидания даты

    # Форматируем дату для БД и отображения
    if year_specified:
        db_date = parsed_date.strftime('%d.%m.%Y')  # Для запросов в БД
        display_date = parsed_date.strftime('%d.%m.%Y')  # Для отображения
    else:
        db_date = parsed_date.strftime('%d.%m')  # Для запросов в БД
        display_date = parsed_date.strftime('%d.%m')  # Для отображения

    # Сохраняем дату в контексте
    context.user_data["selected_date"] = {
        "db_format": db_date,  # Для запросов в БД
        "year_specified": year_specified,  # Указан ли год
        "display_format": display_date,  # Для отображения
        "string": display_date  # Строковое представление
    }

    # Подтверждаем успешный ввод
    await update.message.reply_text(f"📅 Фильтр установлен на: {display_date}")

    # Возвращаемся в меню выбора типа истории
    await view_history_menu(update, context)
    return CHOOSE_HISTORY_TYPE

# Добавьте этот код после функции cancel()
async def clear_date_filter(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    # Проверяем, был ли установлен фильтр
    had_date = "selected_date" in context.user_data

    # Сбрасываем фильтр даты (если есть)
    context.user_data.pop("selected_date", None)

    # Получаем текст и клавиатуру из generate_history_menu
    menu_text, reply_markup = generate_history_menu(context)

    # Меняем текст в зависимости от наличия фильтра
    status_message = "Фильтр даты сброшен." if had_date else "Меню обновлено."
    await query.edit_message_text(
        text=f"{status_message}\n{menu_text}",  # Добавляем статус к тексту меню
        reply_markup=reply_markup
    )

async def update_menu_message(query, context, text):
    """Обновляет сообщение с меню истории"""
    selected_date = context.user_data.get("selected_date")
    date_text = f"\n📅 Фильтр: {selected_date['string']}" if selected_date else "\n📅 Фильтр: все время"

    keyboard = [
        [InlineKeyboardButton("📜 История велосипеда", callback_data="history_bike")],
        [InlineKeyboardButton("👤 История пользователя", callback_data="history_user")],
        [InlineKeyboardButton("📅 Выбрать день", callback_data="select_day")]
    ]

    try:
        await query.edit_message_text(
            text=text + date_text,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    except BadRequest as e:
        logger.error(f"Ошибка обновления сообщения: {e}")

async def abort_operation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    # Полный сброс параметров
    keys_to_remove = ["date_selected", "selected_date", "history_params"]
    for key in keys_to_remove:
        context.user_data.pop(key, None)

    await update.message.reply_text("🚫 Операция прервана")
    return ConversationHandler.END

async def view_bike_history(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для кнопки 'История велосипеда'."""
    query = update.callback_query
    await query.answer()

    # Переходим на первую страницу
    await show_bike_page(update, context)


async def show_bike_page(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Функция для отображения страницы с велосипедами."""
    query = update.callback_query
    await query.answer()

    # Извлекаем номер страницы из callback_data
    try:
        page = int(query.data.split("_")[-1])  # Пример: "bike_page_2" → 2
    except (IndexError, ValueError):
        page = 0  # По умолчанию показываем первую страницу

    # Подключаемся к базе данных
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id, name FROM bikes ORDER BY id")
    bikes = cursor.fetchall()
    conn.close()

    # Если велосипедов нет
    if not bikes:
        await query.edit_message_text("🚫 Велосипеды пока не добавлены.")
        return

    # Настройки пагинации
    page_size = 5  # Количество велосипедов на странице
    total_pages = (len(bikes) + page_size - 1) // page_size  # Общее количество страниц

    # Проверка валидности номера страницы
    if page < 0 or page >= total_pages:
        await query.answer("❌ Это последняя страница")
        return

    # Выбираем велосипеды для текущей страницы
    start = page * page_size
    end = start + page_size
    current_bikes = bikes[start:end]

    # Формируем клавиатуру с велосипедами
    keyboard = [
        [InlineKeyboardButton(bike[1], callback_data=f"bike_history_{bike[0]}")]
        for bike in current_bikes
    ]

    # Добавляем кнопки пагинации
    pagination = []
    if page > 0:
        pagination.append(InlineKeyboardButton("<", callback_data=f"bike_page_{page-1}"))
    if end < len(bikes):
        pagination.append(InlineKeyboardButton(">", callback_data=f"bike_page_{page+1}"))

    if pagination:
        keyboard.append(pagination)

    # Обновляем сообщение
    try:
        await query.edit_message_text(
            "📜 Выберите велосипед для просмотра истории:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    except Exception as e:
        logger.error(f"Ошибка в show_bike_page: {e}")

async def view_user_history(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для кнопки 'История пользователя'."""
    query = update.callback_query
    await query.answer()

    # Переходим на первую страницу
    await show_user_page(update, context)


# Убедитесь, что в начале файла есть этот импорт
from telegram.ext import ContextTypes

async def show_user_page(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Функция для отображения страницы с пользователями."""
    query = update.callback_query
    await query.answer()

    # Извлекаем номер страницы из callback_data
    try:
        page = int(query.data.split("_")[-1])  # Пример: "user_page_3" → 3
    except (IndexError, ValueError):
        page = 0  # По умолчанию показываем первую страницу

    # Подключаемся к базе данных
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id, first_name, last_name FROM users ORDER BY id")
    users = cursor.fetchall()
    conn.close()

    # Если пользователей нет
    if not users:
        await query.edit_message_text("🚫 Пользователи пока не добавлены.")
        return

    # Настройки пагинации
    page_size = 5  # Количество пользователей на странице
    total_pages = (len(users) + page_size - 1) // page_size  # Общее количество страниц

    # Проверка валидности номера страницы
    if page < 0 or page >= total_pages:
        await query.answer("❌ Это последняя страница")
        return

    # Выбираем пользователей для текущей страницы
    start = page * page_size
    end = start + page_size
    current_users = users[start:end]

    # Формируем клавиатуру с пользователями
    keyboard = [
        [InlineKeyboardButton(f"{user[1]} {user[2]}", callback_data=f"user_history_{user[0]}")]
        for user in current_users
    ]

    # Добавляем кнопки пагинации
    pagination = []
    if page > 0:
        pagination.append(InlineKeyboardButton("<", callback_data=f"user_page_{page-1}"))
    if end < len(users):
        pagination.append(InlineKeyboardButton(">", callback_data=f"user_page_{page+1}"))

    if pagination:
        keyboard.append(pagination)

    # Обновляем сообщение
    try:
        await query.edit_message_text(
            "👤 Выберите пользователя для просмотра истории:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    except Exception as e:
        logger.error(f"Ошибка в show_user_page: {e}")


import sqlite3
from datetime import datetime
from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler

async def display_history(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    callback_data = query.data

    if callback_data.startswith("history_pagination_"):
        # Обработка пагинации: history_pagination_{type}_{id}_{page}
        parts = callback_data.split("_")
        if len(parts) != 5:
            logger.error(f"Некорректный формат callback_data: {callback_data}")
            await query.message.reply_text("🚫 Ошибка формата запроса")
            return

        history_type = parts[2]
        entity_id = int(parts[3])
        page = int(parts[4])

    elif callback_data == "clear_date":
        # Сбрасываем дату
        await clear_date_filter(update, context)
        return

    else:
        # Обработка первоначального запроса: bike_history_123 / user_history_456
        if callback_data.startswith("bike_history_"):
            history_type = "bike"
            entity_id = int(callback_data.split("_")[2])
        elif callback_data.startswith("user_history_"):
            history_type = "user"
            entity_id = int(callback_data.split("_")[2])
        else:
            await query.message.reply_text("🚫 Неверный тип истории.")
            return
        page = 1

    # Сохраняем параметры
    context.user_data.setdefault("history_params", {})
    context.user_data["history_params"] = {
        "history_type": history_type,
        "entity_id": entity_id,
        "current_page": page
    }

    # Получаем историю
    history = await get_paginated_history(context, page)
    if not history:
        await query.message.reply_text("📭 История пуста")
        return

    # Форматируем сообщение и клавиатуру
    message = await format_history_message(context, history, page)
    keyboard = await build_pagination_keyboard(context, page)

    await safe_edit_message(
        query=query,
        text=message,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

from telegram.error import BadRequest




async def safe_edit_message(query, text, reply_markup=None):
    MAX_LENGTH = 4096
    try:
        if len(text) <= MAX_LENGTH:
            await query.edit_message_text(
                text=text,
                parse_mode='MarkdownV2',
                reply_markup=reply_markup
            )
        else:
            warning = escape_markdown("\n\n⚠️ Сообщение сокращено из-за ограничения длины")
            await query.edit_message_text(
                text=escape_markdown(text[:MAX_LENGTH - len(warning)]) + warning,
                parse_mode='MarkdownV2',
                reply_markup=reply_markup
            )
    except BadRequest as e:
        # Обработка ошибки и fallback на plain text
        try:
            await query.edit_message_text(
                text=text[:MAX_LENGTH],
                reply_markup=reply_markup
            )
        except Exception as e:
            logger.error(f"Ошибка: {e}")
            await query.message.reply_text("⚠️ Произошла ошибка при отображении истории")

async def handle_critical_error(query):
    """Обработка критических ошибок."""
    try:
        await query.message.reply_text(
            "⚠️ Не удалось отобразить полную историю. Попробуйте выбрать конкретную дату."
        )
    except Exception as e:
        logger.error(f"Ошибка при отправке сообщения об ошибке: {e}")

async def parse_and_format_time(timestamp_str: str) -> str:
    """Приводит timestamp к единому формату."""
    try:
        input_formats = [
            "%d.%m.%Y %H:%M:%S",  # 25.01.2025 10:10:47
            "%d.%m.%y %H:%M:%S",  # 25.01.25 10:10:47
            "%d.%m.%Y",           # 25.01.2025
            "%d.%m.%y",           # 25.01.25
            "%Y-%m-%d %H:%M:%S",  # 2025-01-25 10:10:47
        ]

        # Парсим основными методами
        for fmt in input_formats:
            try:
                dt = datetime.strptime(timestamp_str, fmt)
                # Добавляем время по умолчанию если его нет
                if dt.hour == 0 and dt.minute == 0 and dt.second == 0:
                    return dt.strftime("%d.%m.%Y 00:00:00")
                return dt.strftime("%d.%m.%Y %H:%M:%S")
            except ValueError:
                continue

        # Если ни один формат не подошел
        logger.warning(f"Не удалось распознать формат времени: {timestamp_str}")
        return timestamp_str

    except Exception as e:
        logger.error(f"Критическая ошибка парсинга времени: {timestamp_str} - {e}")
        return timestamp_str

async def get_total_records(context):
    if not context.user_data or "history_params" not in context.user_data:
        logger.error("Отсутствуют параметры истории в context.user_data")
        return 0

    params = context.user_data["history_params"]
    conn = sqlite3.connect(DB_FILE)
    try:
        cursor = conn.cursor()

        # Базовый параметр запроса
        params_list = [params["entity_id"]]
        date_filter = ""

        # Добавляем фильтр даты если есть
        selected_date = context.user_data.get("selected_date")
        if selected_date:
            db_date = selected_date["db_format"]
            year_specified = selected_date["year_specified"]

            if year_specified:
                date_filter = " AND substr(timestamp, 1, 10) = ?"
            else:
                date_filter = " AND substr(timestamp, 1, 5) = ?"

            params_list.append(db_date)

        # Формируем запрос в зависимости от типа истории
        if params["history_type"] == "bike":
            query = f"""
                SELECT COUNT(*)
                FROM bike_history
                WHERE bike_id = ?{date_filter}
            """
        else:
            query = f"""
                SELECT COUNT(*)
                FROM bike_history
                WHERE user_id = ?{date_filter}
            """

        cursor.execute(query, params_list)
        return cursor.fetchone()[0]

    except Exception as e:
        logger.error(f"Ошибка при подсчете записей: {e}")
        return 0
    finally:
        conn.close()
# Основные импорты
import logging
from datetime import datetime
import sqlite3

# Импорты из библиотеки python-telegram-bot
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
)
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
)
from telegram.error import BadRequest
def escape_markdown(text: str) -> str:
    escape_chars = r'_*[]()~`>#+-=|{}.!'
    return ''.join(f'\\{char}' if char in escape_chars else char for char in str(text))

async def format_history_message(context, history, page):
    if not context.user_data or "history_params" not in context.user_data:
        logger.error("History params missing in context")
        return "🚫 Ошибка: данные истории недоступны."

    params = context.user_data["history_params"]
    total = await get_total_records(context)
    total_pages_val = total_pages(total)

    # Получение информации о сущности
    entity_info = ""
    conn = sqlite3.connect(DB_FILE)
    try:
        cursor = conn.cursor()

        if params["history_type"] == "user":
            cursor.execute(
                "SELECT first_name, last_name, username FROM users WHERE id = ?",
                (params["entity_id"],)
            )
            user_data = cursor.fetchone()
            if user_data:
                entity_info = (
                    f"👤 Пользователь: {user_data[0]} {user_data[1]}\n"
                    f"🆔 @{user_data[2] if user_data[2] else 'без username'}\n"
                )
            else:
                entity_info = f"🆔 ID пользователя: {params['entity_id']}\n"

        elif params["history_type"] == "bike":
            cursor.execute(
                "SELECT name, available FROM bikes WHERE id = ?",
                (params["entity_id"],)
            )
            bike_data = cursor.fetchone()
            if bike_data:
                status = "🟢 Доступен" if bike_data[1] == 1 else "🔴 Занят"
                entity_info = (
                    f"🚴 Велосипед: {bike_data[0]}\n"
                    f"{status}\n"
                )
            else:
                entity_info = f"🆔 ID велосипеда: {params['entity_id']}\n"

    except Exception as e:
        logger.error(f"Database error: {e}")
        entity_info = f"🆔 ID объекта: {params['entity_id']}\n"
    finally:
        conn.close()

    # Фильтр даты
    date_filter = context.user_data.get("selected_date", {}).get("string", "все время")

    # Формирование заголовка
    header = (
        f"📋 ИСТОРИЯ {'ПОЛЬЗОВАТЕЛЯ' if params['history_type'] == 'user' else 'ВЕЛОСИПЕДА'}\n"
        "──────────────────────────────────────────────\n"
        f"{entity_info.strip()}\n"
        f"📅 Фильтр: {date_filter}\n"
        f"📑 Страница: {page}/{total_pages_val}\n"
        f"🔢 Всего записей: {total}\n\n"
    )

    # Формирование тела сообщения
    body = []
    for idx, record in enumerate(history, start=1):
        entry_number = (page - 1) * 3 + idx
        entry = [f"🔸 Запись #{entry_number}"]

        try:
            if params["history_type"] == "bike":
                user_info = (
                    f"👤 Пользователь: {record[0]} {record[1]}\n"
                    f"🆔 @{record[2] if record[2] else 'без username'}"
                )
                time_action = (
                    f"⏱ Время: {await parse_and_format_time(record[4])}\n"
                    f"📌 Действие: {record[3].capitalize()}"
                )
                details = f"📄 Детали:\n{record[5]}" if record[5] else ""
            else:
                bike_info = f"🚴 Велосипед: {record[0]}"
                time_action = (
                    f"⏱ Время: {await parse_and_format_time(record[2])}\n"
                    f"📌 Действие: {record[1].capitalize()}"
                )
                details = f"📄 Детали:\n{record[3]}" if record[3] else ""

            entry.extend([
                user_info if params["history_type"] == "bike" else bike_info,
                time_action,
                details,
                "──────────────────────────────────────────────"
            ])

        except (IndexError, TypeError) as e:
            logger.error(f"Ошибка формата записи: {e}")
            entry.append("⚠️ Некорректный формат данных")
            entry.append("──────────────────────────────────────────────")

        body.append("\n".join(filter(None, entry)))

    return header + "\n\n".join(body)

async def get_paginated_history(context, page):
    if not context.user_data or "history_params" not in context.user_data:
        logger.error("Отсутствуют параметры истории в context.user_data")
        return None

    params = context.user_data["history_params"]
    per_page = 3
    offset = (page - 1) * per_page

    date_filter = ""
    params_list = [params["entity_id"]]  # bike_id или user_id в зависимости от типа

    # Добавляем фильтр по дате, если есть
    selected_date = context.user_data.get("selected_date")
    if selected_date:
        db_date = selected_date["db_format"]
        year_specified = selected_date["year_specified"]

        if year_specified:
            date_filter = " AND substr(timestamp, 1, 10) = ?"
        else:
            date_filter = " AND substr(timestamp, 1, 5) = ?"

        params_list.append(db_date)

    params_list.extend([per_page, offset])

    conn = sqlite3.connect(DB_FILE)
    try:
        cursor = conn.cursor()

        if params["history_type"] == "bike":
            # Уточненный запрос для истории велосипеда
            query = f"""
                SELECT
                    u.first_name,
                    u.last_name,
                    u.username,
                    bh.action,
                    bh.timestamp,
                    bh.details
                FROM bike_history bh
                JOIN users u ON bh.user_id = u.id
                WHERE bh.bike_id = ?{date_filter}
                ORDER BY bh.timestamp DESC
                LIMIT ? OFFSET ?
            """
        else:
            # Запрос для истории пользователя
            query = f"""
                SELECT
                    b.name,
                    bh.action,
                    bh.timestamp,
                    bh.details
                FROM bike_history bh
                JOIN bikes b ON bh.bike_id = b.id
                WHERE bh.user_id = ?{date_filter}
                ORDER BY bh.timestamp DESC
                LIMIT ? OFFSET ?
            """

        logger.info(f"Выполняется запрос: {query}")
        logger.info(f"Параметры: {params_list}")
        cursor.execute(query, params_list)
        records = cursor.fetchall()

        if not records:
            logger.info("История пуста для выбранных параметров.")
            return None

        return records

    except Exception as e:
        logger.error(f"Ошибка при выполнении запроса: {e}")
        return None
    finally:
        conn.close()

def total_pages(total_records):
    return (total_records + 2) // 3  # Округление вверх для 3 записей на странице

async def build_pagination_keyboard(context, current_page):
    if not context.user_data or "history_params" not in context.user_data:
        logger.error("Отсутствуют параметры истории в context.user_data")
        return []

    params = context.user_data["history_params"]
    total = await get_total_records(context)
    total_pages_val = total_pages(total)

    # Создаем ряд пагинации
    pagination_buttons = []
    if current_page > 1:
        pagination_buttons.append(
            InlineKeyboardButton(
                "<",
                callback_data=f"history_pagination_{params['history_type']}_{params['entity_id']}_{current_page - 1}"
            )
        )
    if current_page < total_pages_val:
        pagination_buttons.append(
            InlineKeyboardButton(
                ">",
                callback_data=f"history_pagination_{params['history_type']}_{params['entity_id']}_{current_page + 1}"
            )
        )

    # Кнопка "Вернуться" всегда отображается
    return_button = [InlineKeyboardButton("🔄 Вернуться", callback_data="clear_date")]

    # Собираем клавиатуру
    keyboard = []
    if pagination_buttons:
        keyboard.append(pagination_buttons)
    keyboard.append(return_button)  # Добавляем кнопку в любом случае

    return keyboard




async def show_work_menu(update: Update, context) -> None:
    user_id = update.message.from_user.id
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем последний статус рабочего дня
    cursor.execute("SELECT status FROM attendance WHERE user_id=? ORDER BY timestamp DESC LIMIT 1", (user_id,))
    last_status = cursor.fetchone()

    conn.close()

    keyboard = []

    if last_status:
        # Определяем последний статус
        last_status = last_status[0]
        if last_status == 'start of work':
            keyboard.append(["🏁 Завершить рабочий день"])  # Отображаем кнопку завершения, если рабочий день начат
        elif last_status == 'end of work':
            keyboard.append(["📝 Отметиться на работе"])  # Отображаем кнопку "Отметиться на работе", если рабочий день завершен
    else:
        keyboard.append(["📝 Отметиться на работе"])  # Если нет статуса, показываем кнопку для отметки на работе

    # Всегда показываем другие окна
    keyboard.append(["📜 История отметок"])
    keyboard.append(["🏠 Вернуться в главное меню"])

    await update.message.reply_text("Выберите действие:", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True))

async def mark_attendance(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Шаг 1 (Начало дня): Просит прислать геолокацию для отметки о начале работы."""
    user_id = update.message.from_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 У вас нет прав для этого действия.")
        return

    # Сохраняем намерение пользователя, чтобы следующая функция знала, что делать
    context.user_data['attendance_action'] = 'start'
    
    await update.message.reply_text(
        "Чтобы начать рабочий день, пожалуйста, отправьте вашу текущую геопозицию.",
        reply_markup=ReplyKeyboardMarkup(
            [[KeyboardButton("📍 Отправить геопозицию", request_location=True)]],
            resize_keyboard=True, one_time_keyboard=True
        )
    )

async def request_attendance(update: Update, context) -> None:
    query = update.callback_query
    await query.answer()

    if query.data == "request_attendance":
        await query.message.reply_text("📍 Отправьте свою геопозицию:", reply_markup=ReplyKeyboardMarkup(
            [[KeyboardButton("📍 Отправить геопозицию", request_location=True)]],
            resize_keyboard=True,
            one_time_keyboard=True))

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ view_attendance_history НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ view_attendance_history НА ЭТУ ВЕРСИЮ
async def view_attendance_history(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query if hasattr(update, 'callback_query') else None
    if query:
        await query.answer()
        user_id = query.from_user.id
    else:
        user_id = update.message.from_user.id

    # Подключение к базе данных
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # <<< НАЧАЛО ИЗМЕНЕНИЙ: Получаем имя и username пользователя >>>
    cursor.execute("SELECT first_name, last_name, username FROM users WHERE id=?", (user_id,))
    user_info = cursor.fetchone()
    
    user_name_display = f"Пользователь ID {user_id}" # Значение по умолчанию
    if user_info:
        full_name = f"{user_info[0] or ''} {user_info[1] or ''}".strip()
        username_part = f"(@{user_info[2]})" if user_info[2] else ""
        # Собираем итоговую строку, убирая лишние пробелы
        user_name_display = f"{full_name} {username_part}".strip()
    # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

    cursor.execute("SELECT timestamp, status, latitude, longitude FROM attendance WHERE user_id=? ORDER BY timestamp", (user_id,))
    records = cursor.fetchall()
    conn.close()

    if not records:
        await context.bot.send_message(chat_id=user_id, text=f"🚫 У пользователя {user_name_display} нет отметок о работе.")
        return

    # Формируем список сессий (без изменений)
    sessions = []
    for i in range(0, len(records), 2):
        if i + 1 < len(records):
            start_record = records[i]
            end_record = records[i + 1]
            start_time = datetime.strptime(start_record[0], "%Y-%m-%d %H:%M:%S")
            end_time = datetime.strptime(end_record[0], "%Y-%m-%d %H:%M:%S")
            duration = end_time - start_time
            session_text = (
                f"🔵 Начало: {start_time.strftime('%H:%M')} "
                f"([гео](https://www.google.com/maps?q={start_record[2]},{start_record[3]}))\n"
                f"🔴 Конец: {end_time.strftime('%H:%M')} "
                f"([гео](https://www.google.com/maps?q={end_record[2]},{end_record[3]}))\n"
                f"⏳ Время: {duration.seconds // 3600} ч {(duration.seconds % 3600) // 60} м\n\n"
            )
            sessions.append((session_text, duration))

    # Пагинация (без изменений)
    per_page = 7
    total_pages = (len(sessions) + per_page - 1) // per_page
    current_page = 0
    if query and query.data.startswith('attendance_page:'):
        try:
            current_page = int(query.data.split(':')[1])
        except (IndexError, ValueError):
            current_page = 0
    current_page = max(0, min(current_page, total_pages - 1))
    start_idx = current_page * per_page
    end_idx = start_idx + per_page
    page_sessions = sessions[start_idx:end_idx]

    # <<< ИЗМЕНЕНИЕ: Добавляем имя и username в заголовок >>>
    attendance_history = f"📅 *История отметок о работе: {user_name_display}*\n\n" + "".join([s[0] for s in page_sessions])

    page_duration = sum((s[1] for s in page_sessions), timedelta())
    attendance_history += (
        f"🕐 *Общее время на странице:* "
        f"{page_duration.days * 24 + page_duration.seconds // 3600} ч "
        f"{(page_duration.seconds % 3600) // 60} м"
    )

    keyboard = []
    nav_row = []
    if current_page > 0:
        nav_row.append(InlineKeyboardButton("<", callback_data=f'attendance_page:{current_page - 1}'))
    if current_page < total_pages - 1:
        nav_row.append(InlineKeyboardButton(">", callback_data=f'attendance_page:{current_page + 1}'))
    if nav_row:
        keyboard.append(nav_row)

    reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None

    if query:
        await query.edit_message_text(
            text=attendance_history,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
    else:
        await context.bot.send_message(
            chat_id=user_id,
            text=attendance_history,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

async def start(update: Update, context) -> None:
    user_id = update.message.from_user.id
    context.user_data['user_id'] = user_id  # Сохраняем user_id в user_data

    await update.message.reply_text(
        "Привет! 👋 Выберите действие из меню ниже.",
        reply_markup=get_main_menu(user_id)
    )

MONTHS_RU = {
    1: "января",
    2: "февраля",
    3: "марта",
    4: "апреля",
    5: "мая",
    6: "июня",
    7: "июля",
    8: "августа",
    9: "сентября",
    10: "октября",
    11: "ноября",
    12: "декабря"
}

def format_timestamp(timestamp: str) -> str:
    """
    Преобразует временную метку из формата '%Y-%m-%d %H:%M:%S' в '20 января 13:00'.
    """
    dt = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S')
    day = dt.day
    month = MONTHS_RU[dt.month]
    time = dt.strftime('%H:%M')
    return f"{day} {month} {time}"

async def show_notifications(update: Update, context) -> None:
    user_id = update.message.from_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 У вас нет прав для просмотра уведомлений.")
        return

    # Получаем уведомления из БД
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT message, created_at FROM notifications ORDER BY created_at DESC")
    notifications = cursor.fetchall()
    conn.close()

    if not notifications:
        await update.message.reply_text("🚫 Нет новых уведомлений.")
        return

    # Сохраняем данные для пагинации
    context.user_data['notifications'] = notifications
    context.user_data['current_page'] = 0

    # Отправляем первую страницу
    await send_notification_page(update, context)

async def send_notification_page(update: Update, context, is_edit=False):
    notifications = context.user_data['notifications']
    current_page = context.user_data['current_page']
    items_per_page = 5

    # Рассчитываем страницы
    total_pages = (len(notifications) + items_per_page - 1) // items_per_page
    start_idx = current_page * items_per_page
    page_data = notifications[start_idx : start_idx + items_per_page]

    # Форматируем текст
    header = f"📬 *Уведомления* (Страница {current_page + 1}/{total_pages}):\n\n"
    formatted = [f"*{format_timestamp(ts)}*: {msg}\n---" for msg, ts in page_data]
    text = header + "\n".join(formatted)

    # Создаем клавиатуру
    keyboard = []
    if current_page > 0:
        keyboard.append(InlineKeyboardButton("← Назад", callback_data="noti_prev"))
    if current_page < total_pages - 1:
        keyboard.append(InlineKeyboardButton("Вперед →", callback_data="noti_next"))
    keyboard.append(InlineKeyboardButton("🗑️ Удалить всё", callback_data="noti_delete"))

    reply_markup = InlineKeyboardMarkup([keyboard])

    # Отправляем или редактируем сообщение
    if is_edit:
        await update.callback_query.edit_message_text(
            text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

async def handle_noti_button(update: Update, context):
    query = update.callback_query
    data = query.data

    if data == "noti_prev":
        context.user_data['current_page'] -= 1
    elif data == "noti_next":
        context.user_data['current_page'] += 1
    elif data == "noti_delete":
        # Удаление из БД
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM notifications")
        conn.commit()
        conn.close()

        # Очистка контекста
        context.user_data.pop('notifications', None)
        await query.edit_message_text("✅ Все уведомления удалены!")
        return

    # Обновляем страницу
    await send_notification_page(update, context, is_edit=True)
    await query.answer()

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext  # <-- Добавить этот импорт
import sqlite3
from datetime import datetime
import sqlite3
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CallbackContext, ConversationHandler, MessageHandler, filters, CallbackQueryHandler
from datetime import datetime, timedelta
import logging

# Настройка логирования
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Определение состояний
POISK_STATE = 1
RENTAL_REPAIR_REASON = 2
RENTAL_REPAIR_PERSON = 3
RENTAL_REPAIR_WARRANTY = 4
RENTAL_REPAIR_WARRANTY_AMOUNT = 5
RENTAL_REPAIR_ESTIMATED_DATE = 6
CUSTOM_EXTENSION = 7

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ manage_rentals НА ЭТУ
MANAGE_RENTALS_MENU, AWAITING_POISK_INPUT = range(20, 22) # Используем новый, свободный диапазон
async def manage_rentals(update: Update, context: CallbackContext) -> int:
    """
    Точка входа в диалог "Управление арендами". Показывает главное меню выбора.
    """
    user_id = update.message.from_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 У вас нет прав для управления арендой.")
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton("🚲 Клиенты на наших велосипедах", callback_data="rental_filter_own_0")],
        [InlineKeyboardButton("💼 Клиенты на инвесторских", callback_data="rental_filter_investor_0")],
        [InlineKeyboardButton("🌐 Все клиенты с арендой", callback_data="rental_filter_all_0")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "👇 Выберите, каких арендаторов показать:",
        reply_markup=reply_markup
    )
    
    # Переходим в основное состояние меню этого диалога
    return MANAGE_RENTALS_MENU

async def poisk_start(update: Update, context: CallbackContext) -> int:
    """
    Запрашивает у пользователя текст для поиска и переводит диалог в состояние ожидания ввода.
    """
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("🔍 Введите имя, фамилию или @username для поиска:")
    
    # Переходим в состояние ожидания текстового ввода
    return AWAITING_POISK_INPUT

async def poisk_handle(update: Update, context: CallbackContext) -> int:
    """
    Принимает текстовый ввод, ищет пользователей и показывает результат.
    """
    poisk_term = update.message.text.strip()
    search_pattern = f"%{poisk_term}%"

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    query = """
        SELECT DISTINCT u.id, u.first_name, u.last_name, u.username
        FROM users u JOIN bookings b ON u.id = b.user_id
        WHERE (u.first_name LIKE ? OR u.last_name LIKE ? OR u.username LIKE ?) AND b.status = 'rented'
    """
    cursor.execute(query, (search_pattern, search_pattern, search_pattern))
    users = cursor.fetchall()
    conn.close()

    if not users:
        await update.message.reply_text("🚫 По вашему запросу пользователей с активными арендами не найдено.")
        # Возвращаемся в главное меню этого диалога, чтобы можно было попробовать снова
        await manage_rentals(update, context)
        return MANAGE_RENTALS_MENU

    # Если пользователи найдены, сохраняем их и показываем
    context.user_data['all_users'] = users
    await show_users_page(update, context, page=0)
    
    # Возвращаемся в состояние меню, чтобы работали кнопки пагинации и "Новый поиск"
    return MANAGE_RENTALS_MENU

# ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ В ВАШ КОД

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_filtered_rentals НА ЭТУ УЛУЧШЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_filtered_rentals НА ЭТУ УЛУЧШЕННУЮ ВЕРСИЮ

async def show_filtered_rentals(update: Update, context: CallbackContext) -> None:
    """
    ФИНАЛЬНАЯ ВЕРСИЯ:
    - Показывает отфильтрованный список клиентов.
    - Для каждого клиента отображает тип его САМОЙ СРОЧНОЙ сделки (Аренда или Выкуп).
    - Корректно сортирует список по дате оплаты (самые срочные вверху).
    - Отображает оставшиеся дни или статус просрочки.
    """
    query = update.callback_query
    await query.answer()

    # Вспомогательная функция для правильного склонения слова "день"
    def get_day_suffix(days: int) -> str:
        days = abs(days)
        if days % 10 == 1 and days % 100 != 11:
            return "день"
        elif 2 <= days % 10 <= 4 and (days % 100 < 10 or days % 100 >= 20):
            return "дня"
        return "дней"

    try:
        parts = query.data.split('_')
        category = parts[2]
        page = int(parts[3])
    except (IndexError, ValueError):
        logger.error(f"Ошибка парсинга callback_data: {query.data}")
        await query.edit_message_text("🚫 Произошла ошибка.")
        return

    PAGE_SIZE = 5
    
    # --- ШАГ 1: Собираем SQL-запрос для получения ВСЕХ подходящих пользователей ---
    base_sql = """
        SELECT DISTINCT u.id, u.first_name, u.last_name
        FROM users u
        JOIN bookings b ON u.id = b.user_id
        JOIN bikes bk ON b.bike_id = bk.id
        WHERE b.status = 'rented'
    """
    if category == "own":
        filter_condition = " AND bk.investor_id IS NULL"
        title = "Клиенты на наших велосипедах"
    elif category == "investor":
        filter_condition = " AND bk.investor_id IS NOT NULL"
        title = "Клиенты на инвесторских велосипедах"
    else:  # all
        filter_condition = ""
        title = "Все клиенты с арендой"

    final_query = base_sql + filter_condition
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute(final_query)
            all_users = await cursor.fetchall()

            if not all_users:
                await query.edit_message_text(f"В категории «{title}» нет клиентов с активными сделками.")
                return

            # --- ШАГ 2: Для каждого пользователя находим его самую срочную сделку ---
            users_with_deal_info = []
            today = datetime.now(MOSCOW_TZ).date()

            for user in all_users:
                deals_cursor = await conn.execute(
                    "SELECT booking_type, end_date, next_payment_date FROM bookings WHERE user_id = ? AND status = 'rented'",
                    (user['id'],)
                )
                all_deals = await deals_cursor.fetchall()
                
                soonest_date = None
                deal_type = ""

                for deal in all_deals:
                    date_str = deal['end_date'] if deal['booking_type'] == 'rent' else deal['next_payment_date']
                    if date_str:
                        try:
                            current_date = datetime.strptime(date_str, "%d.%m.%Y").date()
                            if soonest_date is None or current_date < soonest_date:
                                soonest_date = current_date
                                deal_type = "Аренда" if deal['booking_type'] == 'rent' else "Выкуп"
                        except (ValueError, TypeError):
                            continue
                
                if soonest_date:
                    users_with_deal_info.append({**user, 'due_date': soonest_date, 'type': deal_type})

            # --- ШАГ 3: Сортируем пользователей по дате (самые срочные вверху) ---
            sorted_users = sorted(users_with_deal_info, key=lambda u: u['due_date'])

            # --- ШАГ 4: Применяем пагинацию к отсортированному списку ---
            total_items = len(sorted_users)
            total_pages = (total_items + PAGE_SIZE - 1) // PAGE_SIZE
            paginated_users = sorted_users[page * PAGE_SIZE : (page + 1) * PAGE_SIZE]

            # --- ШАГ 5: Формируем кнопки с полной информацией ---
            keyboard = []
            for user_data in paginated_users:
                days_left = (user_data['due_date'] - today).days
                
                if days_left < 0:
                    status_str = f"🔴 Просрочка {abs(days_left)} {get_day_suffix(days_left)}"
                elif days_left < 3:
                    status_str = f"🟡 {days_left} {get_day_suffix(days_left)}"
                else:
                    status_str = f"🟢 {days_left} {get_day_suffix(days_left)}"

                button_text = f"{user_data['first_name']} {user_data['last_name'] or ''} | {user_data['type']} ({status_str})"
                keyboard.append([InlineKeyboardButton(button_text, callback_data=f"view_rentals_{user_data['id']}")])

            # Пагинация
            pagination_row = []
            if page > 0:
                pagination_row.append(InlineKeyboardButton("⬅️", callback_data=f"rental_filter_{category}_{page - 1}"))
            if page < total_pages - 1:
                pagination_row.append(InlineKeyboardButton("➡️", callback_data=f"rental_filter_{category}_{page + 1}"))

            if pagination_row:
                keyboard.append(pagination_row)
            keyboard.append([InlineKeyboardButton("🔍 Новый поиск", callback_data="poisk_start")])
            
            message_text = f"📋 {title} (Стр. {page + 1}/{total_pages}):"
            await query.edit_message_text(message_text, reply_markup=InlineKeyboardMarkup(keyboard))

    except Exception as e:
        logger.error(f"Ошибка БД в show_filtered_rentals: {e}", exc_info=True)
        await query.edit_message_text("🚫 Ошибка базы данных.")

# ШАГ 2.1: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ

async def report_investor_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает меню для выбора отчета по инвесторам:
    - Список инвесторов для выбора.
    - Кнопка для отчета по всем сразу.
    """
    query = update.callback_query
    await query.answer()

    # Извлекаем номер страницы из callback_data (например, report_investor_list_0)
    page = int(query.data.split('_')[-1]) if query.data.startswith('report_investor_list_') else 0
    PAGE_SIZE = 5

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            # Считаем общее количество уникальных инвесторов
            count_cursor = await conn.execute(
                "SELECT COUNT(DISTINCT investor_id) FROM bikes WHERE investor_id IS NOT NULL"
            )
            total_items = (await count_cursor.fetchone())[0]

            if total_items == 0:
                await query.edit_message_text(
                    "Не найдено инвесторов с привязанными велосипедами.",
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Назад", callback_data="report_back_to_main")]])
                )
                return

            # Получаем инвесторов для текущей страницы
            cursor = await conn.execute(
                """SELECT DISTINCT b.investor_id, u.first_name, u.last_name
                   FROM bikes b JOIN users u ON b.investor_id = u.id
                   WHERE b.investor_id IS NOT NULL
                   ORDER BY u.last_name, u.first_name
                   LIMIT ? OFFSET ?""",
                (PAGE_SIZE, page * PAGE_SIZE)
            )
            investors = await cursor.fetchall()

        keyboard = [
            # Кнопка для генерации отчета сразу по всем инвесторам
            [InlineKeyboardButton("📊 Отчет по всем инвесторам", callback_data="report_generate_investor_all")],
        ]
        
        # Добавляем кнопки для каждого инвестора на странице
        for inv in investors:
            keyboard.append([InlineKeyboardButton(
                f"{inv['first_name']} {inv['last_name'] or ''}",
                callback_data=f"report_generate_investor_{inv['investor_id']}"
            )])

        # Логика пагинации
        total_pages = (total_items + PAGE_SIZE - 1) // PAGE_SIZE
        pagination_row = []
        if page > 0:
            pagination_row.append(InlineKeyboardButton("⬅️", callback_data=f"report_investor_list_{page - 1}"))
        if page < total_pages - 1:
            pagination_row.append(InlineKeyboardButton("➡️", callback_data=f"report_investor_list_{page + 1}"))
        
        if pagination_row:
            keyboard.append(pagination_row)
        
        # Кнопка "Назад" возвращает нас в главное меню отчетов
        keyboard.append([InlineKeyboardButton("⬅️ Назад", callback_data="report_back_to_main")])

        await query.edit_message_text(
            f"Выберите инвестора для отчета или запросите отчет по всем сразу (Стр. {page + 1}/{total_pages}):",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    except Exception as e:
        logger.error(f"Ошибка при формировании списка инвесторов для отчета: {e}", exc_info=True)
        await query.edit_message_text("❌ Произошла ошибка при загрузке списка инвесторов.")


POISK_ARENDA_STATE, SHOWING_ARENDA_USERS_STATE = range(10, 12)

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ view_user_rentals НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ view_user_rentals НА ЭТУ УНИВЕРСАЛЬНУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ view_user_rentals НА ЭТУ ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ view_user_rentals НА ЭТУ ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ view_user_rentals НА ЭТУ НОВУЮ ВЕРСИЮ С MARKDOWNV2

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ view_user_rentals НА ЭТУ НОВУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ view_user_rentals НА ЭТУ ВЕРСИЮ С НОВЫМИ КНОПКАМИ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ view_user_rentals НА ЭТУ ВЕРСИЮ С НОВЫМИ КНОПКАМИ
import aiosqlite
import json
import logging
from datetime import datetime
import pytz # Важный импорт для часовых поясов
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext
from telegram.helpers import escape_markdown
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ view_user_rentals НА ЭТУ ПОЛНУЮ ВЕРСИю
# ==============================================================================
# НАЧАЛО БЛОКА 2: ПОЛНАЯ ЗАМЕНА ФУНКЦИИ ОТОБРАЖЕНИЯ СДЕЛОК
# ==============================================================================
# ==============================================================================
# НАЧАЛО БЛОКА: ИСПРАВЛЕННАЯ ФУНКЦИЯ ОТОБРАЖЕНИЯ СДЕЛОК (ФИКС Markdown)
# ==============================================================================
# ==============================================================================
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ
# ==============================================================================
OSCOW_TZ = pytz.timezone('Europe/Moscow')

def parse_bike_name_and_vin(full_name: str) -> dict:
    """
    "Умный" парсер: отделяет модель от VIN.
    """
    parts = full_name.strip().split(' ', 2)
    
    if len(parts) > 2:
        model = f"{parts[0]} {parts[1]}"
        vin = parts[2]
    elif len(parts) == 2:
        model = parts[0]
        vin = parts[1]
    else:
        vin_starters = ['JL', 'ESM', 'CNHC']
        model = full_name.strip()
        vin = '(не указан)'
        
        full_name_lower = full_name.lower()
        for prefix in vin_starters:
            prefix_lower = prefix.lower()
            if prefix_lower in full_name_lower:
                start_index = full_name_lower.find(prefix_lower)
                model = full_name[:start_index].strip()
                vin = full_name[start_index:].strip()
                if not model:
                    model = vin
                    vin = '(не указан)'
                break
                
    return {'model': model, 'vin': vin}

async def _get_deal_details_from_db(booking_id: int, conn: aiosqlite.Connection) -> dict | None:
    """
    Универсальная функция для получения всех деталей сделки одним запросом.
    """
    conn.row_factory = aiosqlite.Row
    cursor = await conn.execute("""
        SELECT 
            b.id as booking_id, b.booking_type, b.end_date, b.next_payment_date,
            b.payments_made, b.payment_plan_key,
            bk.id as bike_id, bk.name as bike_name,
            bk.buyout_total_payments, bk.buyout_payment_amount, bk.buyout_period_days,
            bk.rent_price_7d, bk.rent_price_14d, bk.rent_price_30d,
            u.id as user_id, u.first_name, u.last_name, u.username, u.phone_number
        FROM bookings b
        JOIN bikes bk ON b.bike_id = bk.id
        JOIN users u ON b.user_id = u.id
        WHERE b.id = ?
    """, (booking_id,))
    deal_data_raw = await cursor.fetchone()

    if not deal_data_raw:
        return None

    return dict(deal_data_raw)


# --- Основная функция для отображения карточек аренд (ФИНАЛЬНАЯ ВЕРСИЯ) ---

# REPLACED FUNCTION (Step 1)
async def view_user_rentals(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    ПОЛНАЯ ФИНАЛЬНАЯ ВЕРСИЯ:
    - Показывает отдельную карточку для каждой активной сделки пользователя.
    - Включает в карточку ФИО, кликабельный никнейм Telegram и номер телефона.
    - Корректно рассчитывает оставшиеся дни по московскому времени.
    - Формирует правильный набор кнопок для каждого типа сделки.
    - >>> ДОБАВЛЕНА КНОПКА "ИЗМЕНИТЬ ДАТУ" <<<
    """
    query = update.callback_query
    await query.answer()
    user_id = int(query.data.split("_")[2])
    chat_id = query.message.chat.id

    # Вспомогательные функции
    def escape_html(text: str) -> str:
        return str(text or '').replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

    def get_day_suffix(days: int) -> str:
        days = abs(days)
        if days % 10 == 1 and days % 100 != 11: return "день"
        elif 2 <= days % 10 <= 4 and (days % 100 < 10 or days % 100 >= 20): return "дня"
        return "дней"

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("SELECT id FROM bookings WHERE user_id = ? AND status = 'rented'", (user_id,))
            booking_ids = [row[0] for row in await cursor.fetchall()]

            if not booking_ids:
                await query.message.delete()
                await context.bot.send_message(chat_id=chat_id, text="🚫 У этого пользователя нет активных позиций.")
                return
            
            user_deals = []
            for booking_id in booking_ids:
                deal_details = await _get_deal_details_from_db(booking_id, conn)
                if deal_details:
                    user_deals.append(deal_details)

        await query.message.delete()
        
        today = datetime.now(MOSCOW_TZ).date()

        for deal in user_deals:
            parsed_bike = parse_bike_name_and_vin(deal['bike_name'])
            
            full_name_display = f"{escape_html(deal['first_name'])} {escape_html(deal['last_name'])}"
            phone_display = deal.get('phone_number') or 'не указан'
            
            card_parts = [
                f"🆔 <b>Сделка:</b> <code>№{escape_html(str(deal['booking_id']))}</code>",
                f"👤 <b>Клиент:</b> <code>{full_name_display}</code>",
            ]

            if deal.get('username'):
                card_parts.append(f"💬 <b>Телеграм:</b> @{escape_html(deal['username'])}")
            
            card_parts.extend([
                f"📞 <b>Телефон:</b> <code>{escape_html(phone_display)}</code>",
                f"🚲 <b>Модель:</b> <code>{escape_html(parsed_bike['model'])}</code>",
                f"🔧 <b>VIN:</b> <code>{escape_html(deal['bike_name'])}</code>",
                "------------------------------",
            ])

            keyboard = []
            if deal['booking_type'] == 'rent':
                end_date_obj = datetime.strptime(deal['end_date'], "%d.%m.%Y").date()
                days_left = (end_date_obj - today).days

                if days_left < 0:
                    status_emoji, status_text = "🔴", f"Просрочка {abs(days_left)} {get_day_suffix(days_left)}"
                elif days_left == 0:
                    status_emoji, status_text = "🟡", "Сегодня"
                else:
                    status_emoji, status_text = "🟢", f"{days_left} {get_day_suffix(days_left)}"
                
                card_parts.append(f"⏳ <b>До оплаты:</b> {status_emoji} {status_text} ({escape_html(deal['end_date'])})")
                card_parts.append("------------------------------")
                
                keyboard.append([
                    InlineKeyboardButton("🔄 Продлить", callback_data=f"extend_rental_{deal['booking_id']}"),
                    InlineKeyboardButton("✅ Принять товар", callback_data=f"accept_bike_{deal['booking_id']}")
                ])
                # <<< НОВАЯ КНОПКА ЗДЕСЬ (для аренды) >>>
                keyboard.append([InlineKeyboardButton("✏️ Изменить дату оплаты", callback_data=f"edit_date_{deal['booking_id']}")])

            elif deal['booking_type'] == 'buyout':
                total_payments = deal.get('buyout_total_payments', 0)
                payments_made = deal.get('payments_made', 0)
                payment_amount = deal.get('buyout_payment_amount', 0)
                
                card_parts.extend([
                    f"💰 <b>Сумма платежа:</b> <code>{payment_amount:,.0f} ₽</code>".replace(",", " "),
                    f"🗓️ <b>Следующий платеж:</b> до <code>{escape_html(deal.get('next_payment_date', 'не задана'))}</code>",
                    f"📊 <b>Прогресс:</b> <code>({payments_made}/{total_payments})</code>",
                ])

                keyboard.append([
                    InlineKeyboardButton("⚙️ Изменить план", callback_data=f"edit_buyout_{deal['booking_id']}"),
                    InlineKeyboardButton("✏️ +/- Платеж", callback_data=f"edit_payments_{deal['booking_id']}"),
                ])
                # <<< НОВАЯ КНОПКА ЗДЕСЬ (для выкупа) >>>
                keyboard.append([InlineKeyboardButton("✏️ Изменить дату оплаты", callback_data=f"edit_date_{deal['booking_id']}")])

            # Общие кнопки
            keyboard.append([
                InlineKeyboardButton("💰 Штраф", callback_data=f"admin_fine_{user_id}_{deal['booking_id']}"),
                InlineKeyboardButton("📜 История оплаты", callback_data=f"admin_payment_history_{user_id}")
            ])

            final_item_text = "\n".join(card_parts)
            await context.bot.send_message(
                chat_id=chat_id, text=final_item_text,
                reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML"
            )
    except Exception as e:
        logger.error(f"Ошибка в view_user_rentals: {e}", exc_info=True)
        await context.bot.send_message(chat_id=chat_id, text=f"🚫 Ошибка при загрузке данных: {e}")
AWAIT_RENT_TARIFFS_FROM_CARD = range(760, 761)

# ADD THIS NEW CODE BLOCK (Step 2)

# Определяем новое состояние для диалога
AWAIT_NEW_DATE = range(962, 963) # Используем свободный диапазон

async def start_date_edit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Начинает диалог, запрашивая новую дату."""
    query = update.callback_query
    await query.answer()
    
    booking_id = int(query.data.split('_')[-1])
    context.user_data['booking_id_for_date_edit'] = booking_id
    
    await query.message.edit_text(
        f"✏️ *Изменение даты для сделки #{booking_id}*\n\n"
        "Введите новую дату следующего платежа в формате *ДД.ММ.ГГГГ* (например, `25.12.2024`)",
        parse_mode="Markdown"
    )
    return AWAIT_NEW_DATE

async def save_new_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Проверяет, сохраняет новую дату и уведомляет всех."""
    new_date_str = update.message.text.strip()
    booking_id = context.user_data.get('booking_id_for_date_edit')
    admin_id = update.message.from_user.id

    # 1. Валидация даты
    try:
        datetime.strptime(new_date_str, "%d.%m.%Y")
    except ValueError:
        await update.message.reply_text("❌ Неверный формат. Пожалуйста, введите дату как `ДД.ММ.ГГГГ`.")
        return AWAIT_NEW_DATE # Остаемся в том же состоянии

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            await conn.execute("BEGIN")
            
            # 2. Определяем, какую колонку обновлять (end_date или next_payment_date)
            cursor = await conn.execute("SELECT booking_type, user_id, bike_id FROM bookings WHERE id = ?", (booking_id,))
            booking_info = await cursor.fetchone()
            if not booking_info:
                raise ValueError("Сделка не найдена.")

            column_to_update = 'end_date' if booking_info['booking_type'] == 'rent' else 'next_payment_date'
            
            # 3. Обновляем дату в базе
            await conn.execute(f"UPDATE bookings SET {column_to_update} = ? WHERE id = ?", (new_date_str, booking_id))
            
            # 4. Логируем действие
            log_details = f"Дата оплаты изменена администратором на {new_date_str}"
            await log_bike_action(conn, booking_info['bike_id'], booking_info['user_id'], "Изменение даты платежа", log_details)

            await conn.commit()
        
        # 5. Уведомляем администратора
        await update.message.reply_text(f"✅ Дата для сделки #{booking_id} успешно изменена на *{new_date_str}*.", parse_mode="Markdown")

        # 6. Уведомляем клиента
        await context.bot.send_message(
            chat_id=booking_info['user_id'],
            text=f"🔔 Администратор изменил дату вашего следующего платежа на *{new_date_str}*.",
            parse_mode="Markdown"
        )

    except Exception as e:
        logger.error(f"Ошибка при изменении даты платежа: {e}", exc_info=True)
        await update.message.reply_text(f"❌ Произошла ошибка: {e}")
    finally:
        context.user_data.clear()
        return ConversationHandler.END
async def start_set_tariffs_from_card(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 1: Начинает диалог, получает ID велосипеда из сделки и запрашивает цены.
    """
    query = update.callback_query
    await query.answer()

    booking_id = int(query.data.split('_')[-1])
    
    # Получаем ID велосипеда, связанного с этой сделкой
    async with aiosqlite.connect(DB_FILE) as conn:
        cursor = await conn.execute("SELECT bike_id FROM bookings WHERE id = ?", (booking_id,))
        result = await cursor.fetchone()
    
    if not result:
        await query.edit_message_text("🚫 Ошибка: не удалось найти связанную сделку.")
        return ConversationHandler.END

    # Сохраняем ID самого велосипеда, чтобы обновить его тарифы
    context.user_data['editing_bike_id_from_card'] = result[0]
    
    await query.edit_message_text(
        "Введите новые цены для аренды на *7, 14 и 30 дней* через пробел.\n\n"
        "*Пример:* `3500 7000 13000`",
        parse_mode="Markdown"
    )
    return AWAIT_RENT_TARIFFS_FROM_CARD

async def save_rent_tariffs_from_card(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 2: Принимает, проверяет и сохраняет новые цены в БД.
    """
    try:
        prices = [float(p) for p in update.message.text.split()]
        if len(prices) != 3: raise ValueError
    except ValueError:
        await update.message.reply_text("❌ Ошибка. Введите *3 числа* через пробел. Попробуйте снова.")
        return AWAIT_RENT_TARIFFS_FROM_CARD

    bike_id = context.user_data['editing_bike_id_from_card']

    async with aiosqlite.connect(DB_FILE) as conn:
        await conn.execute(
            "UPDATE bikes SET rent_price_7d = ?, rent_price_14d = ?, rent_price_30d = ? WHERE id = ?",
            (*prices, bike_id)
        )
        await conn.commit()
        
    await update.message.reply_text("✅ Тарифы аренды для этого велосипеда обновлены!")
    
    # После сохранения завершаем диалог
    context.user_data.clear()
    return ConversationHandler.END
# ==============================================================================
# КОНЕЦ БЛОКА
# ==============================================================================
# ==============================================================================
# КОНЕЦ БЛОКА 2
# ==============================================================================

# <<< НАЧАЛО НОВОГО БЛОКА КОДА >>>
AWAIT_NEW_PAYMENT_COUNT = range(960, 961)

async def edit_payments_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    booking_id = int(query.data.split('_')[-1])
    context.user_data['edit_payments_booking_id'] = booking_id
    
    await query.message.reply_text(f"✏️ Корректировка платежей для сделки #{booking_id}.\n\nВведите новое число совершенных платежей:")
    return AWAIT_NEW_PAYMENT_COUNT

async def save_new_payment_count(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        new_count = int(update.message.text)
        if new_count < 0: raise ValueError
    except ValueError:
        await update.message.reply_text("❌ Введите корректное целое число (0 или больше).")
        return AWAIT_NEW_PAYMENT_COUNT

    booking_id = context.user_data['edit_payments_booking_id']
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute("UPDATE bookings SET payments_made = ? WHERE id = ?", (new_count, booking_id))
            await conn.commit()
        await update.message.reply_text(f"✅ Успешно! Для сделки #{booking_id} установлено {new_count} совершенных платежей.")
    except Exception as e:
        logger.error(f"Ошибка при обновлении кол-ва платежей: {e}", exc_info=True)
        await update.message.reply_text("❌ Произошла ошибка при обновлении данных.")
    
    context.user_data.clear()
    return ConversationHandler.END


# --- Диалог для отмены выкупа ---
CONFIRM_CANCEL_BUYOUT = range(961, 962)

async def cancel_buyout_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    booking_id = int(query.data.split('_')[-1])
    context.user_data['cancel_buyout_booking_id'] = booking_id
    
    keyboard = [
        [InlineKeyboardButton("ДА, ОТМЕНИТЬ ВЫКУП", callback_data="confirm_cancel_buyout_yes")],
        [InlineKeyboardButton("Нет, оставить", callback_data="confirm_cancel_buyout_no")]
    ]
    await query.message.reply_text(
        f"🚨 ВЫ УВЕРЕНЫ?\n\nОтмена выкупа для сделки #{booking_id} приведет к тому, что велосипед вернется в парк, а прогресс клиента будет сброшен. Это действие необратимо.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return CONFIRM_CANCEL_BUYOUT

async def cancel_buyout_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    if query.data == "confirm_cancel_buyout_no":
        await query.edit_message_text("Отмена действия.")
        context.user_data.clear()
        return ConversationHandler.END

    booking_id = context.user_data['cancel_buyout_booking_id']
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("SELECT bike_id, user_id FROM bookings WHERE id = ?", (booking_id,))
            booking_data = await cursor.fetchone()
            if not booking_data:
                await query.edit_message_text("❌ Сделка уже была завершена или удалена.")
                return ConversationHandler.END
            
            bike_id, user_id = booking_data
            
            # 1. Удаляем сделку
            await conn.execute("DELETE FROM bookings WHERE id = ?", (booking_id,))
            # 2. Возвращаем велосипед в парк
            await conn.execute("UPDATE bikes SET available = 1 WHERE id = ?", (bike_id,))
            
            log_details = f"Выкуп по сделке #{booking_id} был отменен администратором."
            await log_bike_action(conn, bike_id, user_id, "Отмена выкупа", log_details)
            
            await conn.commit()
        
        await query.edit_message_text(f"✅ Выкуп по сделке #{booking_id} успешно отменен. Велосипед ID {bike_id} возвращен в парк.")
        await context.bot.send_message(user_id, "🔔 Администратор отменил вашу сделку по выкупу. Для уточнения деталей свяжитесь с поддержкой.")

    except Exception as e:
        logger.error(f"Ошибка при отмене выкупа: {e}", exc_info=True)
        await query.edit_message_text("❌ Произошла ошибка при отмене выкупа.")
    
    context.user_data.clear()
    return ConversationHandler.END
# --- ОБРАБОТЧИКИ ДЛЯ НОВЫХ АДМИНСКИХ КНОПОК ---

# 1. Функция для кнопки "Доп. день"
async def admin_add_extra_day(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    booking_id = int(query.data.split('_')[-1])
    admin_id = query.from_user.id
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute("BEGIN")
            cursor = await conn.execute("SELECT end_date, user_id, bike_id FROM bookings WHERE id=?", (booking_id,))
            booking = await cursor.fetchone()

            if not booking:
                await query.edit_message_text("🚫 Аренда не найдена.")
                return

            current_end_date = datetime.strptime(booking[0], '%d.%m.%Y')
            new_end_date = current_end_date + timedelta(days=1)
            new_end_date_str = new_end_date.strftime('%d.%m.%Y')

            await conn.execute("UPDATE bookings SET end_date=? WHERE id=?", (new_end_date_str, booking_id))
            
            log_details = f"Добавлен 1 бесплатный день. Новый срок: {new_end_date_str}"
            await log_bike_action(conn, booking[2], booking[1], "Доп. день (бонус)", log_details)
            
            await conn.commit()

        # Отправляем новое сообщение вместо редактирования, т.к. старое могло быть удалено
        await context.bot.send_message(chat_id=query.message.chat.id, text=f"✅ Пользователю добавлен 1 дополнительный день аренды. Новый срок: {new_end_date_str}")
        await context.bot.send_message(booking[1], f"🎉 Вам начислен бонусный день аренды! Ваш новый срок окончания: *{new_end_date_str}*", parse_mode="Markdown")

    except Exception as e:
        logger.error(f"Ошибка при добавлении доп. дня: {e}", exc_info=True)
        await context.bot.send_message(chat_id=query.message.chat.id, text="🚫 Произошла ошибка.")

# 2. Функция для кнопки "История оплаты"
# ==============================================================================
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ admin_show_payment_history НА ЭТУ ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ
# ==============================================================================

# ==============================================================================
# ОКОНЧАТЕЛЬНАЯ ИСПРАВЛЕННАЯ ВЕРСИЯ (ЗАМЕНИТЕ СТАРУЮ)
# ==============================================================================
async def admin_show_payment_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    ОКОНЧАТЕЛЬНАЯ ВЕРСИЯ С ИСПРАВЛЕНИЕМ ФОРМАТИРОВАНИЯ ДАТЫ:
    - Использует надежный ручной метод форматирования даты, чтобы избежать системных сбоев strftime.
    """
    query = update.callback_query
    await query.answer()
    user_id = int(query.data.split('_')[-1])
    chat_id = query.message.chat.id

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute(
                """SELECT action, details, timestamp 
                   FROM bike_history 
                   WHERE user_id=? AND (
                       action LIKE 'Оплата%' OR action LIKE 'Выкуп%' OR 
                       action LIKE 'Продление%' OR action LIKE 'Досрочное%' OR
                       action LIKE 'Платеж%' OR action LIKE 'Аренда%'
                   ) 
                   ORDER BY timestamp DESC""",
                (user_id,)
            )
            payments = await cursor.fetchall()
        
        if not payments:
            await context.bot.send_message(chat_id=chat_id, text="История платежей для этого пользователя пуста.")
            return

        history_parts = ["📜 *История платежей*:\n"]
        for payment in payments:
            amount_text = "Сумма не указана"
            if payment['details'] and "сумма:" in payment['details']:
                try:
                    amount_str = payment['details'].split('сумма:')[1].replace('\u00A0₽', '').strip()
                    amount_text = f"{float(amount_str):.2f} ₽"
                except (IndexError, ValueError):
                    pass
            
            payment_date_str = payment['timestamp']
            payment_date_formatted = "нет данных"

            if payment_date_str and isinstance(payment_date_str, str):
                possible_formats = [
                    '%Y-%m-%d %H:%M:%S', '%d.%m.%Y %H:%M:%S', '%d.%m.%Y',
                    '%d.%m.%y %H:%M:%S', '%d.%m.%y'
                ]
                for fmt in possible_formats:
                    try:
                        dt_obj = datetime.strptime(payment_date_str.strip(), fmt)
                        
                        # --- НАДЕЖНОЕ РУЧНОЕ ФОРМАТИРОВАНИЕ ВМЕСТО STRFTIME ---
                        payment_date_formatted = (
                            f"{dt_obj.day:02d}.{dt_obj.month:02d}.{dt_obj.year} в "
                            f"{dt_obj.hour:02d}:{dt_obj.minute:02d}"
                        )
                        # --- КОНЕЦ ИЗМЕНЕНИЯ ---
                        break 
                    except (ValueError, TypeError):
                        continue
            
            history_parts.append(
                f"\n📅 *Дата:* {payment_date_formatted}\n"
                f"📝 *Назначение:* {payment['action']}\n"
                f"💰 *Сумма:* {amount_text}"
            )
        
        await context.bot.send_message(chat_id=chat_id, text="\n".join(history_parts), parse_mode="Markdown")

    except Exception as e:
        logging.error(f"КРИТИЧЕСКАЯ ОШИБКА в 'admin_show_payment_history': {e}", exc_info=True)
        await context.bot.send_message(chat_id=chat_id, text="🚫 Произошла критическая ошибка при загрузке истории.")

# 3. Новые ConversationHandlers для "Штраф" и "Скидка"
# Определяем состояния
ADMIN_AWAIT_FINE_AMOUNT, ADMIN_AWAIT_FINE_REASON, ADMIN_AWAIT_FINE_DUE_DATE = range(810, 813)
ADMIN_AWAIT_DISCOUNT_AMOUNT, ADMIN_AWAIT_DISCOUNT_REASON, ADMIN_AWAIT_DISCOUNT_DURATION = range(813, 816)

# --- Диалог для ШТРАФА ---
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ
# ДОБАВЬТЕ ЭТУ НОВУЮ ВСПОМОГАТЕЛЬНУЮ ФУНКЦИЮ В ВАШ КОД
def _get_plan_details(payment_plan_key: str, item_name: str, item_type: str) -> dict | None:
    """
    Универсальная функция для получения деталей плана рассрочки.
    Сначала пытается разобрать ключ как кастомный JSON.
    Если не удается, ищет его в стандартных словарях BUYOUT_PLANS.
    """
    if payment_plan_key and payment_plan_key.startswith('custom_'):
        try:
            # Извлекаем JSON-часть и парсим ее
            json_part = payment_plan_key.split('custom_', 1)[1]
            custom_plan = json.loads(json_part)
            # Добавляем стандартные ключи для совместимости
            custom_plan['first_payment'] = custom_plan.get('payment_amount', 0)
            custom_plan['full_label'] = "Индивидуальный план"
            return custom_plan
        except (json.JSONDecodeError, IndexError):
            logger.error(f"Не удалось разобрать кастомный ключ плана: {payment_plan_key}")
            return None

    # Если ключ не кастомный, работаем по старой логике
    if item_type == PRODUCT_TYPE_BIKE:
        return BUYOUT_PLANS.get(payment_plan_key)
    elif item_type == PRODUCT_TYPE_BATTERY:
        model_key = '60V21Ah' if '60V21Ah' in item_name else '60V30Ah'
        if model_key in BATTERY_BUYOUT_PLANS:
            return BATTERY_BUYOUT_PLANS[model_key]['plans'].get(payment_plan_key)

    return None

# ДОБАВЬТЕ ЭТОТ БЛОК КОДА С ДРУГИМИ ConversationHandler'ами

# Определяем состояния для нового диалога
# ==============================================================================
# НАЧАЛО БЛОКА 1: ПОЛНАЯ ЗАМЕНА ДИАЛОГА "ИЗМЕНИТЬ ПЛАН"
# ==============================================================================

# Состояния для диалога (могут остаться прежними, если не конфликтуют)
AWAIT_TOTAL_PAYMENTS, AWAIT_PAYMENT_AMOUNT, AWAIT_PERIOD_DAYS = range(950, 953)

async def edit_buyout_plan_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Начинает диалог, сохраняет ID сделки."""
    query = update.callback_query
    await query.answer()
    booking_id = int(query.data.split('_')[-1])
    context.user_data['edit_buyout_booking_id'] = booking_id
    
    await query.message.edit_text(f"📝 Изменение плана для сделки #{booking_id}.\n\nВведите НОВОЕ ОБЩЕЕ количество платежей (например, 15):")
    return AWAIT_TOTAL_PAYMENTS

async def get_new_total_payments(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Принимает общее кол-во платежей."""
    try:
        total_payments = int(update.message.text)
        if total_payments <= 0: raise ValueError
        context.user_data['new_total_payments'] = total_payments
        await update.message.reply_text("Отлично. Теперь введите НОВУЮ СУММУ одного платежа (например, 5000):")
        return AWAIT_PAYMENT_AMOUNT
    except ValueError:
        await update.message.reply_text("❌ Введите корректное целое число.")
        return AWAIT_TOTAL_PAYMENTS

async def get_new_payment_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 3: Принимает сумму платежа."""
    try:
        amount = float(update.message.text.replace(',', '.'))
        if amount <= 0: raise ValueError
        context.user_data['new_payment_amount'] = amount
        await update.message.reply_text("Введите НОВЫЙ период между платежами в днях (например, 7 для недели):")
        return AWAIT_PERIOD_DAYS
    except ValueError:
        await update.message.reply_text("❌ Введите корректную сумму.")
        return AWAIT_PAYMENT_AMOUNT

async def save_updated_buyout_plan(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ФИНАЛ: Принимает период, обновляет тарифы в таблице BIKES и дату платежа в BOOKINGS.
    """
    try:
        period_days = int(update.message.text)
        if period_days <= 0: raise ValueError
    except ValueError:
        await update.message.reply_text("❌ Введите корректное число дней.")
        return AWAIT_PERIOD_DAYS

    booking_id = context.user_data['edit_buyout_booking_id']
    total_payments = context.user_data['new_total_payments']
    payment_amount = context.user_data['new_payment_amount']
    
    new_next_payment_date = (datetime.now() + timedelta(days=period_days)).strftime('%d.%m.%Y')
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            # Сначала получаем ID велосипеда из сделки
            cursor = await conn.execute("SELECT bike_id, user_id FROM bookings WHERE id = ?", (booking_id,))
            result = await cursor.fetchone()
            if not result:
                await update.message.reply_text("❌ Ошибка: сделка не найдена.")
                return ConversationHandler.END
            
            bike_id, user_id = result
            
            # 1. ОБНОВЛЯЕМ ТАРИФЫ В САМОМ ВЕЛОСИПЕДЕ
            await conn.execute(
                """UPDATE bikes 
                   SET buyout_total_payments = ?, buyout_payment_amount = ?, buyout_period_days = ?
                   WHERE id = ?""",
                (total_payments, payment_amount, period_days, bike_id)
            )
            
            # 2. ОБНОВЛЯЕМ ДАТУ ПЛАТЕЖА В СДЕЛКЕ
            await conn.execute(
                "UPDATE bookings SET next_payment_date = ? WHERE id = ?",
                (new_next_payment_date, booking_id)
            )

            log_details = f"План выкупа изменен. Новые условия: {total_payments} пл. по {payment_amount} руб. каждые {period_days} дней."
            await log_bike_action(conn, bike_id, user_id, "Изменение плана выкупа", log_details)
            
            await conn.commit()

        await update.message.reply_text(
            f"✅ План для сделки #{booking_id} успешно изменен!\n"
            f"Новая дата след. платежа: {new_next_payment_date}"
        )
    except Exception as e:
        logger.error(f"Ошибка при сохранении нового плана выкупа: {e}", exc_info=True)
        await update.message.reply_text("❌ Произошла ошибка при сохранении данных в БД.")

    context.user_data.clear()
    return ConversationHandler.END
# ==============================================================================
# КОНЕЦ БЛОКА 1
# ==============================================================================
async def admin_start_fine(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    parts = query.data.split('_')
    user_id = int(parts[2])
    
    context.user_data.clear()
    context.user_data['fine_user_id'] = user_id
    context.user_data['admin_id'] = query.from_user.id
    
    # <<< ГЛАВНОЕ ИЗМЕНЕНИЕ: Редактируем сообщение вместо отправки нового >>>
    await query.edit_message_text(
        text=f"💸 Назначение штрафа для пользователя ID {user_id}.\nВведите сумму штрафа в рублях:",
        reply_markup=None # Убираем старые кнопки
    )
    return ADMIN_AWAIT_FINE_AMOUNT

# --- Диалог для СКИДКИ ---
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ
async def admin_process_fine_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        amount = float(update.message.text.replace(',', '.'))
        if amount <= 0: raise ValueError
        context.user_data['amount'] = amount
        await update.message.reply_text("📝 Укажите причину штрафа:")
        return ADMIN_AWAIT_FINE_REASON # <-- Возвращаем ПРАВИЛЬНОЕ состояние
    except ValueError:
        await update.message.reply_text("❌ Некорректная сумма! Введите положительное число:")
        return ADMIN_AWAIT_FINE_AMOUNT

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ НОВУЮ ВЕРСИЮ

async def admin_process_fine_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 2 (ФИНАЛ): Принимает причину, СРАЗУ сохраняет штраф в БД без даты и завершает диалог.
    """
    reason = update.message.text.strip()
    if len(reason) < 5:
        await update.message.reply_text("❌ Слишком короткое описание! Минимум 5 символов:")
        return ADMIN_AWAIT_FINE_REASON

    # <<< НАЧАЛО ЛОГИКИ СОХРАНЕНИЯ (перенесено из старой функции) >>>
    try:
        user_id = context.user_data['fine_user_id']
        admin_id = context.user_data['admin_id']
        amount = context.user_data['amount']

        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            await conn.execute("BEGIN")
            
            await conn.execute(
                "INSERT INTO fines (user_id, admin_id, amount, reason, status) VALUES (?, ?, ?, ?, 'unpaid')",
                (user_id, admin_id, amount, reason)
            )
            
            cursor = await conn.execute("SELECT first_name, last_name, username FROM users WHERE id = ?", (user_id,))
            user_data = await cursor.fetchone()
            user_name = f"{user_data['first_name']} {user_data['last_name'] or ''} (@{user_data['username'] or 'N/A'})"
            
            await log_bike_action(conn, None, user_id, "Назначение штрафа", f"Сумма: {amount}₽, Причина: {reason}")
            
            await conn.commit()

        # Отправка подтверждения администратору (без даты)
        await update.message.reply_text(
            f"✅ Штраф успешно назначен!\n"
            f"▪️ Пользователь: {user_name}\n"
            f"▪️ Сумма: {amount}₽\n"
            f"▪️ Причина: {reason}"
        )
        
        # Отправка уведомления пользователю
        await context.bot.send_message(
            chat_id=user_id,
            text=(
                f"🚨 Вам назначен штраф!\n\n"
                f"▪️ Сумма: *{amount:.2f} ₽*\n"
                f"▪️ Причина: _{reason}_\n\n"
                "Вы можете оплатить или оспорить его в Личном кабинете."
            ),
            parse_mode="Markdown"
        )

    except Exception as e:
        logger.error(f"Ошибка при сохранении штрафа: {e}", exc_info=True)
        await update.message.reply_text(f"🚫 Произошла ошибка при сохранении штрафа: {e}")
    
    finally:
        context.user_data.clear()
        return ConversationHandler.END

async def admin_process_due_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    # Эта функция полностью переиспользует логику process_due_date, но завершает диалог
    await process_due_date(update, context) # Вызываем старую функцию для сохранения в БД
    return ConversationHandler.END

# --- Адаптированные функции для диалога СКИДКИ из карточки ---

async def admin_process_discount_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        amount = float(update.message.text.replace(',', '.'))
        if amount <= 0: raise ValueError
        context.user_data['discount_amount'] = amount
        await update.message.reply_text("Отлично. Теперь введите причину выдачи скидки (например, 'Бонус за лояльность'):")
        return ADMIN_AWAIT_DISCOUNT_REASON # <-- Возвращаем ПРАВИЛЬНОЕ состояние
    except ValueError:
        await update.message.reply_text("❌ Введите корректную сумму (положительное число, например, 500 или 250.5).")
        return ADMIN_AWAIT_DISCOUNT_AMOUNT

async def admin_process_discount_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reason = update.message.text.strip()
    if not reason:
        await update.message.reply_text("❌ Причина не может быть пустой.")
        return ADMIN_AWAIT_DISCOUNT_REASON
    context.user_data['discount_reason'] = reason
    await update.message.reply_text("Введите срок действия скидки в днях (например, 7):")
    return ADMIN_AWAIT_DISCOUNT_DURATION # <-- Возвращаем ПРАВИЛЬНОЕ состояние

async def admin_process_discount_duration(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    # Эта функция полностью переиспользует логику process_discount_duration, но завершает диалог
    await process_discount_duration(update, context) # Вызываем старую функцию для сохранения в БД
    return ConversationHandler.END
async def admin_start_discount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    user_id = int(query.data.split('_')[2])
    
    context.user_data.clear()
    context.user_data['discount_user_id'] = user_id
    context.user_data['admin_id'] = query.from_user.id

    # <<< ГЛАВНОЕ ИЗМЕНЕНИЕ: Редактируем сообщение вместо отправки нового >>>
    await query.edit_message_text(
        text=f"🎁 Выдача скидки для пользователя ID {user_id}.\nВведите сумму скидки в рублях (например, 500):",
        reply_markup=None # Убираем старые кнопки
    )
    return ADMIN_AWAIT_DISCOUNT_AMOUNT

# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>

# НАЙДИТЕ ЭТУ ФУНКЦИЮ И ЗАМЕНИТЕ ЕЁ

# НАЙДИТЕ ВАШУ ФУНКЦИЮ extend_rental И ЗАМЕНИТЕ ЕЕ НА ЭТУ:

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ extend_rental НА ЭТУ ВЕРСИЮ

async def extend_rental(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()

    booking_id = int(query.data.split("_")[2])

    # Получаем название велосипеда, чтобы определить тарифы для стандартных кнопок
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM bikes WHERE id = (SELECT bike_id FROM bookings WHERE id=?)", (booking_id,))
    bike_name_row = cursor.fetchone()
    conn.close()

    if not bike_name_row:
        await query.message.reply_text("🚫 Ошибка: не найден велосипед для этой аренды.")
        return

    bike_name = bike_name_row[0]
    model_key = get_bike_model_key(bike_name)
    
    keyboard = []
    if model_key:
        # Формируем стандартные кнопки с актуальными ценами
        for days in [7, 14, 30]:
            price_key = f"{model_key}_{days}"
            price = RENTAL_PRICES.get(price_key)
            if price:
                # Эти кнопки будут обрабатываться старым хендлером
                keyboard.append([InlineKeyboardButton(f"{days} дней - {price} руб", callback_data=f"extend_{days}_{booking_id}")])
    
    # --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ---
    # Кнопка для ручного бесплатного продления. Она запустит новый ConversationHandler.
    keyboard.append([InlineKeyboardButton("Другое количество дней (бесплатно)", callback_data=f"manual_ext_start_{booking_id}")])
    keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="cancel_repair")]) # Используем существующую отмену

    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.message.reply_text("Выберите, на сколько дней продлить аренду:", reply_markup=reply_markup)

# ==============================================================================
#           НОВЫЙ МОДУЛЬ ДЛЯ БЕСПЛАТНОГО ПРОДЛЕНИЯ АРЕНДЫ (АДМИН)
# ==============================================================================

# --- Состояния для диалога ---
AWAIT_MANUAL_DAYS = range(800, 801)

async def start_manual_extension(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Начинает диалог, запрашивая количество дней."""
    query = update.callback_query
    await query.answer()

    booking_id = int(query.data.split('_')[-1])
    context.user_data['manual_ext_booking_id'] = booking_id

    await query.edit_message_text("Введите количество дней для бесплатного продления:")
    return AWAIT_MANUAL_DAYS

async def process_manual_extension_days(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Принимает дни, обновляет БД и завершает диалог."""
    try:
        days_to_add = int(update.message.text.strip())
        if days_to_add <= 0:
            raise ValueError("Дней должно быть больше нуля")
    except ValueError:
        await update.message.reply_text("❌ Введите корректное число дней (например, 3).")
        return AWAIT_MANUAL_DAYS

    booking_id = context.user_data.get('manual_ext_booking_id')
    admin_id = update.message.from_user.id

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            await conn.execute("BEGIN")
            
            cursor = await conn.execute(
                "SELECT b.end_date, b.user_id, b.bike_id, bk.name as bike_name "
                "FROM bookings b JOIN bikes bk ON b.bike_id = bk.id WHERE b.id=?",
                (booking_id,)
            )
            booking_info = await cursor.fetchone()

            if not booking_info:
                raise ValueError("Аренда не найдена.")

            current_end_date = datetime.strptime(booking_info['end_date'], '%d.%m.%Y')
            new_end_date = current_end_date + timedelta(days=days_to_add)
            new_end_date_str = new_end_date.strftime('%d.%m.%Y')
            
            await conn.execute("UPDATE bookings SET end_date=? WHERE id=?", (new_end_date_str, booking_id))
            
            log_details = f"Аренда продлена бесплатно на {days_to_add} дней. Новый срок: {new_end_date_str}"
            await log_bike_action(conn, booking_info['bike_id'], booking_info['user_id'], "Продление (бесплатно)", log_details)
            
            await conn.commit()

        # Уведомление администратору
        await update.message.reply_text(
            f"✅ Аренда #{booking_id} бесплатно продлена на {days_to_add} дней.\n"
            f"Новая дата окончания: {new_end_date_str}"
        )

        # Уведомление пользователю
        await context.bot.send_message(
            chat_id=booking_info['user_id'],
            text=(f"🎉 Ваша аренда велосипеда *{booking_info['bike_name']}* была бесплатно продлена администратором!\n\n"
                  f"Новая дата окончания: *{new_end_date_str}*")
            , parse_mode="Markdown"
        )
        
    except Exception as e:
        logger.error(f"Ошибка в process_manual_extension_days: {e}", exc_info=True)
        await update.message.reply_text(f"❌ Произошла ошибка: {e}")
    finally:
        context.user_data.clear()
        return ConversationHandler.END

async def cancel_manual_extension(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет диалог и удаляет сообщение."""
    await update.callback_query.answer()
    await update.callback_query.edit_message_text("Действие отменено.")
    context.user_data.clear()
    return ConversationHandler.END

# ДОБАВЬТЕ ЭТИ НОВЫЕ ФУНКЦИИ В ВАШ КОД

async def handle_custom_extension_start(update: Update, context: CallbackContext) -> int:
    """Шаг 1: Начинает диалог кастомного продления, запрашивая количество дней."""
    query = update.callback_query
    await query.answer()

    # Извлекаем booking_id из callback_data и сохраняем в контекст
    booking_id = int(query.data.split("_")[-1])
    context.user_data['extending_booking_id'] = booking_id

    await query.edit_message_text(
        "Введите количество дней для продления (например, 10):"
    )
    return CUSTOM_EXTENSION_DAYS

async def process_custom_extension_days(update: Update, context: CallbackContext) -> int:
    """Шаг 2: Принимает количество дней и запрашивает общую цену."""
    try:
        days = int(update.message.text.strip())
        if days <= 0:
            raise ValueError
        context.user_data['custom_extension_days'] = days
        await update.message.reply_text("Теперь введите ОБЩУЮ стоимость для этого срока (например, 5000):")
        return AWAIT_CUSTOM_PRICE
    except ValueError:
        await update.message.reply_text("Пожалуйста, введите корректное число (целое, больше 0).")
        return CUSTOM_EXTENSION_DAYS

# main.py

# main.py

async def process_custom_price_and_pay(update: Update, context: CallbackContext) -> int:
    """
    Шаг 3 (ФИНАЛ): Принимает цену, отправляет клиенту уведомление о согласовании,
    затем ОТДЕЛЬНЫМ сообщением выставляет счет и запускает проверку.
    """
    try:
        price = float(update.message.text.strip().replace(',', '.'))
        if price <= 0:
            raise ValueError
    except ValueError:
        await update.message.reply_text("Пожалуйста, введите корректную положительную сумму (число).")
        return AWAIT_CUSTOM_PRICE

    # 1. Получаем все нужные данные из контекста и БД
    booking_id = context.user_data.get('extending_booking_id')
    days_to_extend = context.user_data.get('custom_extension_days')
    admin_id = update.message.from_user.id

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("""
        SELECT b.user_id, b.bike_id, bk.name, u.phone_number
        FROM bookings b
        JOIN bikes bk ON b.bike_id = bk.id
        JOIN users u ON b.user_id = u.id
        WHERE b.id = ?
    """, (booking_id,))
    result = cursor.fetchone()
    conn.close()

    if not result:
        await update.message.reply_text("🚫 Ошибка: бронирование не найдено.")
        return ConversationHandler.END

    user_id, bike_id, bike_name, phone_number = result

    if not phone_number:
        await update.message.reply_text(f"🚫 Ошибка: у пользователя ID {user_id} не указан номер телефона для чека.")
        return ConversationHandler.END

    # 2. Формируем данные для платежа (без изменений)
    description = f"Продление аренды '{bike_name}' на {days_to_extend} дн. (индивид. тариф)"
    payload = f"prolong_{booking_id}_{days_to_extend}"
    metadata = {'internal_payload': payload, 'user_id': user_id, 'admin_id': admin_id}
    items_for_receipt = [{"description": description, "quantity": "1.00", "amount": {"value": f"{price:.2f}", "currency": "RUB"}, "vat_code": "1", "payment_subject": "service", "payment_mode": "full_payment"}]
    customer_info = {"phone": phone_number}

    # 3. Создаем платеж (без изменений)
    payment_info = await create_yookassa_payment(
        amount=price, description=description, metadata=metadata,
        items=items_for_receipt, customer_info=customer_info, payment_method='sbp'
    )

    if not (payment_info and payment_info.get('url')):
        await update.message.reply_text("❌ Не удалось создать ссылку на оплату в ЮKassa. Попробуйте позже.")
        return ConversationHandler.END

    # 4. Отправляем сообщения и запускаем проверку
    payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']

    # Уведомление для админа (без изменений)
    async with aiosqlite.connect(DB_FILE) as conn_async:
        conn_async.row_factory = aiosqlite.Row
        user_name_formatted = await get_user_info_for_notification(user_id, conn_async)
    await update.message.reply_text(
        f"✅ Счет на сумму {final_amount:.2f} ₽ для пользователя {user_name_formatted} успешно создан и отправлен."
    )

    # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>

    # ПЕРВОЕ сообщение для клиента - уведомление о согласовании
    await context.bot.send_message(
        chat_id=user_id,
        text=f"✅ Ваше продление на *{days_to_extend} дней* согласовано! Готовим счет...",
        parse_mode="Markdown"
    )

    # ВТОРОЕ сообщение для клиента - уже сам счет
    user_invoice_message = f"Нажмите кнопку для оплаты {final_amount:.2f} ₽"
    keyboard = [[InlineKeyboardButton("💳 Оплатить", url=payment_url)]]

    # Запускаем анимацию на втором сообщении
    animated_message = await context.bot.send_message(
        chat_id=user_id,
        text=user_invoice_message,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

    # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

    # 5. Запускаем фоновую проверку статуса (без изменений)
    if 'pending_payments' not in context.bot_data:
        context.bot_data['pending_payments'] = {}

    stop_animation_event = asyncio.Event()
    context.bot_data['pending_payments'][payment_id] = {
        'user_id': user_id, 'start_time': datetime.now(),
        'payload': metadata['internal_payload'], 'amount': final_amount,
        'animated_message_id': animated_message.message_id, 'url': payment_url,
        'animation_sequence': random.choice(PAYMENT_ANIMATIONS),
        'stop_animation_event': stop_animation_event
    }

    asyncio.create_task(animate_payment_message(context, payment_id))
    context.job_queue.run_repeating(
        callback=check_payment_status, interval=15, first=10,
        name=f"payment_{payment_id}", data={'yookassa_id': payment_id}
    )

    context.user_data.clear()
    return ConversationHandler.END

async def handle_custom_extension(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    booking_id = int(query.data.split("_")[2])
    context.user_data['extending_booking_id'] = booking_id

    await query.message.reply_text(
        "Введите количество дней для продления (от 1 до 30):"
    )
    return CUSTOM_EXTENSION

async def process_custom_extension(update: Update, context: CallbackContext) -> int:
    try:
        days = int(update.message.text.strip())
        if days < 1 or days > 30:
            await update.message.reply_text("Пожалуйста, введите число от 1 до 30.")
            return CUSTOM_EXTENSION

        booking_id = context.user_data.get('extending_booking_id')
        await process_extension(update, context, days, booking_id)
        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text("Пожалуйста, введите корректное число.")
        return CUSTOM_EXTENSION

async def handle_extension_choice(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    data_parts = query.data.split("_")

    if data_parts[1] == "custom":
        return await handle_custom_extension(update, context)

    days_to_extend = int(data_parts[1])
    booking_id = int(data_parts[2])

    await process_extension(update, context, days_to_extend, booking_id)

async def process_extension(update: Update, context: CallbackContext, days_to_extend: int, booking_id: int):
    # Определяем стоимость в зависимости от количества дней
    if days_to_extend <= 7:
        extension_price = 3750
    elif days_to_extend <= 14:
        extension_price = 7500
    else:
        extension_price = 15000

    # Создаем клавиатуру для подтверждения оплаты
    keyboard = [
        [
            InlineKeyboardButton("✅ Оплата получена", callback_data=f"payment_yes_{booking_id}_{days_to_extend}_{extension_price}"),
            InlineKeyboardButton("❌ Оплаты нет", callback_data=f"payment_no_{booking_id}_{days_to_extend}")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    message = (
        f"Продление на {days_to_extend} дней\n"
        f"Сумма к оплате: {extension_price} руб.\n\n"
        f"Подтвердите получение оплаты:"
    )

    if isinstance(update, Update) and update.message:
        await update.message.reply_text(message, reply_markup=reply_markup)
    else:
        await update.callback_query.message.reply_text(message, reply_markup=reply_markup)

async def handle_payment_confirmation(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    data_parts = query.data.split("_")
    payment_received = data_parts[1] == "yes"
    booking_id = int(data_parts[2])
    days_to_extend = int(data_parts[3])

    # Если оплата получена, у нас будет сумма в запросе
    extension_price = int(data_parts[4]) if payment_received else None

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    try:
        cursor.execute("""
            SELECT b.end_date, b.user_id, bi.name, bi.id, b.status
            FROM bookings b
            JOIN bikes bi ON b.bike_id = bi.id
            WHERE b.id = ?
        """, (booking_id,))
        booking_info = cursor.fetchone()

        if not booking_info:
            await query.message.reply_text("🚫 Ошибка: бронирование не найдено")
            return

        current_end_date, user_id, bike_name, bike_id, status = booking_info

        if status != 'rented':
            await query.message.reply_text("🚫 Ошибка: аренда не активна")
            return

        current_end_date_obj = datetime.strptime(current_end_date, '%d.%m.%Y')
        current_date = datetime.now()

        overdue_days = (current_date - current_end_date_obj).days if current_date > current_end_date_obj else 0
        effective_days = max(days_to_extend - overdue_days, 0)
        new_end_date = current_date + timedelta(days=effective_days) if overdue_days else current_end_date_obj + timedelta(days=days_to_extend)

        new_end_date_str = new_end_date.strftime('%d.%m.%Y')

        cursor.execute("UPDATE bookings SET end_date=? WHERE id=?", (new_end_date_str, booking_id))
        conn.commit()

        payment_status = "✅ Оплачено" if payment_received else "❌ Без оплаты"
        admin_msg = (
            f"🔄 Аренда велосипеда {bike_name} продлена!\n"
            f"👤 Пользователь ID: {user_id}\n"
            f"📅 Новая дата окончания: {new_end_date_str}\n"
            f"⏳ Добавлено дней: {days_to_extend}\n"
            f"🚨 Просрочено дней: {overdue_days}\n"
            f"💰 Статус оплаты: {payment_status}"
        )

        if payment_received:
            admin_msg += f"\n💵 Сумма: {extension_price} руб."

        await query.message.reply_text(admin_msg)

        user_msg = (
            f"🚲 Ваша аренда велосипеда <b>{bike_name}</b> продлена!\n\n"
            f"📅 Новая дата окончания: <b>{new_end_date_str}</b>\n"
            f"⏳ Добавлено дней: <b>{days_to_extend}</b>\n"
            f"🚨 Просрочено дней: <b>{overdue_days}</b>\n"
        )

        if payment_received:
            user_msg += f"💰 Стоимость продления: <b>{extension_price} руб.</b>\n\n"

        user_msg += "Спасибо, что пользуетесь нашим сервисом!"

        await context.bot.send_message(
            chat_id=user_id,
            text=user_msg,
            parse_mode="HTML"
        )

        # Записываем в историю только если получена оплата
        if payment_received:
            log_bike_action(
                bike_id=bike_id,
                user_id=user_id,
                action="Продление (оплачено)",
                details=(
                    f"+{days_to_extend} дней\n"
                    f"Новый срок: {new_end_date_str}\n"
                    f"Просрочено дней: {overdue_days}"
                ),
                amount=extension_price
            )
        else:
            # Просто записываем изменение без финансовой информации
            log_bike_action(
                bike_id=bike_id,
                user_id=user_id,
                action="Продление (без оплаты)",
                details=(
                    f"+{days_to_extend} дней\n"
                    f"Новый срок: {new_end_date_str}\n"
                    f"Просрочено дней: {overdue_days}"
                )
            )

    except Exception as e:
        logger.error(f"Ошибка продления: {e}")
        await query.message.reply_text("🚫 Произошла ошибка при продлении аренды")

    finally:
        conn.close()

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ accept_rental НА ЭТУ

async def accept_rental(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()
    booking_id = int(query.data.split("_")[2])

    keyboard = [
        [
            InlineKeyboardButton("✅ Принять", callback_data=f"rental_accept_{booking_id}"),
            InlineKeyboardButton("🔧 В ремонт", callback_data=f"rental_repair_{booking_id}")
        ]
    ]

    # ### ИЗМЕНЕНИЕ: Текст стал более общим ###
    await query.edit_message_text(
        text=(
            "Нажимая *✅ Принять*:\n"
            "- Вы подтверждаете исправность товара\n"
            "- Очередь (если есть) будет обновлена\n"
            "- Товар станет доступен для аренды/выкупа\n\n"
            "Нажимая *🔧 В ремонт*:\n"
            "- Товар будет помечен как недоступен\n"
            "- Очередь (если есть) сохранится\n"
            "- Все активные брони на эту модель будут удалены"
        ),
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
async def mock_payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Обрабатывает нажатие на кнопку "Тестовая оплата".
    Имитирует успешный платеж и вызывает основной обработчик.
    """
    query = update.callback_query
    await query.answer("✅ Тестовая оплата прошла успешно!")
    # Удаляем сообщение с кнопкой, чтобы избежать повторных нажатий
    await query.message.delete()

    # Формат callback_data: mock_payment_{original_payload}_{amount_in_rubles}
    # Пример: "mock_payment_rental_123_14_6500"

    # Отделяем 'mock_payment_' от остальной части
    data_parts = query.data.split('_', 2)
    payload_with_price = data_parts[2]

    # Извлекаем сумму из конца строки
    payload_parts = payload_with_price.rsplit('_', 1)
    original_payload = payload_parts[0]
    amount_rub = int(payload_parts[1])

    user_id = query.from_user.id

    # Вызываем основной обработчик, передавая ему "фейковый" update, но с реальными данными
    await process_successful_payment(update, context, user_id, original_payload, amount_rub)
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ handle_rental_decision НА ЭТУ

async def handle_rental_decision(update: Update, context: CallbackContext, accept: bool) -> None:
    query = update.callback_query
    if not query or not query.data:
        logger.error("Отсутствует callback_query или данные")
        return

    try:
        await query.answer()
    except Exception as e:
        logger.error(f"Ошибка подтверждения запроса: {e}")
        return

    try:
        booking_id = int(query.data.split("_")[2])
    except (IndexError, ValueError) as e:
        logger.error(f"Ошибка парсинга booking_id: {e}")
        await query.message.reply_text("🚫 Некорректный идентификатор брони")
        return

    conn = None
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.row_factory = sqlite3.Row # Для удобства

        cursor.execute("SELECT bike_id, user_id FROM bookings WHERE id=?", (booking_id,))
        booking_info = cursor.fetchone()
        if not booking_info:
            await query.message.reply_text("🚫 Бронирование не найдено")
            return

        bike_id, user_id = booking_info['bike_id'], booking_info['user_id']

        # Удаляем запись о бронировании (и аренды, и рассрочки)
        cursor.execute("DELETE FROM bookings WHERE id=?", (booking_id,))

        # Обновляем статус велосипеда/АКБ
        new_status = 1 if accept else 0
        cursor.execute("UPDATE bikes SET available=?, owner_id=NULL WHERE id=?", (new_status, bike_id))
        conn.commit()

        cursor.execute("SELECT name FROM bikes WHERE id=?", (bike_id,))
        item_name_row = cursor.fetchone()
        item_name = item_name_row['name'] if item_name_row else "Неизвестный товар"

        try:
            status_text = "принят в работу" if accept else "отправлен в ремонт"
            emoji = "✅" if accept else "🔧"
            current_time = datetime.now().strftime("%d.%m.%Y %H:%M:%S")

            for admin_id in ADMIN_IDS:
                await context.bot.send_message(
                    admin_id,
                    f"{emoji} [{current_time}] Товар '{item_name}' {status_text}\nПользователь: {user_id}"
                )

            # ### ИЗМЕНЕНИЕ: Универсальное уведомление ###
            await context.bot.send_message(
                user_id,
                f"{'🚲 Товар успешно возвращен! Спасибо!' if accept else '🔧 Товар принят в ремонт. Благодарим за информацию!'}"
            )

            if accept:
                cursor.execute("SELECT id, user_id, status FROM queue ORDER BY created_at ASC")
                queue = cursor.fetchall()
                if queue:
                    first_in_queue = queue[0]
                    cursor.execute("DELETE FROM queue WHERE id=?", (first_in_queue['id'],))
                    conn.commit()
                    await context.bot.send_message(first_in_queue['user_id'], f"🎉 Товар, который вы ждали, стал доступен! Можете его арендовать.")
                    logger.info(f"Уведомление отправлено следующему в очереди: user_id {first_in_queue['user_id']}")

        except Exception as e:
            logger.error(f"Ошибка при обработке очереди или отправке уведомлений (ID брони: {booking_id}): {e}", exc_info=True)

        action_text = "Принят в работу" if accept else "В ремонт"
        details = f"Товар {item_name} {action_text.lower()}"

        # Используем синхронное подключение, если log_bike_action не асинхронный
        log_bike_action(bike_id, user_id, action_text, details)
        logger.info(f"[{current_time}] {action_text}: Товар '{item_name}', Пользователь: {user_id}")

        # Уведомляем админа об успешном завершении
        await query.message.edit_text(f"✅ Товар '{item_name}' успешно принят от пользователя.")

    except Exception as e:
        current_time = datetime.now().strftime("%d.%m.%Y %H:%M:%S")
        logger.error(f"[{current_time}] Критическая ошибка в handle_rental_decision: {e}", exc_info=True)
        await query.message.reply_text("⚠️ Произошла системная ошибка при обработке.")
    finally:
        if conn:
            conn.close()

async def process_accept_rental(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()
    booking_id = int(query.data.split("_")[2])
    await handle_rental_decision(update, context, accept=True)

async def process_start_repair(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    booking_id = int(query.data.split("_")[2])
    context.user_data['repair_booking_id'] = booking_id

    await query.edit_message_text(
        "🔧 Пожалуйста, укажите причину отправки велосипеда в ремонт:\n"
        "Опишите, что именно сломалось или требует ремонта."
    )
    return RENTAL_REPAIR_REASON

async def handle_repair_reason(update: Update, context: CallbackContext) -> int:
    reason = update.message.text
    context.user_data['repair_reason'] = reason

    await update.message.reply_text("👷 Введите имя мастера, который отправляет велосипед в ремонт:")
    return RENTAL_REPAIR_PERSON

async def handle_repair_person(update: Update, context: CallbackContext) -> int:
    repair_person = update.message.text
    context.user_data['repair_person'] = repair_person

    keyboard = [
        [InlineKeyboardButton("Да", callback_data="warranty_yes")],
        [InlineKeyboardButton("Нет", callback_data="warranty_no")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("🔧 Это гарантийный ремонт?", reply_markup=reply_markup)
    return RENTAL_REPAIR_WARRANTY

# main.py

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ handle_warranty НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ

async def handle_warranty(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    - Корректно обрабатывает выбор типа ремонта.
    - При гарантийном ремонте устанавливает цену 0 и переходит к дате.
    - При НЕгарантийном ремонте запрашивает ЦЕНУ.
    """
    query = update.callback_query
    await query.answer()

    # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>

    if query.data == "warranty_yes":
        # Если ремонт ГАРАНТИЙНЫЙ
        context.user_data['is_warranty'] = True
        # Устанавливаем цену в 0, так как оплата не требуется
        context.user_data['warranty_amount'] = 0.0
        # Сразу переходим к запросу даты завершения
        await query.edit_message_text("Гарантийный ремонт. Введите предполагаемую дату завершения (формат ДД.ММ.ГГГГ):")
        return RENTAL_REPAIR_ESTIMATED_DATE

    elif query.data == "warranty_no":
        # Если ремонт НЕ ГАРАНТИЙНЫЙ
        context.user_data['is_warranty'] = False
        # Теперь правильно запрашиваем сумму ремонта
        await query.edit_message_text("💰 Введите СТОИМОСТЬ негарантийного ремонта в рублях:")
        # И переходим в состояние ожидания суммы
        return RENTAL_REPAIR_WARRANTY_AMOUNT

    # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

    # На случай непредвиденных данных
    return ConversationHandler.END

async def handle_warranty_amount(update: Update, context: CallbackContext) -> int:
    try:
        amount = float(update.message.text)
        context.user_data['warranty_amount'] = amount
    except ValueError:
        await update.message.reply_text("🚫 Неверный формат суммы. Попробуйте ещё раз:")
        return RENTAL_REPAIR_WARRANTY_AMOUNT

    await update.message.reply_text("📅 Введите предполагаемую дату завершения ремонта (формат ДД.ММ.ГГГГ):")
    return RENTAL_REPAIR_ESTIMATED_DATE

# main.py

# Убедитесь, что эти импорты есть в начале вашего файла
import aiosqlite
from datetime import datetime
import asyncio
import random

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ handle_estimated_date НА ЭТУ УЛУЧШЕННУЮ ВЕРСИЮ
# main.py

# ... (все ваши импорты) ...

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ handle_estimated_date НА ЭТУ УЛУЧШЕННУЮ ВЕРСИЮ
# main.py

# Убедитесь, что эти импорты есть в начале вашего файла
import aiosqlite
from datetime import datetime
import asyncio
import random

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ handle_estimated_date НА ЭТУ ПОЛНУЮ ВЕРСИЮ
async def handle_estimated_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ФИНАЛ ДИАЛОГА РЕМОНТА С УЛУЧШЕННЫМИ УВЕДОМЛЕНИЯМИ И ВЫСТАВЛЕНИЕМ СЧЕТА:
    - Показывает админу ФИО пользователя.
    - Отправляет клиенту детальное сообщение о ремонте ПЕРЕД счетом.
    - Если ремонт платный, немедленно выставляет счет отдельным сообщением.
    """
    date_str = update.message.text
    admin_chat_id = update.effective_chat.id
    try:
        # Валидация даты
        datetime.strptime(date_str, "%d.%m.%Y")
        context.user_data['estimated_completion_date'] = date_str
    except ValueError:
        await update.message.reply_text("🚫 Неверный формат даты. Используйте ДД.ММ.ГГГГ. Попробуйте ещё раз:")
        return RENTAL_REPAIR_ESTIMATED_DATE

    # Собираем данные из контекста
    booking_id = context.user_data.get('repair_booking_id')
    reason = context.user_data.get('repair_reason')
    repair_person = context.user_data.get('repair_person')
    is_warranty = context.user_data.get('is_warranty')
    price = context.user_data.get('warranty_amount', 0.0)
    estimated_completion_date = context.user_data['estimated_completion_date']
    current_date = datetime.now().strftime("%d.%m.%Y")

    if not booking_id:
        await update.message.reply_text("🚫 Ошибка сессии: не найден ID бронирования.")
        return ConversationHandler.END

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            await conn.execute("BEGIN")

            # 1. Получаем все необходимые данные одним запросом
            cursor = await conn.execute(
                "SELECT b.user_id, b.bike_id, u.first_name, u.last_name, u.phone_number, bk.name as bike_name "
                "FROM bookings b "
                "JOIN users u ON b.user_id = u.id "
                "JOIN bikes bk ON b.bike_id = bk.id "
                "WHERE b.id=?",
                (booking_id,)
            )
            data = await cursor.fetchone()
            if not data: raise ValueError("Не удалось найти данные для обработки ремонта.")
            user_id, bike_id, first_name, last_name, phone_number, bike_name = data

            # 2. Удаляем старую аренду
            await conn.execute("DELETE FROM bookings WHERE id=?", (booking_id,))

            # 3. Создаем заявку на ремонт
            repair_status = 'completed' if not is_warranty and price > 0 else 'oplacheno'
            completed_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            cursor = await conn.execute(
                "INSERT INTO repair_requests (user_id, bike_id, description, status, estimated_price, is_warranty, completed_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (user_id, bike_id, reason, repair_status, price, 1 if is_warranty else 0, completed_at)
            )
            request_id = cursor.lastrowid

            # 4. Обновляем статус велосипеда и логируем
            await conn.execute("UPDATE bikes SET available=0, repair_status='in_repair', repair_reason=? WHERE id=?", (reason, bike_id))
            await log_bike_action(conn, bike_id, user_id, "Отправка в ремонт (с возврата)", f"Причина: {reason}", price)
            await conn.commit()

        # 5. Уведомление для администратора с ФИО
        user_display_name = f"{first_name} {last_name}".strip() if first_name else f"ID: {user_id}"
        admin_msg = (
            f"🔧 Велосипед '{bike_name}' отправлен в ремонт\n"
            f"👤 Пользователь: {user_display_name}\n"
            f"👷 Мастер: {repair_person}\n"
            f"📝 Причина: {reason}\n"
            f"📅 Дата начала: {current_date}\n"
            f"📅 Предполагаемое завершение: {estimated_completion_date}\n"
            f"{'💰 Гарантийный ремонт' if is_warranty else f'💰 Негарантийный ремонт, сумма: {price:.2f} ₽'}"
        )
        await update.message.reply_text(admin_msg)

        # 6. Уведомления и счет для клиента
        if not is_warranty and price > 0:
            # Сначала информационное сообщение
            user_info_message = (
                f"🛠️ *Информация по ремонту вашего велосипеда «{bike_name}»*\n\n"
                f"**Причина:** {reason}\n"
                f"**Стоимость ремонта:** {price:.2f} ₽\n\n"
                "Сейчас мы подготовим счет для оплаты."
            )
            await context.bot.send_message(user_id, user_info_message, parse_mode="Markdown")

            # Теперь выставляем счет
            if not phone_number:
                await context.bot.send_message(admin_chat_id, f"⚠️ Не удалось выставить счет пользователю {user_display_name} (нет номера телефона).")
            else:
                description = f"Оплата ремонта '{bike_name}' (заявка #{request_id})"
                payload = f"repair_payment_{request_id}"
                metadata = {'internal_payload': payload, 'user_id': user_id}
                items = [{"description": description, "quantity": "1.00", "amount": {"value": f"{price:.2f}", "currency": "RUB"}, "vat_code": "1"}]
                customer = {"phone": phone_number}

                payment_info = await create_yookassa_payment(price, description, metadata, items, customer, 'sbp')
                if not payment_info:
                    await context.bot.send_message(admin_chat_id, f"⚠️ Ошибка создания платежа для заявки #{request_id}.")
                else:
                    payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']
                    keyboard = [[InlineKeyboardButton("💳 Оплатить", url=payment_url)]]

                    animated_message = await context.bot.send_message(
                        user_id,
                        f"Нажмите кнопку для оплаты {final_amount:.2f} ₽",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )

                    if 'pending_payments' not in context.bot_data: context.bot_data['pending_payments'] = {}
                    stop_animation_event = asyncio.Event()
                    context.bot_data['pending_payments'][payment_id] = {'user_id': user_id, 'start_time': datetime.now(),'payload': payload, 'amount': final_amount, 'animated_message_id': animated_message.message_id, 'url': payment_url, 'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 'stop_animation_event': stop_animation_event}
                    asyncio.create_task(animate_payment_message(context, payment_id))
                    context.job_queue.run_repeating(callback=check_payment_status, interval=15, first=10, name=f"payment_{payment_id}", data={'yookassa_id': payment_id})

                    await context.bot.send_message(admin_chat_id, f"✅ Счет на {final_amount:.2f} ₽ отправлен клиенту.")
        else: # Гарантийный ремонт
            user_info_message = (
                f"🛠️ *Информация по ремонту вашего велосипеда «{bike_name}»*\n\n"
                f"**Причина:** {reason}\n"
                f"**Статус:** Гарантийный ремонт\n\n"
                "Оплата не требуется. Мы сообщим, когда велосипед будет готов."
            )
            await context.bot.send_message(user_id, user_info_message, parse_mode="Markdown")

    except Exception as e:
        logger.error(f"Ошибка при обработке возврата в ремонт: {e}", exc_info=True)
        await update.message.reply_text(f"❌ Произошла критическая ошибка: {e}")
    finally:
        context.user_data.clear()
        return ConversationHandler.END

async def cancel_repair(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    if query:
        await query.answer()
        await query.edit_message_text("❌ Операция отменена")
    else:
        await update.message.reply_text("❌ Операция отменена")
    return ConversationHandler.END

async def start(update: Update, context) -> None:
    user_id = update.message.from_user.id

    # Проверяем, зарегистрирован ли пользователь
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*), passport_photo FROM users WHERE id=?", (user_id,))
    result = cursor.fetchone()
    is_registered = result[0] > 0
    passport_photo = result[1] if result else None
    conn.close()

    # Если пользователь — мастер
    if user_id ==  835886969:
        if not context.user_data.get('first_time_user'):
            # Приветствие для мастера при первом входе
            await update.message.reply_sticker("CAACAgIAAxkBAAELJLhnafG1kLqQn-ZhJw844LdDmRAbswACZSAAAoF_KUrc8uTuPScLhTYE")
            await update.message.reply_text(
                "🔧 Привет, мастер! Добро пожаловать в систему управления ремонтами.\n\n"
                "Здесь вы можете:\n"
                "   - 🛠️ Просматривать заявки на ремонт\n"
                "   - 🔧 Выполнять ремонтные работы\n\n"
                "Выберите действие из меню ниже:",
                reply_markup=get_main_menu(user_id)
            )
            context.user_data['first_time_user'] = True
        else:
            # Повторный вход мастера
            await update.message.reply_sticker("CAACAgIAAxkBAAELJLhnafG1kLqQn-ZhJw844LdDmRAbswACZSAAAoF_KUrc8uTuPScLhTYE")
            await update.message.reply_text(
                "🔧 Привет, мастер! Выберите действие из меню ниже:",
                reply_markup=get_main_menu(user_id)
            )
        return  # Завершаем выполнение функции для мастера

    # Проверяем, первый ли раз пользователь заходит в бота
    if not context.user_data.get('first_time_user'):
        if is_admin(user_id):
            # Отправляем стикер и краткое сообщение для админа
            await update.message.reply_sticker("CAACAgIAAxkBAAELJLhnafG1kLqQn-ZhJw844LdDmRAbswACZSAAAoF_KUrc8uTuPScLhTYE")
            await update.message.reply_text(
                "Привет! 👋 Выберите действие из меню ниже.",
                reply_markup=get_main_menu(user_id)
            )
            context.user_data['first_time_user'] = True
        else:
            # Оригинальное приветствие для обычных пользователей
            await update.message.reply_text(
                "🌟 *Добро пожаловать в бота для аренды электровелосипедов!* 🌟\n\n"
                "🚴‍♂️ Мы рады, что вы выбрали нас! Здесь вы найдете все, что нужно для удобной и комфортной аренды электровелосипедов.\n\n"
                "✨ *Что можно делать в боте?*\n"
                "   - 🗓️ *Бронировать и арендовать* электровелосипеды в несколько кликов.\n"
                "   - 👤 *Личный кабинет*: управляйте своими арендами, просматривайте историю и статусы.\n"
                "   - 🛠️ *Заявки на ремонт*: быстро сообщайте о проблемах и отслеживайте их статус.\n"
                "   - 💳 *Оплата*: удобные способы оплаты аренды и ремонтов.\n"
                "   - 📊 *Контроль и учет*: прозрачные тарифы и детализация всех операций.\n"
                "📝 *Чтобы пользоваться всеми функциями, необходимо зарегистрироваться.*\n"
                "📄 *Для аренды электровелосипеда через бота необходимо подтвердить свою личность.*\n"
                "   - Вы можете сделать это через бота, отправив фотографию паспорта.\n"
                "   - Или лично по адресу: *ул. Салтыковская, д. 53*.\n\n"
                "💬 *Все вопросы можно задать в поддержку или лично @BFbike*\n\n"
                "🐱 *Мы знаем, как работают курьеры, и готовы предоставить лучшие условия:*\n"
                "   - Удобные тарифы и гибкие условия аренды.\n"
                "   - Все просто, супер и комфортно!\n\n"
                "👇 *Чтобы зарегистрироваться, нажмите '📝 Зарегистрироваться ' *",
                parse_mode="Markdown",
                reply_markup=get_main_menu(user_id)
            )
            await update.message.reply_sticker("CAACAgIAAxkBAAELvTpnjFi9lrKfoO35DH4g2hrLVE6raAACuyAAAgUQIEuQBtrjrbLKljYE")
            context.user_data['first_time_user'] = True
    else:
        # Логика для повторных входов
        if not is_registered and not is_admin(user_id):
            await update.message.reply_sticker("CAACAgIAAxkBAAELvTRnjFROmx-PvTO_EcbJ5aW7KkY3twACViEAAtTlIErBD_uZckfSpzYE")
            await update.message.reply_text(
                "🌟 Привет! Советуем зарегистрироваться! Так вам будет доступно больше функций. 🌟\n\n"
                "Выберите действие из меню ниже:",
                reply_markup=get_main_menu(user_id)
            )
        else:
            if not passport_photo and not is_admin(user_id):
                await update.message.reply_sticker("CAACAgIAAxkBAAELvTRnjFROmx-PvTO_EcbJ5aW7KkY3twACViEAAtTlIErBD_uZckfSpzYE")
                await update.message.reply_text(
                    "🌟 Привет! Советуем подтвердить свою личность! Так вы сможете арендовать электровелосипед прямо в боте. 🌟\n\n"
                    "🐱 Выберите действие из меню ниже:",
                    reply_markup=get_main_menu(user_id)
                )
            else:
                # Стандартное приветствие для зарегистрированных или админов
                await update.message.reply_sticker("CAACAgIAAxkBAAELJLhnafG1kLqQn-ZhJw844LdDmRAbswACZSAAAoF_KUrc8uTuPScLhTYE")
                await update.message.reply_text(
                    "Привет! 👋 Выберите действие из меню ниже.",
                    reply_markup=get_main_menu(user_id)
                )



    # Сохраняем конфигурацию в user_data
    context.user_data['config'] = config

async def send_news(update: Update, context) -> int:
    user_id = update.message.from_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 У вас нет прав для отправки новостей.")
        return ConversationHandler.END

    await update.message.reply_text("Введите текст новости, которую хотите рассылать (или отправьте фото):")
    return 1  # Переход к следующему шагу (ввод текста новости или загрузка фото)

async def broadcast_news(update: Update, context) -> int:
    news_message = update.message.caption or update.message.text  # Получаем текст из сообщения

    # Получаем всех пользователей
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id FROM users")
    users = cursor.fetchall()
    conn.close()

    for user in users:
        user_id = user[0]
        try:
            # Если сообщение является фотографией
            if update.message.photo:
                photo = update.message.photo[-1].file_id  # Получаем последнее фото
                await context.bot.send_photo(chat_id=user_id, photo=photo, caption=news_message)
            else:
                # Если это текстовое сообщение
                await context.bot.send_message(chat_id=user_id, text=news_message)
        except Exception as e:
            logger.error(f"Не удалось отправить сообщение пользователю {user_id}: {e}")

    await update.message.reply_text("✅ Новость успешно разослана всем пользователям!")
    return ConversationHandler.END
from datetime import datetime

import sqlite3
import logging
from datetime import datetime, timedelta
import pytz
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
async def check_rental_reminders(context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Ежедневно проверяет активные аренды:
    - Уведомляет за 3 дня до окончания
    - Сообщает о просроченных арендах
    - Логирует все действия в историю
    """
    logging.info("🔄 ЗАПУСК ПРОВЕРКИ АРЕНД ===================================")

    def get_day_suffix(days: int) -> str:
        """Возвращает правильную форму слова 'день' для русского языка."""
        if days % 10 == 1 and days % 100 != 11:
            return "день"
        elif 2 <= days % 10 <= 4 and (days % 100 < 10 or days % 100 >= 20):
            return "дня"
        return "дней"

    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        logging.info("🔎 Поиск активных аренд...")
        cursor.execute("SELECT id, user_id, end_date, bike_id FROM bookings WHERE status = 'rented'")
        active_rentals = cursor.fetchall()
        logging.info(f"📊 Найдено активных аренд: {len(active_rentals)}")

        soon_expired = 0
        overdue_rentals = 0
        notifications_sent = 0

        for booking_id, user_id, end_date_str, bike_id in active_rentals:
            try:
                logging.info(f"\n🔍 Обработка аренды #{booking_id}:")
                logging.info(f"   👤 Пользователь: {user_id}")
                logging.info(f"   🚲 Велосипед ID: {bike_id}")
                logging.info(f"   📅 Дата окончания: {end_date_str}")

                end_date = datetime.strptime(end_date_str, "%d.%m.%Y").date()
                now_date = datetime.now().date()
                days_remaining = (end_date - now_date).days

                message = None
                log_action = None
                log_details = None

                # Уведомление за 3 дня
                if 0 <= days_remaining <= 3:
                    soon_expired += 1
                    time_left = f"{days_remaining} {get_day_suffix(days_remaining)}" if days_remaining != 0 else "сегодня"

                    message = (
                        f"Внимание!\n"
                        f"До окончания аренды осталось: {time_left}!\n"
                        "Пожалуйста, продлевайте или сдавайте велосипед вовремя."
                    )
                    log_action = "Напоминалка"
                    log_details = f"Напоминание что до конца аренды {time_left}"

                # Просроченная аренда
                elif days_remaining < 0:
                    overdue_rentals += 1
                    overdue_days = -days_remaining
                    time_overdue = f"{overdue_days} {get_day_suffix(overdue_days)}"

                    message = (
                        f"🚨СРОЧНО!\n"
                        f"🚨Просрочка на {time_overdue}!\n"
                        "🚨Немедленно свяжитесь с администратором!"
                    )
                    log_action = "Просрочка"
                    log_details = f"🚨🚨🚨Просрочка {time_overdue}"

                else:
                    logging.info("   ✅ Аренда активна (уведомление не требуется)")
                    continue

                # Отправка уведомления и логирование
                if message:
                    try:
                        await context.bot.send_message(
                            chat_id=user_id,
                            text=message
                        )
                        notifications_sent += 1
                        logging.info(f"   📨 Уведомление отправлено пользователю {user_id}")

                        # Логируем действие в историю
                        log_bike_action(
                            bike_id=bike_id,
                            user_id=user_id,
                            action=log_action,
                            details=log_details
                        )
                        logging.info(f"   📝 Запись в истории: {log_action} - {log_details}")

                    except Exception as e:
                        logging.error(f"   ❌ Ошибка отправки: {str(e)}")

            except Exception as e:
                logging.error(f"❌ Ошибка обработки аренды #{booking_id}: {str(e)}")

        # Итоговое логирование
        logging.info("\n📊 ИТОГИ ПРОВЕРКИ:")
        logging.info(f"• Всего аренд: {len(active_rentals)}")
        logging.info(f"• Скоро заканчиваются (3 дня): {soon_expired}")
        logging.info(f"• Просроченных: {overdue_rentals}")
        logging.info(f"• Отправлено уведомлений: {notifications_sent}")
        logging.info("✅ ПРОВЕРКА ЗАВЕРШЕНА ================================\n")

        conn.close()
    except Exception as e:
        logging.error(f"⛔️ КРИТИЧЕСКАЯ ОШИБКА: {str(e)}")
        raise

import sqlite3
import logging
from datetime import datetime, timedelta
import pytz
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ

# ### НОВАЯ, ПОЛНОСТЬЮ ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
# ### НОВАЯ, ПОЛНОСТЬЮ ИСПРАВЛЕННАЯ ФУНКЦИЯ manage_bike ###

async def manage_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Основная функция для управления велосипедами и АКБ.
    - Корректно отображает информацию по всем типам товаров.
    - Формирует одну общую кнопку "Сдать товар".
    """
    try:
        # Определяем, откуда пришел вызов (сообщение или кнопка)
        user = update.effective_user
        if not user or user.is_bot: return

        user_id = user.id

        # Отправляем стикер один раз в начале
        if update.message: # Только если это первое открытие по кнопке из меню
            await context.bot.send_sticker(chat_id=user_id, sticker="CAACAgIAAxkBAAELWEpneCDwY-TzVoqeqlYgjWiuxTNZbwAC6BwAAvyDKUoY8WDBCRptzzYE")

        info_parts = []
        keyboard_buttons = []
        has_active_items = False # Флаг наличия активных товаров

        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row

            # Сначала ищем товары в собственности пользователя
            cursor = await conn.execute("SELECT name FROM bikes WHERE owner_id = ?", (user_id,))
            owned_items = await cursor.fetchall()

            for (item_name,) in owned_items:
                info_parts.append(
                    f"🎉 *Ваш собственный товар «{escape_markdown(item_name, version=2)}»*\n"
                    f"   └ Наслаждайтесь, он ВАШ\\!"
                )

            # Ищем активные аренды и рассрочки
            cursor = await conn.execute("""
                SELECT
                    b.id, b.bike_id, bi.name, bi.type as item_type,
                    b.booking_type, b.booking_date, b.end_date,
                    b.payment_plan_key, b.payments_made, b.next_payment_date
                FROM bookings b
                JOIN bikes bi ON b.bike_id = bi.id
                WHERE b.user_id = ? AND b.status = 'rented'
            """, (user_id,))
            active_items = await cursor.fetchall()

        if not active_items and not owned_items:
            await context.bot.send_message(
                chat_id=user_id,
                text="🌟 *Добро пожаловать в управление товарами\\!* 🌟\n\n🚫 У вас нет активных аренд или товаров в собственности\\.",
                parse_mode="MarkdownV2"
            )
            return

        # Если есть хотя бы один активный товар, устанавливаем флаг
        if active_items:
            has_active_items = True

        for item in active_items:
            (booking_id, bike_id, item_name, item_type, booking_type,
             booking_date, end_date, plan_key, payments_made, next_payment_date) = item

            if booking_type == 'buyout':
                plan = None
                total_payments = 0
                plan_label = "Неизвестный план"

                if item_type == PRODUCT_TYPE_BIKE:
                    if plan_key in BUYOUT_PLANS:
                        plan = BUYOUT_PLANS[plan_key]
                        total_payments = plan.get('total_payments', 0)
                        plan_label = plan.get('full_label', plan_label)

                elif item_type == PRODUCT_TYPE_BATTERY:
                    battery_model = '60V21Ah' if '60V21Ah' in item_name else '60V30Ah'
                    if battery_model in BATTERY_BUYOUT_PLANS and plan_key in BATTERY_BUYOUT_PLANS[battery_model]['plans']:
                        plan = BATTERY_BUYOUT_PLANS[battery_model]['plans'][plan_key]
                        total_payments = plan.get('count', 0)
                        plan_label = plan.get('label', plan_label)

                if plan:
                    info_parts.append(
                        f"💰 *Рассрочка на «{escape_markdown(item_name, version=2)}»*\n"
                        f"   \\- План: *{escape_markdown(plan_label, version=2)}*\n"
                        f"   \\- Внесено платежей: *{payments_made} из {total_payments}*\n"
                        f"   \\- Следующий платеж до: *{escape_markdown(str(next_payment_date), version=2)}*"
                    )
                    keyboard_buttons.append([InlineKeyboardButton(f"💳 Оплатить след. платеж ({item_name[:15]})", callback_data=f"pay_next_{booking_id}")])
                    keyboard_buttons.append([InlineKeyboardButton(f"💵 Погасить досрочно ({item_name[:15]})", callback_data=f"pay_full_{booking_id}")])
                else:
                    info_parts.append(f"⚠️ Ошибка: не найден план рассрочки для «{escape_markdown(item_name, version=2)}»\\.")

            elif booking_type == 'rent':
                try:
                    status_text = ""
                    if end_date:
                        end_date_obj = datetime.strptime(end_date, "%d.%m.%Y")
                        remaining_days = (end_date_obj.date() - datetime.now(MOSCOW_TZ).date()).days
                        status_text = f"🚨 *ПРОСРОЧЕНО ДНЕЙ: {-remaining_days}*" if remaining_days < 0 else f"⏳ *Осталось дней: {remaining_days}*"

                    emoji = "🚲" if item_type == PRODUCT_TYPE_BIKE else "🔋"
                    info_parts.append(
                        f"{emoji} *Аренда «{escape_markdown(item_name, version=2)}»*\n"
                        f"   \\- {status_text}"
                    )
                    keyboard_buttons.append([InlineKeyboardButton(f"Продлить аренду ({item_name[:15]})", callback_data=f"prolong_rental_{booking_id}")])
                except (ValueError, TypeError):
                    info_parts.append(f"⚠️ Ошибка данных для аренды «{escape_markdown(item_name, version=2)}»\\.")

        # ### НОВЫЙ КОД: Добавляем одну общую кнопку "Сдать товар", если есть активные товары ###
        if has_active_items:
            # Добавляем разделитель для визуального отделения
            if keyboard_buttons:
                 keyboard_buttons.append([InlineKeyboardButton("─" * 20, callback_data="noop")])
            keyboard_buttons.append([InlineKeyboardButton("↩️ Сдать товар", callback_data="return_bike_start")])

        welcome_text = "🌟 *Добро пожаловать в управление вашими товарами\\!* 🌟\n\n"
        full_message_body = "\n\n".join(info_parts)
        final_message = welcome_text + full_message_body

        # Определяем, как отправить/отредактировать сообщение
        message_to_send = None
        if update.message:
            message_to_send = update.message
        elif update.callback_query:
            message_to_send = update.callback_query.message

        if message_to_send:
            await message_to_send.reply_text( # Используем reply_text для отправки нового сообщения
                text=final_message,
                parse_mode="MarkdownV2",
                reply_markup=InlineKeyboardMarkup(keyboard_buttons) if keyboard_buttons else None
            )

    except Exception as e:
        logging.error(f"Ошибка в manage_bike: {str(e)}", exc_info=True)
        chat_id_to_report = update.effective_chat.id if update and update.effective_chat else None
        if chat_id_to_report:
            await context.bot.send_message(
                chat_id=chat_id_to_report,
                text="❌ Произошла ошибка при загрузке данных. Попробуйте позже."
            )



async def fines_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Меню для управления штрафами.
    """
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id

    # Получаем штрафы пользователя
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, amount, created_at, status
            FROM fines
            WHERE user_id = ? AND status != 'paid'
            ORDER BY created_at DESC
        """, (user_id,))
        fines = cursor.fetchall()

    # Формируем клавиатуру с опциями
    keyboard = []

    # Кнопки для оплаты штрафов
    for fine in fines:
        fine_id, amount, _, _ = fine
        keyboard.append([InlineKeyboardButton(
            f"💳 Оплатить штраф #{fine_id} ({amount}₽)",
            callback_data=f"pay_fine_{fine_id}"
        )])

    # Дополнительные действия
    keyboard.append([InlineKeyboardButton("✋ Оспорить штраф", callback_data="dispute_fine")])
    # Отправляем меню штрафов
    await query.message.reply_text(
        "📝 Меню штрафов. Выберите действие:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

SELECT_FINE, UPLOAD_MEDIA, ENTER_DISPUTE_COMMENT = range(3)

async def start_dispute(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Начало процесса оспаривания штрафа"""
    query = update.callback_query
    await query.answer()  # Обязательно подтверждаем callback

    user_id = query.from_user.id  # Получаем user_id из callback_query

    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT id, amount, reason, created_at
            FROM fines
            WHERE user_id = ? AND status = 'unpaid'
        """, (user_id,))
        fines = cursor.fetchall()

    if not fines:
        await query.message.reply_text("❌ У вас нет штрафов для оспаривания")
        return ConversationHandler.END

    buttons = [
        InlineKeyboardButton(
            f"Штраф #{f[0]} - {f[1]}₽ ({f[3][:10]})",
            callback_data=f"dispute_{f[0]}"
        ) for f in fines
    ]

    await query.message.reply_text(  # Используем query.message вместо update.message
        "Выберите штраф для оспаривания:",
        reply_markup=InlineKeyboardMarkup([buttons])
    )
    return SELECT_FINE

async def select_fine_for_dispute(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка выбора штрафа"""
    query = update.callback_query
    await query.answer()

    fine_id = int(query.data.split("_")[1])
    context.user_data["dispute_fine_id"] = fine_id

    await query.edit_message_text(f"➡️ Выбран штраф ID: {fine_id}")
    await query.message.reply_text(
        "📎 Прикрепите фото/видео доказательства:\n"
        "(можно отправить как файл или фото)"
    )
    return UPLOAD_MEDIA

async def handle_dispute_media(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка медиа-доказательств"""
    user_id = update.message.from_user.id
    fine_id = context.user_data["dispute_fine_id"]

    # Сохраняем file_id медиа
    if update.message.photo:
        media_type = 'photo'
        file_id = update.message.photo[-1].file_id
    elif update.message.video:
        media_type = 'video'
        file_id = update.message.video.file_id
    else:
        await update.message.reply_text("❌ Пожалуйста, отправьте фото или видео")
        return UPLOAD_MEDIA

    # Сохраняем в БД
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        if media_type == 'photo':
            cursor.execute("UPDATE fines SET dispute_photo = ? WHERE id = ?", (file_id, fine_id))
        else:
            cursor.execute("UPDATE fines SET dispute_video = ? WHERE id = ?", (file_id, fine_id))
        conn.commit()

    await update.message.reply_text("📝 Напишите комментарий к оспариванию:")
    return ENTER_DISPUTE_COMMENT

async def save_dispute_comment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Сохранение комментария"""
    comment = update.message.text.strip()
    fine_id = context.user_data["dispute_fine_id"]

    if len(comment) < 10:
        await update.message.reply_text("❌ Комментарий должен содержать минимум 10 символов")
        return ENTER_DISPUTE_COMMENT

    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE fines SET
                dispute_comment = ?,
                dispute_status = 'pending',
                status = 'disputed'
            WHERE id = ?
        """, (comment, fine_id))
        conn.commit()

    # Отправляем подтверждение
    await update.message.reply_text(
        "✅ Заявка на оспаривание отправлена!\n"
        "Администратор рассмотрит её в течение 3 рабочих дней."
    )

    # Оповещаем администраторов
    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_message(
                chat_id=admin_id,
                text=f"🚨 Новая заявка на оспаривание штрафа #{fine_id}"
            )
        except Exception as e:
            logging.error(f"Ошибка оповещения администратора {admin_id}: {e}")

    context.user_data.clear()
    return ConversationHandler.END

from datetime import datetime

import sqlite3
import logging
from datetime import datetime, timedelta
import pytz
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
async def test_reminder(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    await update.message.reply_text("🔍 Ищу ваши активные аренды...")

    try:
        # 1. Получаем данные аренд из БД
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT b.id, b.end_date
            FROM bookings b
            WHERE b.user_id = ? AND b.status = 'rented'
            ORDER BY b.end_date DESC
        """, (user_id,))

        rentals = cursor.fetchall()
        conn.close()

        if not rentals:
            await update.message.reply_text("❌ Нет активных аренд для теста")
            return

        # 2. Берем последнюю аренду
        booking_id, end_date = rentals[0]

        # 3. Модифицируем расписание для теста
        async def setup_test_reminder(context: ContextTypes.DEFAULT_TYPE):
            job_name = f"TEST_AUTO_{user_id}_{booking_id}"

            # Очистка старых заданий
            current_jobs = context.job_queue.get_jobs_by_name(job_name)
            for job in current_jobs:
                job.schedule_removal()

            # Настройка тестового расписания
            context.job_queue.run_repeating(
                callback=send_reminder,
                interval=10,  # Интервал 10 секунд
                first=5,      # Первый запуск через 5 секунд
                name=job_name,
                data={
                    'user_id': user_id,
                    'booking_id': booking_id,
                    'end_date': end_date
                }
            )

        # 4. Запускаем тест
        await setup_test_reminder(context)
        await update.message.reply_text(
            f"🛠 Тест запущен!\n"
            f"• Аренда: #{booking_id}\n"
            f"• Дата окончания: {end_date}\n"
            f"Первое уведомление через 5 секунд..."
        )

    except Exception as e:
        logging.error(f"Test reminder error: {e}")
        await update.message.reply_text("⚠️ Ошибка при запуске теста")


async def schedule_reminder(context: ContextTypes.DEFAULT_TYPE, user_id: int,
                          booking_id: int, end_date_str: str):
    job_name = f"reminder_{user_id}_{booking_id}"

    # Удаляем предыдущие задания для этой аренды
    current_jobs = context.job_queue.get_jobs_by_name(job_name)
    for job in current_jobs:
        job.schedule_removal()

    # Настройка времени для Перми (UTC+5)
    tz = pytz.timezone('Asia/Yekaterinburg')
    now = datetime.now(tz)
    target_time = now.replace(hour=20, minute=0, second=0, microsecond=0)

    # Корректируем время первого запуска
    if now > target_time:
        target_time += timedelta(days=1)

    # Добавляем новое задание
    context.job_queue.run_repeating(
        callback=send_reminder,
        interval=timedelta(days=1),
        first=target_time,
        name=job_name,
        data={
            'user_id': user_id,
            'booking_id': booking_id,
            'end_date': end_date_str
        }
    )

# === НАЧАЛО БЛОКА 1 ===

# Определяем состояния для нового диалога
STATS_AWAIT_DATE_RANGE = range(990, 991)

async def start_detailed_report_date_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Запрашивает период для выбранного типа отчета."""
    query = update.callback_query
    await query.answer()

    # Сохраняем, какой именно отчет запросил пользователь
    context.user_data['report_info'] = query.data
    
    message_text = (
        "📅 *Отчет за период*\n\n"
        "Введите период в формате `ДД.ММ.ГГГГ-ДД.ММ.ГГГГ`\n"
        "Или используйте команды: `сегодня`, `неделя`, `месяц`."
    )
    
    await query.edit_message_text(message_text, parse_mode="Markdown")
    return STATS_AWAIT_DATE_RANGE

async def process_detailed_report_dates_and_generate(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Принимает даты, вызывает нужный генератор и отправляет отчет."""
    user_input = update.message.text.strip().lower()
    today = datetime.now()
    start_date, end_date = None, None

    try:
        if user_input == 'сегодня':
            start_date = end_date = today
        elif user_input == 'неделя':
            start_date = today - timedelta(days=today.weekday())
            end_date = today
        elif user_input == 'месяц':
            start_date = today.replace(day=1)
            end_date = today
        else:
            start_str, end_str = user_input.split('-')
            start_date = datetime.strptime(start_str.strip(), '%d.%m.%Y')
            end_date = datetime.strptime(end_str.strip(), '%d.%m.%Y')
    except (ValueError, IndexError):
        await update.message.reply_text("❌ Неверный формат. Попробуйте еще раз.")
        return STATS_AWAIT_DATE_RANGE

    status_message = await update.message.reply_text("⏳ Генерирую Excel-отчет, это может занять до минуты...")

    report_info = context.user_data.get('report_info', '')
    parts = report_info.split('_')
    report_type = parts[2]
    investor_id = int(parts[3]) if len(parts) > 3 and parts[3].isdigit() else None
    filename = None
    
    try:
        # Вызываем универсальный генератор с указанием дат
        if report_type == 'expenses':
             filename = generate_expense_report(start_date, end_date)
        else:
             filename = await generate_unified_report(
                 report_type=report_type, 
                 start_date=start_date, 
                 end_date=end_date, 
                 investor_id=investor_id
             )

        if filename and os.path.exists(filename):
            with open(filename, 'rb') as file:
                await context.bot.send_document(
                    chat_id=update.effective_chat.id,
                    document=file,
                    caption=f"✅ Ваш отчет за период с {start_date.strftime('%d.%m.%Y')} по {end_date.strftime('%d.%m.%Y')} готов."
                )
            os.remove(filename)
            await status_message.delete()
        else:
            await status_message.edit_text("😔 В этой категории нет данных для отчета за указанный период.")

    except Exception as e:
        logger.error(f"Ошибка при генерации отчета по датам: {e}", exc_info=True)
        await status_message.edit_text(f"❌ Произошла ошибка: {e}")

    context.user_data.clear()
    return ConversationHandler.END
async def send_reminder(context: ContextTypes.DEFAULT_TYPE):
    """
    Отправляет уведомление пользователю о скором окончании аренды.
    """
    job = context.job
    data = job.data
    user_id = data['user_id']
    booking_id = data['booking_id']
    end_date_str = data['end_date']
    conn = None

    try:
        # Подключаемся к базе данных
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Проверяем актуальность аренды
        cursor.execute("""
            SELECT status, end_date
            FROM bookings
            WHERE id = ? AND user_id = ?
        """, (booking_id, user_id))
        result = cursor.fetchone()

        if not result or result[0] != 'rented':
            logging.info(f"Аренда #{booking_id} неактивна или не найдена")
            return

        # Получаем дату окончания аренды
        end_date = datetime.strptime(end_date_str, "%d.%m.%Y").date()
        today = datetime.now().date()
        remaining_days = (end_date - today).days

        # Если аренда уже завершена
        if remaining_days < 0:
            logging.info(f"Аренда #{booking_id} завершена")
            job.schedule_removal()
            return

        # Если до окончания аренды 3 дня или меньше
        if 0 <= remaining_days <= 3:
            # Определяем правильное склонение для слова "день"
            if remaining_days == 1:
                days_text = "день"
            elif 2 <= remaining_days <= 4:
                days_text = "дня"
            else:
                days_text = "дней"

            # Экранируем все динамические части
            attention_escaped = escape_markdown("Внимание!", version=2)
            days_escaped = escape_markdown(str(remaining_days), version=2)
            days_text_escaped = escape_markdown(days_text, version=2)
            please_text = escape_markdown(
                "Пожалуйста, продлите аренду или подготовьтесь к возврату велосипеда.",
                version=2
            )
            manage_text = escape_markdown("Для доп информации нажмите: '🗓️ Управление велосипедом' ", version=2)

            # Формируем сообщение с экранированием и разметкой
            message = (
                f"⚠️ *{attention_escaped}* До конца аренды осталось\n"
                f"*{days_escaped}* {days_text_escaped}\\!\n\n"
                f"{please_text}\n"
                f"{manage_text}"
            )

            # Отправляем сообщение пользователю
            await context.bot.send_message(
                chat_id=user_id,
                text=message,
                parse_mode='MarkdownV2'
            )
            logging.info(f"Уведомление отправлено пользователю {user_id}")

    except Exception as e:
        logging.error(f"Ошибка отправки уведомления: {e}")
    finally:
        # Закрываем соединение с базой данных
        if conn:
            conn.close()


# Обработчик для отмены заявки на сдачу
async def cancel_return_request(update: Update, context) -> None:
    query = update.callback_query
    await query.answer()

    # Убираем флаг о поданной заявке на сдачу
    context.user_data['return_request_submitted'] = False

    # Сообщаем пользователю, что заявка отменена
    await query.edit_message_text("✅ Заявка на сдачу велосипеда отменена.")

    # Предлагаем пользователю снова выбрать действие
    keyboard = [
        [InlineKeyboardButton("Продлить аренду", callback_data=f"prolong_rental_{booking_id}")],
        [InlineKeyboardButton("Сдать велосипед", callback_data="return_bike")]
    ]
    await query.message.reply_text(
        "Что будете делать дальше? 🐱",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def handle_prolong_rental(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    # Получаем booking_id из callback_data
    booking_id = int(query.data.split("_")[2])

    # Сохраняем booking_id в context.user_data
    context.user_data['booking_id_for_extension'] = booking_id

    # Вызываем функцию request_extension
    await request_extension(update, context)

# ### НОВАЯ, УЛУЧШЕННАЯ ФУНКЦИЯ `return_bike` ###

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ return_bike НА ЭТУ

async def return_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Шаг 1: Запускается по общей кнопке "Сдать товар" и предлагает выбор.
    """
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Ищем все активные товары (и аренды, и рассрочки)
    cursor.execute("""
        SELECT b.id, bk.name, b.booking_type
        FROM bookings b JOIN bikes bk ON b.bike_id = bk.id
        WHERE b.user_id = ? AND b.status = 'rented'
    """, (user_id,))
    active_items = cursor.fetchall()
    conn.close()

    if not active_items:
        await query.message.edit_text("🚫 У вас нет активных товаров для сдачи.")
        return

    keyboard = []
    for booking_id, item_name, booking_type in active_items:
        type_label = "Аренда" if booking_type == 'rent' else "Рассрочка"
        label = f"{type_label}: {item_name}"
        # Кнопка для подтверждения возврата конкретного товара
        keyboard.append([InlineKeyboardButton(label, callback_data=f"confirm_return_{booking_id}")])

    keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="cancel_return")])

    # Редактируем сообщение, показывая список товаров для сдачи
    await query.message.edit_text(
        "Какой из ваших товаров вы хотите сдать?",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

# Замените вашу функцию confirm_return_item на эту
# main.py

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ confirm_return_item НА ЭТУ
# main.py

async def confirm_return_item(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Обрабатывает выбор конкретного товара для сдачи.
    ИСПРАВЛЕНИЕ: Отправляет админу уведомление с двумя кнопками: "Принять" и "В ремонт".
    """
    query = update.callback_query
    await query.answer()

    if query.data == "cancel_return":
        await query.edit_message_text("Действие отменено.")
        return

    user = query.from_user
    user_id = user.id
    booking_id = int(query.data.split('_')[-1])

    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        cursor = await conn.execute(
            # Получаем ID велосипеда вместе с его названием
            "SELECT b.name, b.id as bike_id FROM bikes b JOIN bookings bo ON b.id = bo.bike_id WHERE bo.id = ?",
            (booking_id,)
        )
        item_data = await cursor.fetchone()

        if not item_data:
            await query.message.edit_text("🚫 Ошибка: не удалось найти информацию по этой брони.")
            return

        item_name = item_data['name']
        bike_id = item_data['bike_id'] # Получаем ID самого велосипеда
        user_name_formatted = await get_user_info_for_notification(user_id, conn)

    await query.message.edit_text(
        f"✅ Ваш запрос на сдачу товара «*{item_name}*» принят.\n"
        "Пожалуйста, подойдите к месту, откуда вы брали товар, для технического осмотра.",
        parse_mode="Markdown"
    )

    # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
    # Создаем клавиатуру с двумя кнопками
    keyboard = [[
        InlineKeyboardButton("✅ Принять", callback_data=f"rental_accept_{booking_id}"),
        # Используем rental_repair, так как он уже запускает нужный диалог
        InlineKeyboardButton("🔧 В ремонт", callback_data=f"rental_repair_{booking_id}")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    notification_message = (
        f"🔙 Пользователь {user_name_formatted} сдает товар «{item_name}» (бронь #{booking_id}).\n\n"
        "Осмотрите товар и выберите действие:"
    )

    for admin_id in ADMIN_IDS:
        # Отправляем сообщение с новыми кнопками
        await context.bot.send_message(admin_id, notification_message, reply_markup=reply_markup)
    # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

    # Логируем именно факт подачи заявки
    await log_bike_action(conn, bike_id, user_id, "Заявка на возврат", f"Пользователь подал заявку на возврат товара '{item_name}' (бронь #{booking_id})")

# main.py

# ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ
async def admin_accept_return(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Обрабатывает нажатие админом кнопки "Принять и сделать доступным".
    Завершает аренду, освобождает товар, уведомляет пользователя и проверяет очередь.
    """
    query = update.callback_query
    await query.answer()

    booking_id = int(query.data.split('_')[-1])

    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        await conn.execute("BEGIN")

        try:
            cursor = await conn.execute("SELECT bike_id, user_id FROM bookings WHERE id=?", (booking_id,))
            booking_info = await cursor.fetchone()

            if not booking_info:
                await query.edit_message_text("🚫 Ошибка: эта аренда уже была завершена или отменена.")
                await conn.rollback()
                return

            bike_id, user_id = booking_info['bike_id'], booking_info['user_id']
            cursor = await conn.execute("SELECT name, type FROM bikes WHERE id=?", (bike_id,))
            item_info = await cursor.fetchone()
            item_name = item_info['name']
            item_type_rus = "Велосипед" if item_info['type'] == 'bike' else "Аккумулятор"

            # 1. Удаляем аренду/рассрочку
            await conn.execute("DELETE FROM bookings WHERE id=?", (booking_id,))
            # 2. Освобождаем товар
            await conn.execute("UPDATE bikes SET available=1, owner_id=NULL WHERE id=?", (bike_id,))
            # 3. Логируем действие
            await log_bike_action(conn, bike_id, user_id, "Возврат принят", f"Администратор принял товар '{item_name}'")

            # 4. Проверяем очередь (только для велосипедов)
            if item_info['type'] == 'bike':
                cursor = await conn.execute("SELECT user_id FROM queue ORDER BY created_at ASC LIMIT 1")
                next_in_queue = await cursor.fetchone()
                if next_in_queue:
                    next_user_id = next_in_queue['user_id']
                    await conn.execute("DELETE FROM queue WHERE user_id = ?", (next_user_id,))
                    await context.bot.send_message(
                        chat_id=next_user_id,
                        text=f"🎉 Хорошие новости! {item_type_rus}, который вы ждали, стал доступен! Вы можете его арендовать."
                    )

            # Сохраняем все изменения
            await conn.commit()

            # Уведомляем пользователя и администратора
            await context.bot.send_message(user_id, f"✅ Ваш возврат товара «{item_name}» успешно подтвержден. Спасибо!")
            await query.edit_message_text(f"✅ Возврат товара «{item_name}» от пользователя ID {user_id} подтвержден. Товар снова доступен.")

        except Exception as e:
            await conn.rollback()
            logger.error(f"Ошибка в admin_accept_return для booking_id {booking_id}: {e}", exc_info=True)
            await query.edit_message_text(f"❌ Произошла ошибка при обработке возврата: {e}")

# Не забудьте зарегистрировать новый обработчик `confirm_return_item` в `main()`
# application.add_handler(CallbackQueryHandler(confirm_return_item, pattern=r"^confirm_return_"))



def get_month_name(month_number):
    """Получает название месяца по его номеру."""
    months = [
        "января", "февраля", "марта", "апреля",
        "мая", "июня", "июля", "августа",
        "сентября", "октября", "ноября", "декабря"
    ]
    return months[month_number - 1]  # Индексируем с 0, поэтому -1


def create_calendar():
    """Создает календарь для следующих трех дней в формате дд месяц."""
    today = datetime.now()

    # Генерация трех следующих дней в нужном формате
    next_three_days = [(today + timedelta(days=i)) for i in range(3)]

    keyboard = [
        [InlineKeyboardButton(f"{day.day} {get_month_name(day.month)}", callback_data=f"select_date_{day.strftime('%Y-%m-%d')}")]
        for day in next_three_days
    ]

    return InlineKeyboardMarkup(keyboard)

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ


### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ, ЧТОБЫ УБЕДИТЬСЯ В ПРАВИЛЬНОСТИ ВЫЗОВА

async def calendar_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Обрабатывает выбор даты. Шаг 2: Выбор времени.
    """
    query = update.callback_query
    await query.answer()

    if not query.data.startswith('select_date_'):
        return SELECTING_DATE

    try:
        selected_date_str = query.data.split('_', 2)[2]
        selected_date = datetime.strptime(selected_date_str, '%Y-%m-%d')
        context.user_data['booking_date'] = selected_date

        # Редактируем сообщение, запрашивая время
        await query.message.edit_text(
            f"🗓️ Дата: *{selected_date.strftime('%d %B %Y')}*\n\n"
            f"🕒 *Выберите удобное время для визита:*",
            # ВЫЗЫВАЕМ ФУНКЦИЮ БЕЗ АРГУМЕНТОВ
            reply_markup=create_time_keyboard(),
            parse_mode="Markdown"
        )
        # Переходим в состояние ожидания выбора времени
        return SELECTING_TIME

    except (ValueError, IndexError) as e:
        logger.error(f"Ошибка в calendar_callback: {e} | data: {query.data}")
        await query.message.edit_text("🚫 Произошла ошибка при выборе даты. Пожалуйста, начните заново.")
        return ConversationHandler.END


# ЗАМЕНИТЕ ВСЕ ВЕРСИИ ЭТОЙ ФУНКЦИИ НА ЭТОТ КОД

def create_time_keyboard():
    """Создает клавиатуру с кнопками выбора времени с 13:00 до 22:00."""
    keyboard = []
    # Создаем кнопки для часов с 13:00 до 22:00
    for hour in range(13, 23):
        time_str = f"{hour}:00"
        # Каждая кнопка в своей строке, чтобы они были большими и удобными
        keyboard.append([InlineKeyboardButton(time_str, callback_data=f"select_time_{time_str}")])
    return InlineKeyboardMarkup(keyboard)
### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
async def time_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Обрабатывает выбор времени. Шаг 3: Финальное подтверждение.
    """
    query = update.callback_query
    await query.answer()

    # Проверяем, что нажата кнопка времени
    if not query.data.startswith('select_time_'):
        return 3

    try:
        # Извлекаем время из callback_data
        selected_time_str = query.data.split('_', 2)[2]
        context.user_data['booking_time'] = selected_time_str

        # Получаем дату из контекста
        booking_date = context.user_data.get('booking_date')
        if not booking_date:
            raise ValueError("Дата не найдена в контексте")

        # Формируем сообщение для подтверждения
        final_datetime_str = f"{booking_date.strftime('%d.%m.%Y')} в {selected_time_str}"

        await query.message.edit_text(
            f"✅ *Ваша заявка почти готова!*\n\n"
            f"Вы хотите забронировать велосипед на:\n"
            f"📅 *{final_datetime_str}*\n\n"
            f"Пожалуйста, подтвердите ваш выбор.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("✅ Подтвердить бронь", callback_data='accept_booking')],
                [InlineKeyboardButton("❌ Отменить", callback_data='reject_booking')]
            ]),
            parse_mode="Markdown"
        )
        # Остаемся в том же состоянии (3), но ждем уже `accept_booking` или `reject_booking`
        return CONFIRMING_BOOKING

    except (ValueError, IndexError) as e:
        logger.error(f"Ошибка в time_callback: {e} | data: {query.data}")
        await query.message.edit_text("🚫 Произошла ошибка при выборе времени. Пожалуйста, начните заново.")
        return ConversationHandler.END


# Обновление функции бронирования
# Функция для просмотра всех запчастей 🛠️
async def list_parts(update: Update, context) -> None:
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    # Выбираем только id, name и quantity
    cursor.execute("SELECT id, name, quantity FROM parts WHERE available=1")
    parts = cursor.fetchall()
    conn.close()

    if not parts:
        await update.message.reply_text("🚫 Запчасти пока не добавлены или отсутствуют.")
        return

    keyboard = []
    for part in parts:
        part_id, part_name, part_quantity = part
        # Изменяем текст на отображение только названия и количества запчасти
        keyboard.append([InlineKeyboardButton(f"{part_name} (Количество: {part_quantity})", callback_data=f"part_info_{part_id}")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("💼 Доступные запчасти:", reply_markup=reply_markup)

# Показ информации о запчасти 📄
async def part_info(update: Update, context) -> None:
    query = update.callback_query
    await query.answer()
    part_id = query.data.split("_")[2]

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    # Выбираем имя, описание и количество запчасти
    cursor.execute("SELECT name, description, photo_url, quantity FROM parts WHERE id=?", (part_id,))
    part = cursor.fetchone()
    conn.close()

    if part:
        name, description, photo_url, quantity = part
        # Формируем сообщение с количеством
        await query.message.reply_photo(
            photo=photo_url,
            caption=f"{name}\n\nОписание: {description or 'Нет описания'}\nКоличество: {quantity} шт."
        )
    else:
        await query.message.reply_text("🚫 Ошибка: запчасть не найдена.")

# ### НОВЫЙ КОД: Универсальная функция для получения информации о пользователе ###

async def get_user_info_for_notification(user_id: int, conn: aiosqlite.Connection) -> str:
    """
    Асинхронно получает и форматирует информацию о пользователе для уведомлений.
    Принимает ID пользователя и объект соединения с БД.
    """
    try:
        cursor = await conn.execute("SELECT first_name, last_name, username FROM users WHERE id=?", (user_id,))
        user_data = await cursor.fetchone()

        if user_data:
            first_name = user_data['first_name'] or ""
            last_name = user_data['last_name'] or ""
            username = user_data['username'] or "нет username"

            # Собираем полное имя, убирая лишние пробелы, если чего-то нет
            full_name = f"{first_name} {last_name}".strip()

            return f"{full_name} (@{username})"
        else:
            return f"ID: {user_id} (не найден в БД)"
    except Exception as e:
        logging.error(f"Ошибка при получении информации о пользователе {user_id}: {e}")
        return f"ID: {user_id} (ошибка БД)"

# Команда для просмотра всех велосипедов 🚴‍♂️
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

def get_user_queue_position(user_id):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем всех пользователей в очереди с их статусами
    cursor.execute("SELECT user_id, status FROM queue WHERE status IN ('pending', 'first_user') ORDER BY created_at")
    queue = cursor.fetchall()

    # Находим позицию и статус пользователя в очереди
    for idx, (queued_user_id, status) in enumerate(queue, start=1):
        if queued_user_id == user_id:
            conn.close()
            return {"position": idx, "status": status}  # Возвращаем позицию и статус

    conn.close()
    return {"position": -1, "status": None}  # Если пользователь не найден в очереди


async def handle_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    # Получаем номер страницы из callback_data
    page = int(query.data.split('_')[1])

    # Вызываем list_bikes с обновленным номером страницы
    await list_bikes(update, context, page=page)

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ list_bikes НА ЭТУ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ list_bikes НА ЭТУ

# corrected_code.py

# corrected_code.py

# corrected_code.py

# corrected_code.py

# corrected_code.py

# corrected_code.py

# corrected_code.py

# corrected_code.py

# corrected_code.py

# DEBUGGING VERSION

import logging # Убедитесь, что этот импорт есть в начале вашего файла

# Создаем логгер, чтобы сообщения были более заметными
logger = logging.getLogger(__name__)


# main.py

# main.py

# main.py

# main.py

# main.py
# <<< НАЧАЛО НОВОГО БЛОКА КОДА >>>

# НАХОДИТСЯ В РАЙОНЕ СТРОКИ 6176
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ show_filtered_bike_list НА ЭТУ ВЕРСИЮ
# ==============================================================================
# ФИНАЛЬНАЯ ВЕРСИЯ show_filtered_bike_list (с исправлением ошибки редактирования)
# ==============================================================================
async def show_filtered_bike_list(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Показывает список велосипедов со статусами.
    ИСПРАВЛЕНО: Корректно обрабатывает возврат из сообщения с фото, удаляя его
    и отправляя новое текстовое сообщение.
    """
    query = update.callback_query
    await query.answer()
    
    # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
    # Сохраняем chat_id и удаляем предыдущее сообщение (которое может быть фото)
    chat_id = query.message.chat_id
    try:
        await query.message.delete()
    except Exception as e:
        logger.warning(f"Не удалось удалить сообщение при возврате к списку: {e}")
    # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

    try:
        parts = query.data.split('_')
        category = parts[3]
        page = int(parts[4])
    except (IndexError, ValueError):
        logger.error(f"Ошибка парсинга callback_data в show_filtered_bike_list: {query.data}")
        await context.bot.send_message(chat_id, "🚫 Произошла ошибка.")
        return

    PAGE_SIZE = 5
    sql_where_clause = ""
    sql_params = ()
    title = ""

    if category == "own":
        sql_where_clause = "WHERE b.investor_id IS NULL"
        title = "🚲 Наши велосипеды"
    elif category == "investor":
        sql_where_clause = "WHERE b.investor_id IS NOT NULL"
        title = "💼 Инвесторские велосипеды"
    elif category == "all":
        sql_where_clause = ""
        title = "🌐 Все велосипеды"

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            count_cursor = await conn.execute(f"SELECT COUNT(b.id) FROM bikes b {sql_where_clause}", sql_params)
            total_items = (await count_cursor.fetchone())[0]
            total_pages = (total_items + PAGE_SIZE - 1) // PAGE_SIZE

            offset = page * PAGE_SIZE
            
            cursor = await conn.execute(
                f"""SELECT 
                       b.id, b.name, b.investor_id, b.repair_status,
                       u.first_name, u.last_name,
                       bo.booking_type
                   FROM bikes b
                   LEFT JOIN users u ON b.investor_id = u.id
                   LEFT JOIN bookings bo ON b.id = bo.bike_id AND bo.status = 'rented'
                   {sql_where_clause}
                   ORDER BY b.name
                   LIMIT ? OFFSET ?""",
                sql_params + (PAGE_SIZE, offset)
            )
            bikes = await cursor.fetchall()

    except Exception as e:
        logger.error(f"Ошибка БД в show_filtered_bike_list: {e}", exc_info=True)
        await context.bot.send_message(chat_id, "🚫 Ошибка базы данных.")
        return

    if not bikes and page == 0:
        await context.bot.send_message(
            chat_id,
            f"В категории «{title}» нет велосипедов.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Назад к выбору категории", callback_data="back_to_main_bike_list")]])
        )
        return

    keyboard = []
    for bike in bikes:
        status_emoji = "✅" 
        if bike['repair_status'] == 'in_repair':
            status_emoji = "🔧"
        elif bike['booking_type'] == 'buyout':
            status_emoji = "💰"
        elif bike['booking_type'] == 'rent':
            status_emoji = "🚴‍♂️"
        
        button_text = f"{status_emoji} {bike['name']}"

        if bike['investor_id']:
            investor_name = f"{bike['first_name'] or ''} {bike['last_name'] or ''}".strip()
            button_text += f" (Инвестор: {investor_name})"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"info_{bike['id']}")])

    pagination_row = []
    if page > 0:
        pagination_row.append(InlineKeyboardButton("⬅️", callback_data=f"list_bikes_category_{category}_{page - 1}"))
    if page < total_pages - 1:
        pagination_row.append(InlineKeyboardButton("➡️", callback_data=f"list_bikes_category_{category}_{page + 1}"))

    if pagination_row:
        keyboard.append(pagination_row)

    keyboard.append([InlineKeyboardButton("⬅️ Назад к выбору категории", callback_data="back_to_main_bike_list")])

    message_text = f"{title} (Стр. {page + 1}/{total_pages}):"
    
    # <<< ИЗМЕНЕНИЕ: Отправляем новое сообщение вместо редактирования >>>
    await context.bot.send_message(
        chat_id=chat_id,
        text=message_text,
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ list_bikes НА ЭТУ

async def list_bikes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    ОБНОВЛЕННАЯ ВЕРСИЯ:
    - Для админов показывает меню фильтрации.
    - Для пользователей ДИНАМИЧЕСКИ создает меню на основе категорий в БД.
    """
    user_id = update.effective_user.id

    if is_admin(user_id):
        # Логика для админа остается без изменений
        keyboard = [
            [InlineKeyboardButton("🚲 Наши велосипеды (не инвесторские)", callback_data="list_bikes_category_own_0")],
            [InlineKeyboardButton("💼 Инвесторские велосипеды", callback_data="list_bikes_category_investor_0")],
            [InlineKeyboardButton("🌐 Все велосипеды", callback_data="list_bikes_category_all_0")]
        ]
        message_text = "👇 Выберите, какие велосипеды показать:"
    else:
        # --- НОВАЯ ДИНАМИЧЕСКАЯ ЛОГИКА ДЛЯ КЛИЕНТОВ ---
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        
        # SQL-запрос, который извлекает первое слово из названия велосипеда
        # и группирует их, чтобы получить уникальные категории
        cursor.execute("""
            SELECT DISTINCT
                CASE
                    WHEN INSTR(name, ' ') > 0 THEN SUBSTR(name, 1, INSTR(name, ' ') - 1)
                    ELSE name
                END as category
            FROM bikes
            WHERE type = 'bike' AND available = 1
        """)
        
        categories = cursor.fetchall()
        conn.close()

        keyboard = []
        if not categories:
            message_text = "😔 К сожалению, сейчас нет доступных велосипедов для аренды."
        else:
            # Создаем кнопки на лету для каждой найденной категории
            for (category_name,) in categories:
                # Пропускаем "Дополнительный", чтобы он не создавал отдельную кнопку
                if 'дополнительный' in category_name.lower():
                    continue
                keyboard.append([
                    InlineKeyboardButton(f"🚲 {category_name}", callback_data=f"show_model_{category_name}_page_0")
                ])
            
            # Добавляем кнопку для АКБ отдельно и вручную
            keyboard.append([InlineKeyboardButton("🔋 Дополнительный АКБ", callback_data="show_model_AKB_page_0")])
            message_text = "👇 Выберите интересующую вас категорию:"

    reply_markup = InlineKeyboardMarkup(keyboard)

    # Отправка/редактирование сообщения (без изменений)
    if update.callback_query:
        await update.callback_query.edit_message_text(message_text, reply_markup=reply_markup)
    else:
        await update.message.reply_text(message_text, reply_markup=reply_markup)

# НАЙДИТЕ И ПОЛНОСТЬЮ ЗАМЕНИТЕ ФУНКЦИЮ list_bikes_by_model НА ЭТУ ВЕРСИЮ

# ==============================================================================
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ
# ==============================================================================
async def _get_deal_details_from_db(booking_id: int, conn: aiosqlite.Connection) -> dict | None:
    """
    ОБНОВЛЕННАЯ ВЕРСИЯ:
    - Теперь дополнительно извлекает индивидуальные цены на аренду (7, 14, 30 дней).
    - Остальная логика для выкупов сохранена.
    """
    logger.info(f"[ЛОГ] Запрос деталей для сделки #{booking_id}")
    conn.row_factory = aiosqlite.Row
    cursor = await conn.execute("""
        SELECT 
            b.id as booking_id, b.booking_type, b.end_date, b.next_payment_date,
            b.payments_made, b.payment_plan_key,
            bk.id as bike_id, bk.name as bike_name,
            bk.buyout_total_payments, bk.buyout_payment_amount, bk.buyout_period_days,
            
            -- <<< НАЧАЛО ИЗМЕНЕНИЙ: ДОБАВЛЕНЫ ЭТИ СТРОКИ >>>
            bk.rent_price_7d, bk.rent_price_14d, bk.rent_price_30d,
            -- <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

            u.id as user_id, u.first_name, u.last_name, u.username, u.phone_number
        FROM bookings b
        JOIN bikes bk ON b.bike_id = bk.id
        JOIN users u ON b.user_id = u.id
        WHERE b.id = ?
    """, (booking_id,))
    deal_data_raw = await cursor.fetchone()
    if not deal_data_raw:
        logger.error(f"[ЛОГ] Сделка #{booking_id} не найдена в БД.")
        return None

    deal_data = dict(deal_data_raw)
    logging.info(f"[ЛОГ] Сделка #{booking_id}: Сырые данные из БД: {deal_data}")

    if deal_data['booking_type'] == 'buyout':
        individual_plan_payments = deal_data.get('buyout_total_payments')
        logger.info(f"[ЛОГ] Сделка #{booking_id}: Проверка индивидуального плана из 'bikes'. Найдено платежей: {individual_plan_payments}")
        
        if not individual_plan_payments or individual_plan_payments <= 0:
            plan_key = deal_data.get('payment_plan_key')
            logger.warning(f"[ЛОГ] Сделка #{booking_id}: Индивидуальный план не настроен. Попытка найти стандартный план по ключу: '{plan_key}'")
            
            if plan_key and plan_key in BUYOUT_PLANS:
                plan = BUYOUT_PLANS[plan_key]
                deal_data['buyout_total_payments'] = plan.get('total_payments')
                deal_data['buyout_payment_amount'] = plan.get('first_payment')
                deal_data['buyout_period_days'] = plan.get('period_days')
                logger.info(f"[ЛОГ] Сделка #{booking_id}: Успешно применен стандартный план '{plan_key}'.")
            else:
                logger.error(f"[ЛОГ] Сделка #{booking_id}: КРИТИЧЕСКАЯ ОШИБКА! Не найден ни индивидуальный, ни стандартный план выкупа!")
        else:
            logger.info(f"[ЛОГ] Сделка #{booking_id}: Используется индивидуальный план, заданный для велосипеда в таблице 'bikes'.")

    return deal_data

async def list_bikes_by_model(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    - Корректно показывает и Kugoo, и Liming вместе при выборе категории "Kugoo".
    - Для категории "АКБ" всегда показывает "бесконечные" аккумуляторы,
      игнорируя их доступность.
    """
    query = update.callback_query
    await query.answer()

    # Парсим callback_data: show_model_Kugoo_page_0
    try:
        parts = query.data.split('_')
        model_name_key = parts[2]
        page = int(parts[4])
    except (IndexError, ValueError):
        logger.error(f"Ошибка парсинга callback_data в list_bikes_by_model: {query.data}")
        await query.edit_message_text("🚫 Произошла ошибка. Попробуйте снова.")
        return

    PAGE_SIZE = 6
    sql_query = ""
    sql_params = ()
    count_query = ""
    count_params = ()

    if model_name_key == "Kugoo":
        # Если выбрана общая категория, ищем и JL, и ESM
        sql_query = "SELECT id, name FROM bikes WHERE (name LIKE ? OR name LIKE ?) AND available = 1 ORDER BY name LIMIT ? OFFSET ?"
        sql_params = ('%JL%', '%ESM%', PAGE_SIZE, page * PAGE_SIZE)
        count_query = "SELECT COUNT(*) FROM bikes WHERE (name LIKE ? OR name LIKE ?) AND available = 1"
        count_params = ('%JL%', '%ESM%')

    # --- ИЗМЕНЕНИЕ ЗДЕСЬ: Логика для Дополнительных АКБ ---
    elif model_name_key == "AKB":
        # Мы больше не проверяем available=1.
        # Вместо этого мы ищем конкретные товары, помеченные как "бесконечные".
        # Это гарантирует, что они всегда будут отображаться в списке.
        search_pattern = "Дополнительный АКБ%"
        sql_query = "SELECT id, name FROM bikes WHERE name LIKE ? AND is_unlimited = 1 ORDER BY name"
        # Пагинация здесь не нужна, так как у нас всего два таких товара
        sql_params = (search_pattern,)
        count_query = "SELECT COUNT(*) FROM bikes WHERE name LIKE ? AND is_unlimited = 1"
        count_params = (search_pattern,)
    # --- КОНЕЦ ИЗМЕНЕНИЯ ---

    else: # Для Wenbox и других
        search_pattern = f"%{model_name_key}%"
        sql_query = "SELECT id, name FROM bikes WHERE name LIKE ? AND available = 1 ORDER BY name LIMIT ? OFFSET ?"
        sql_params = (search_pattern, PAGE_SIZE, page * PAGE_SIZE)
        count_query = "SELECT COUNT(*) FROM bikes WHERE name LIKE ? AND available = 1"
        count_params = (search_pattern,)

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            count_cursor = await conn.execute(count_query, count_params)
            total_items = (await count_cursor.fetchone())[0]
            total_pages = (total_items + PAGE_SIZE - 1) // PAGE_SIZE

            cursor = await conn.execute(sql_query, sql_params)
            available_bikes = await cursor.fetchall()
    except Exception as e:
        logger.error(f"Ошибка БД в list_bikes_by_model: {e}", exc_info=True)
        await query.edit_message_text("🚫 Произошла ошибка при доступе к базе данных.")
        return

    if not available_bikes:
        await query.edit_message_text(
            "🚫 К сожалению, в этой категории сейчас нет доступных товаров.",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Назад к категориям", callback_data="back_to_categories")]])
        )
        return

    keyboard = []
    for bike_id, bike_name in available_bikes:
        keyboard.append([InlineKeyboardButton(bike_name, callback_data=f"info_{bike_id}")])

    # Пагинация (для АКБ она не будет отображаться, так как total_pages будет <= 1)
    pagination_row = []
    if page > 0:
        pagination_row.append(InlineKeyboardButton("⬅️ Назад", callback_data=f"show_model_{model_name_key}_page_{page - 1}"))
    if page < total_pages - 1:
        pagination_row.append(InlineKeyboardButton("Вперед ➡️", callback_data=f"show_model_{model_name_key}_page_{page + 1}"))
    if pagination_row:
        keyboard.append(pagination_row)

    keyboard.append([InlineKeyboardButton("⬅️ Назад к категориям", callback_data="back_to_categories")])

    await query.edit_message_text(
        f"Выберите товар из доступных (Стр. {page + 1}/{total_pages}):",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )




async def handle_view_queue(update: Update, context) -> None:
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id  # ID текущего пользователя
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем текущую очередь (всех пользователей, включая first_user)
    cursor.execute("""
        SELECT q.user_id, q.created_at, q.status, u.first_name, u.last_name, u.username
        FROM queue q
        JOIN users u ON q.user_id = u.id
        ORDER BY q.created_at
    """)
    queue = cursor.fetchall()
    conn.close()

    if queue:
        # Общее количество человек в очереди
        total_users = len(queue)

        # Место текущего пользователя в очереди
        user_position = None
        queue_text = "👥 Очередь:\n"
        for idx, (queued_user_id, created_at, status, first_name, last_name, username) in enumerate(queue, start=1):
            # Формируем информацию о пользователе
            user_info = f"{last_name} {first_name}"
            if username:
                user_info += f" (@{username})"

            # Выделяем первого пользователя (если статус first_user)
            if status == 'first_user':
                queue_text += f"🥇 {idx}. {user_info} (первый в очереди)\n"
            else:
                queue_text += f"{idx}. {user_info}\n"

            # Проверяем, является ли текущий пользователь этим пользователем
            if queued_user_id == user_id:
                user_position = idx

        # Добавляем информацию о месте пользователя
        if user_position is not None:
            queue_text += f"\n📍 Вы на {user_position} месте."
        else:
            queue_text += "\n📍 Вы не в очереди."
    else:
        queue_text = "👥 Очередь пуста."

    await query.edit_message_text(queue_text)

from datetime import datetime
# DEBUG FUNCTION - REMOVE LATER
async def debug_bikes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Временная функция для проверки статуса велосипедов в БД."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Запрашиваем ВСЕХ монстров и колхозников, чтобы увидеть их статусы
    cursor.execute("SELECT id, name, available FROM bikes WHERE name LIKE 'Монстр%' OR name LIKE 'Колхозник%'")
    bikes = cursor.fetchall()
    conn.close()

    if not bikes:
        await update.message.reply_text("В базе данных не найдено записей для 'Монстр' или 'Колхозник'.")
        return

    message = "🔍 Отладочная информация:\n\n"
    for bike_id, name, available in bikes:
        status_emoji = "✅" if available == 1 else "❌"
        message += f"ID: {bike_id}, Имя: {name}, Доступен: {status_emoji}\n"

    # Отправляем сообщение частями, если оно слишком длинное
    for part in [message[i:i + 4000] for i in range(0, len(message), 4000)]:
        await update.message.reply_text(part)
async def handle_join_queue(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    user_name = f"{query.from_user.first_name}"  # Имя пользователя
    if query.from_user.last_name:  # Добавляем фамилию, если она есть
        user_name += f" {query.from_user.last_name}"
    if query.from_user.username:  # Добавляем @username, если он есть
        user_name += f" (@{query.from_user.username})"

    conn = None
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Проверяем, есть ли пользователь уже в очереди
        cursor.execute("SELECT * FROM queue WHERE user_id = ?", (user_id,))
        if cursor.fetchone():
            await query.edit_message_text("🚫 Вы уже в очереди.")
            return

        # Получаем текущее время в правильном формате
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Проверяем, пуста ли очередь
        cursor.execute("SELECT COUNT(*) FROM queue WHERE status = 'first_user'")
        first_user_count = cursor.fetchone()[0]

        if first_user_count == 0:
            # Если нет пользователя со статусом first_user, текущий пользователь становится первым
            cursor.execute(
                "INSERT INTO queue (user_id, status, created_at) VALUES (?, 'first_user', ?)",
                (user_id, current_time)
            )
            conn.commit()
            await query.edit_message_text("🎉 Вы первый в очереди! Как только появится свободный велосипед, вы сможете его арендовать.")

            # Уведомление администраторам
            notification_message = (
                f"📝 Пользователь {user_name} встал в очередь.\n"
                f"Место в очереди: 1"
            )
            for admin_id in ADMIN_IDS:
                await context.bot.send_message(admin_id, notification_message)
                add_notification(notification_message)  # Добавляем уведомление в базу данных

        else:
            # Если в очереди есть first_user, добавляем пользователя с статусом pending
            cursor.execute(
                "INSERT INTO queue (user_id, status, created_at) VALUES (?, 'pending', ?)",
                (user_id, current_time)
            )
            conn.commit()

            # Получаем текущее место в очереди
            cursor.execute("""
                SELECT COUNT(*)
                FROM queue
                WHERE created_at <= (SELECT created_at FROM queue WHERE user_id = ?)
            """, (user_id,))
            position = cursor.fetchone()[0]

            await query.edit_message_text(f"✅ Вы добавлены в очередь. Ваше текущее место: {position}. Мы уведомим вас, когда появится свободный велосипед.")

            # Уведомление администраторам
            notification_message = (
                f"📝 Пользователь {user_name} встал в очередь.\n"
                f"Место в очереди: {position}"
            )
            for admin_id in ADMIN_IDS:
                await context.bot.send_message(admin_id, notification_message)
                add_notification(notification_message)  # Добавляем уведомление в базу данных

    except sqlite3.Error as e:
        # Логируем ошибку и уведомляем пользователя
        print(f"Ошибка при работе с базой данных: {e}")
        await query.edit_message_text("🚫 Произошла ошибка при добавлении в очередь. Пожалуйста, попробуйте позже.")
    finally:
        if conn:
            conn.close()

# Добавьте обработчик в диспетчер



async def join_queue(update: Update, context) -> None:
    user_id = update.message.from_user.id
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Проверяем, есть ли пользователь уже в очереди
    cursor.execute("SELECT * FROM queue WHERE user_id = ?", (user_id,))
    if cursor.fetchone():
        await update.message.reply_text("🚫 Вы уже в очереди.")
        conn.close()
        return

    # Добавляем пользователя в очередь
    cursor.execute("INSERT INTO queue (user_id, status) VALUES (?, 'pending')", (user_id,))
    conn.commit()
    conn.close()

    await update.message.reply_text("✅ Вы добавлены в очередь. Мы уведомим вас, когда появится свободный велосипед.")




import sqlite3
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.helpers import escape_markdown
from telegram.ext import CallbackContext

import sqlite3
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.helpers import escape_markdown
from telegram.ext import CallbackContext
import sqlite3
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.helpers import escape_markdown
from telegram.ext import CallbackContext

# ### ИЗМЕНЕНИЕ ### Логика отображения информации о велосипеде
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ bike_info НА ЭТУ НОВУЮ ВЕРСИЮ

# ЗАМЕНИТЕ СУЩЕСТВУЮЩУЮ ФУНКЦИЮ bike_info НА ЭТУ УЛУЧШЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ bike_info НА ЭТУ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ bike_info НА ЭТУ ПОЛНУЮ ВЕРСИЮ

# Убедитесь, что эти импорты есть в начале вашего файла
import aiosqlite
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown

# Убедитесь, что все эти импорты есть в начале вашего файла
import aiosqlite
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown

# --- ПОЛНАЯ, УНИВЕРСАЛЬНАЯ И ИСПРАВЛЕННАЯ ФУНКЦИЯ ---

# ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ bike_info НА ЭТУ

# ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ bike_info НА ЭТУ

# Убедитесь, что эти импорты есть в начале вашего файла
import logging
import telegram # нужен для обработки исключений
import aiosqlite
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# ... (остальные ваши импорты и константы, включая ADMIN_IDS, RENTAL_PRICES, get_bike_model_key и т.д.)

#logger = logging.getLogger(__name__) # Убедитесь, что логгер определен

# ==============================================================================
# ФИНАЛЬНАЯ ВЕРСИЯ ФУНКЦИИ bike_info (ЗАМЕНИТЕ СТАРУЮ)
# ==============================================================================

# ==============================================================================
# ФИНАЛЬНАЯ ВЕРСИЯ ФУНКЦИИ bike_info (с исправлениями)
# ==============================================================================
async def bike_info(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    ОКОНЧАТЕЛЬНАЯ ВЕРСИЯ:
    - Для обычных велосипедов отправляет ФОТО с подписью и тарифами.
    - Для аккумуляторов отправляет ТЕКСТОВОЕ СООБЩЕНИЕ с кнопками аренды/выкупа.
    """
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    # Навигация (остается без изменений)
    if query.data == "back_to_categories":
        await list_bikes(update, context)
        return
    if query.data.startswith("show_model_"):
        await list_bikes_by_model(update, context)
        return
    if query.data.startswith("list_bikes_category_"):
        await show_filtered_bike_list(update, context)
        return

    bike_id = int(query.data.split("_")[1])
    try:
        # Пытаемся удалить предыдущее сообщение, чтобы интерфейс был чище
        await query.message.delete()
    except Exception:
        pass # Игнорируем ошибку, если сообщение уже удалено или слишком старое

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute("SELECT * FROM bikes WHERE id=?", (bike_id,))
            bike_data = await cursor.fetchone()

        if not bike_data:
            await context.bot.send_message(user_id, "🚫 Ошибка: товар не найден.")
            return

        is_unlimited_battery = bike_data['type'] == PRODUCT_TYPE_BATTERY and bike_data['is_unlimited'] == 1
        
        # Формируем базовый текст (подпись для фото или текст для сообщения)
        final_text = f"*{bike_data['name']}*\n_{bike_data['description'] or 'Описание отсутствует'}_"
        keyboard = []

        if is_unlimited_battery:
            # Для АКБ просто создаем кнопки
            keyboard.append([InlineKeyboardButton("🔋 Арендовать АКБ", callback_data=f"rent_battery_{bike_id}")])
            keyboard.append([InlineKeyboardButton("💰 Выкупить АКБ (рассрочка)", callback_data=f"buyout_battery_{bike_id}")])
        else:
            # Для обычных велосипедов добавляем тарифы в текст
            if bike_data['rent_price_7d'] is not None and bike_data['rent_price_7d'] > 0:
                final_text += "\n\n*Тарифы на аренду:*"
                final_text += f"\n• 7 дней: *{bike_data['rent_price_7d']} ₽*"
                final_text += f"\n• 14 дней: *{bike_data['rent_price_14d']} ₽*"
                final_text += f"\n• 30 дней: *{bike_data['rent_price_30d']} ₽*"
                keyboard.append([InlineKeyboardButton("🚀 Арендовать", callback_data=f"arenda_{bike_id}")])

            if bike_data['buyout_total_payments'] is not None and bike_data['buyout_total_payments'] > 0:
                final_text += "\n\n*Условия выкупа (рассрочка):*"
                final_text += f"\n• {bike_data['buyout_total_payments']} платежей по *{bike_data['buyout_payment_amount']} ₽*"
                final_text += f"\n• Периодичность: *каждые {bike_data['buyout_period_days']} дней*"
                keyboard.append([InlineKeyboardButton("💰 Выкупить", callback_data=f"buyout_{bike_id}")])

        # Логика кнопки "Назад" (без изменений)
        back_callback_data = "back_to_categories"
        if 'АКБ' in bike_data['name']:
             back_callback_data = "show_model_AKB_page_0"
        elif 'wenbox' in bike_data['name'].lower(): 
             back_callback_data = "show_model_Wenbox_page_0"
        elif 'jl' in bike_data['name'].lower() or 'esm' in bike_data['name'].lower(): 
             back_callback_data = "show_model_Kugoo_page_0"
        
        keyboard.append([InlineKeyboardButton("⬅️ Назад к списку", callback_data=back_callback_data)])
        
        # --- РАЗДЕЛЕНИЕ ЛОГИКИ ОТПРАВКИ ---
        
        if is_unlimited_battery:
            # Если это АКБ, отправляем простое ТЕКСТОВОЕ сообщение
            await context.bot.send_message(
                chat_id=user_id,
                text=final_text,
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            # Если это обычный велосипед, отправляем ФОТО с подписью
            await context.bot.send_photo(
                chat_id=user_id,
                photo=bike_data['photo_url'],
                caption=final_text,
                parse_mode='Markdown',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )

    except Exception as e:
        logger.error(f"Ошибка в bike_info: {e}", exc_info=True)
        await context.bot.send_message(user_id, "🚫 Произошла системная ошибка.")

# <<< НАЧАЛО НОВОГО БЛОКА КОДА >>>

# <<< НАЧАЛО НОВОГО БЛОКА КОДА >>>

async def handle_bike_list_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    Обрабатывает пагинацию, проверяя, есть ли следующая страница,
    чтобы избежать "зависания" и ошибок.
    """
    query = update.callback_query
    await query.answer()

    current_page = context.user_data.get('edit_page', 0)
    bikes_per_page = 5

    # --- Проверка возможности перехода ---
    async with aiosqlite.connect(DB_FILE) as conn:
        cursor = await conn.execute("SELECT COUNT(*) FROM bikes")
        total_bikes = (await cursor.fetchone())[0]
        total_pages = (total_bikes + bikes_per_page - 1) // bikes_per_page

    new_page = current_page
    if "next" in query.data and (current_page + 1) < total_pages:
        new_page = current_page + 1
    elif "prev" in query.data and current_page > 0:
        new_page = current_page - 1
    
    # Если страница не изменилась (например, нажали "вперед" на последней),
    # просто выходим, ничего не делая, чтобы не вызывать ошибку.
    if new_page == current_page:
        return EDIT_USER_MENU

    # Если страница изменилась, обновляем ее в контексте и перерисовываем меню
    context.user_data['edit_page'] = new_page
    await show_bike_list_for_editing(update, context)

    return EDIT_USER_MENU

# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>

# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>
# ШАГ 2: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ
AWAITING_PHOTO_FOR_ID = range(1) # Простое число, не пересекающееся с другими

# НАЙДИТЕ ФУНКЦИЮ get_photo_id_start И ЗАМЕНИТЕ ЕЕ НА ЭТУ ВЕРСИЮ

async def get_photo_id_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Начинает процесс получения file_id. Доступно только админу."""
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("🚫 Эта команда доступна только администратору.")
        return ConversationHandler.END

    # Убираем parse_mode, так как сложное форматирование здесь не нужно
    await update.message.reply_text(
        "📸 Отправьте фото, для которого нужно получить file_id.\n\n"
        "Для отмены введите /cancel."
        # УБРАН ПАРАМЕТР: parse_mode="MarkdownV2"
    )
    return AWAITING_PHOTO_FOR_ID

# НАЙДИТЕ ФУНКЦИЮ receive_photo_for_id И ЗАМЕНИТЕ ЕЕ НА ЭТУ ВЕРСИЮ

async def receive_photo_for_id(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Принимает фото и в ответ отправляет его file_id."""
    photo_file_id = update.message.photo[-1].file_id

    # Экранируем точки с помощью `\.`
    message_text = (
        f"✅ `file_id` получен:\n\n`{photo_file_id}`\n\n"
        "☝️ Нажмите на ID выше, чтобы скопировать его, а затем вставьте в базу данных в столбец `photo_url` для нужного велосипеда\\."
    )

    await update.message.reply_text(
        text=message_text,
        parse_mode="MarkdownV2" # Оставляем V2 для кликабельности
    )

    return ConversationHandler.END

async def cancel_get_id(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет операцию получения file_id."""
    await update.message.reply_text("Операция отменена.")
    return ConversationHandler.END
async def quick_rent_akb_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Сразу создает платеж для аренды дополнительного АКБ без договора.
    """
    query = update.callback_query
    await query.answer()
    
    # Разбираем callback_data: quick_rent_akb_{product_id}_{price}
    parts = query.data.split('_')
    product_id = int(parts[3])
    price = int(parts[4])
    user_id = query.from_user.id
    
    await query.message.edit_text("⏳ Готовлю счет на оплату аренды аккумулятора...")

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            # Получаем данные для чека и описания
            cursor = await conn.execute(
                "SELECT u.phone_number, b.name as item_name FROM users u, bikes b WHERE u.id=? AND b.id=?",
                (user_id, product_id)
            )
            data = await cursor.fetchone()

        if not data or not data['phone_number']:
            raise ValueError("Не найден пользователь или его номер телефона для чека.")

        # Формируем данные для YooKassa
        description = f"Аренда: {data['item_name']} на 7 дней"
        # Создаем уникальный payload для этого типа платежа
        payload = f"quick_rent_akb_{product_id}" 
        
        metadata = {'internal_payload': payload, 'user_id': user_id}
        items_for_receipt = [{"description": description, "quantity": "1.00", "amount": { "value": f"{price:.2f}", "currency": "RUB" }, "vat_code": "1", "payment_subject": "service"}]
        payment_info = await create_yookassa_payment(amount=price, description=description, metadata=metadata, items=items_for_receipt, customer_info={"phone": data['phone_number']}, payment_method='sbp')
        
        if not payment_info:
            raise ValueError("Не удалось создать ссылку на оплату.")

        # Отправляем счет и запускаем проверку (стандартная логика)
        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']
        
        keyboard = [[InlineKeyboardButton("💳 Оплатить", url=payment_url)]]
        animated_message = await query.message.edit_text(
            f"Для аренды аккумулятора, пожалуйста, оплатите {final_amount:.2f} ₽.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        if 'pending_payments' not in context.bot_data: context.bot_data['pending_payments'] = {}
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {'user_id': user_id, 'start_time': datetime.now(), 'payload': payload, 'amount': final_amount, 'animated_message_id': animated_message.message_id, 'url': payment_url, 'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 'stop_animation_event': stop_animation_event}
        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(callback=check_payment_status, interval=15, first=10, name=f"payment_{payment_id}", data={'yookassa_id': payment_id})

    except Exception as e:
        logger.error(f"Ошибка в quick_rent_akb_payment: {e}", exc_info=True)
        await query.message.edit_text(f"❌ Произошла ошибка: {e}")
# ВСТАВЬТЕ ЭТОТ КОД РЯДОМ С ДРУГИМИ ConversationHandler'ами

# --- НОВЫЙ ДИАЛОГ ДЛЯ АРЕНДЫ АККУМУЛЯТОРА ---

# Определяем состояния
(
    BATTERY_RENT_CONFIRMATION,
) = range(1)

async def start_battery_rent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Запускается по кнопке 'Арендовать АКБ'. Удаляет старое сообщение и шлет новое."""
    query = update.callback_query
    await query.answer()

    product_id = int(query.data.split('_')[-1])

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM bikes WHERE id=?", (product_id,))
    name = cursor.fetchone()[0]
    conn.close()

    battery_model = '60V21Ah' if '60V21Ah' in name else '60V30Ah'
    rent_plan = BATTERY_RENTAL_PRICES.get(battery_model)

    if not rent_plan:
        await context.bot.send_message(chat_id=query.from_user.id, text="🚫 Ошибка: тарифы не найдены.")
        return ConversationHandler.END

    context.user_data['rent_battery_data'] = {
        'product_id': product_id, 'name': name, 'model': battery_model,
        'price': rent_plan['initial_price'],
        'description': f"Первоначальный платеж за аренду АКБ '{name}' ({rent_plan['initial_months']} мес.)"
    }

    text = (
        f"Вы собираетесь арендовать аккумулятор *{name}*.\n\n"
        f"*Условия аренды:*\n"
        f"Первоначальный платеж за *{rent_plan['initial_months']} месяца* составляет *{rent_plan['initial_price']} руб.*\n"
        f"Далее арендная плата составит *{rent_plan['monthly_price']} руб/мес.*\n\n"
        f"Нажимая 'Подтвердить и оплатить', вы соглашаетесь с условиями и переходите к оплате."
    )

    keyboard = [
        [InlineKeyboardButton("✅ Подтвердить и оплатить", callback_data="confirm_battery_rent")],
        [InlineKeyboardButton("❌ Отмена", callback_data="cancel_battery_rent")]
    ]

    # --- ИСПРАВЛЕНИЕ: Удаляем старое сообщение и отправляем новое ---
    await query.message.delete()
    await context.bot.send_message(
        chat_id=query.from_user.id,
        text=text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return BATTERY_RENT_CONFIRMATION

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ process_battery_rent_payment НА ЭТУ ВЕРСИЮ

async def process_battery_rent_payment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (АРЕНДА): Формирует и отправляет ссылку на оплату через YooKassa (СБП) И ЗАПУСКАЕТ ПРОВЕРКУ."""
    query = update.callback_query
    await query.answer()

    if query.data == "cancel_battery_rent":
        await query.message.edit_text("Аренда отменена.")
        return ConversationHandler.END

    user_id = query.from_user.id
    data = context.user_data.get('rent_battery_data')

    if not data:
        await query.message.edit_text("🚫 Ошибка сессии. Пожалуйста, начните заново.")
        return ConversationHandler.END

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT phone_number FROM users WHERE id = ?", (user_id,))
    phone_number = (cursor.fetchone() or [None])[0]
    conn.close()

    if not phone_number:
        await query.message.edit_text("🚫 Ошибка: не найден ваш номер телефона для отправки чека.")
        return ConversationHandler.END

    amount = data['price']
    description = data['description']
    payload = f"rent_battery_{data['product_id']}_{amount}"

    metadata = {'internal_payload': payload, 'user_id': user_id}
    items_for_receipt = [{"description": description, "quantity": "1.00", "amount": {"value": f"{float(amount):.2f}", "currency": "RUB"}, "vat_code": "1", "payment_subject": "service", "payment_mode": "full_payment"}]
    customer_info = {"phone": phone_number}

    payment_info = await create_yookassa_payment(
        amount=amount, description=description, metadata=metadata,
        items=items_for_receipt, customer_info=customer_info, payment_method='sbp'
    )

    if not (payment_info and payment_info.get('url')):
        await query.message.edit_text("❌ Не удалось создать ссылку на оплату. Попробуйте позже.")
        return ConversationHandler.END

    # --- НАЧАЛО БЛОКА ЗАПУСКА ПРОВЕРКИ ---
    payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']

    keyboard = [[InlineKeyboardButton("💳 Оплатить по СБП", url=payment_url)]]
    animated_message = await query.message.edit_text(
        f"Для завершения аренды, пожалуйста, оплатите {final_amount:.2f} ₽.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

    # Сохраняем все необходимые данные для проверки
    if 'pending_payments' not in context.bot_data:
        context.bot_data['pending_payments'] = {}

    stop_animation_event = asyncio.Event()
    context.bot_data['pending_payments'][payment_id] = {
        'user_id': user_id, 'start_time': datetime.now(),
        'payload': metadata['internal_payload'], 'amount': final_amount,
        'animated_message_id': animated_message.message_id, 'url': payment_url,
        'animation_sequence': random.choice(PAYMENT_ANIMATIONS),
        'stop_animation_event': stop_animation_event
    }

    # Запускаем анимацию и проверку статуса
    asyncio.create_task(animate_payment_message(context, payment_id))
    context.job_queue.run_repeating(
        callback=check_payment_status,
        interval=15,
        first=10,
        name=f"payment_{payment_id}",
        data={'yookassa_id': payment_id}
    )
    # --- КОНЕЦ БЛОКА ЗАПУСКА ПРОВЕРКИ ---

    return ConversationHandler.END


# --- НОВЫЙ ДИАЛОГ ДЛЯ ВЫКУПА АККУМУЛЯТОРА ---

# Определяем состояния
(
    BATTERY_BUYOUT_SELECT_PLAN,
    BATTERY_BUYOUT_CONFIRMATION,
) = range(2)

async def start_battery_buyout(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Запускается по кнопке 'Выкупить АКБ'. Удаляет старое сообщение и шлет новое."""
    query = update.callback_query
    await query.answer()

    product_id = int(query.data.split('_')[-1])

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM bikes WHERE id=?", (product_id,))
    name = cursor.fetchone()[0]
    conn.close()

    battery_model = '60V21Ah' if '60V21Ah' in name else '60V30Ah'
    buyout_info = BATTERY_BUYOUT_PLANS.get(battery_model)

    if not buyout_info:
        await context.bot.send_message(chat_id=query.from_user.id, text="🚫 Ошибка: тарифы не найдены.")
        return ConversationHandler.END

    context.user_data['buyout_battery_data'] = {
        'product_id': product_id, 'name': name, 'model': battery_model,
        'initial_payment': buyout_info['initial_payment']
    }

    keyboard = []
    for key, plan in buyout_info['plans'].items():
        keyboard.append([InlineKeyboardButton(plan['label'], callback_data=f"select_bb_plan_{key}")])

    keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="cancel_battery_buyout")])

    # --- ИСПРАВЛЕНИЕ: Удаляем старое сообщение и отправляем новое ---
    await query.message.delete()
    await context.bot.send_message(
        chat_id=query.from_user.id,
        text=(
            f"Вы выбрали рассрочку на *{name}*.\n\n"
            f"Первоначальный взнос: *{buyout_info['initial_payment']} руб.*\n\n"
            "Выберите удобный для вас график дальнейших платежей:"
        ),
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return BATTERY_BUYOUT_SELECT_PLAN

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ select_battery_buyout_plan НА ЭТУ

async def select_battery_buyout_plan(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    Обрабатывает и выбор плана, и подтверждение, и отмену.
    """
    query = update.callback_query
    await query.answer()

    data_parts = query.data.split('_')
    action = data_parts[1] # 'bb' (для select_bb_plan) или 'buyout' (для confirm_battery_buyout)

    buyout_data = context.user_data.get('buyout_battery_data')
    if not buyout_data:
        await query.message.edit_text("🚫 Ошибка сессии. Пожалуйста, начните заново.")
        return ConversationHandler.END

    # --- Обработка выбора плана ---
    if action == 'bb':
        plan_key = query.data.split('select_bb_plan_')[-1]
        plan_details = BATTERY_BUYOUT_PLANS[buyout_data['model']]['plans'][plan_key]

        # Сохраняем ключ выбранного плана в контекст
        buyout_data['plan_key'] = plan_key

        text = (
            f"**Подтверждение рассрочки:**\n\n"
            f"Товар: *{buyout_data['name']}*\n"
            f"План: *{plan_details['label']}*\n\n"
            f"Сумма первого взноса: *{buyout_data['initial_payment']} руб.*\n\n"
            "Нажимая 'Подтвердить и оплатить', вы соглашаетесь с условиями и переходите к оплате."
        )

        keyboard = [
            [InlineKeyboardButton("✅ Подтвердить и оплатить", callback_data="confirm_battery_buyout")],
            [InlineKeyboardButton("⬅️ Назад к выбору планов", callback_data=f"buyout_battery_{buyout_data['product_id']}")]
        ]

        await query.message.edit_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
        # Остаемся в том же состоянии, просто меняем текст и кнопки
        return BATTERY_BUYOUT_SELECT_PLAN

    # --- Обработка подтверждения оплаты ---
    elif action == 'buyout' and data_parts[0] == 'confirm':
        # Этот код теперь находится в process_battery_buyout_payment,
        # так что мы просто вызываем эту функцию
        return await process_battery_buyout_payment(update, context)

    # --- Обработка отмены ---
    elif action == 'buyout' and data_parts[0] == 'cancel':
        await query.message.edit_text("Рассрочка отменена.")
        return ConversationHandler.END

    return ConversationHandler.END

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ process_battery_buyout_payment НА ЭТУ ВЕРСИЮ

async def process_battery_buyout_payment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 3 (ВЫКУП): Формирует ссылку на оплату (СБП) И ЗАПУСКАЕТ ПРОВЕРКУ."""
    query = update.callback_query
    await query.answer()

    if query.data.startswith("buyout_battery_"):
        return await start_battery_buyout(update, context)

    user_id = query.from_user.id
    data = context.user_data.get('buyout_battery_data')

    if not data:
        await query.message.edit_text("🚫 Ошибка сессии. Пожалуйста, начните заново.")
        return ConversationHandler.END

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT phone_number FROM users WHERE id = ?", (user_id,))
    phone_number = (cursor.fetchone() or [None])[0]
    conn.close()

    if not phone_number:
        await query.message.edit_text("🚫 Ошибка: не найден ваш номер телефона для отправки чека.")
        return ConversationHandler.END

    amount = data['initial_payment']
    description = f"Первый взнос за рассрочку на АКБ '{data['name']}'"
    payload = f"buyout_battery_{data['product_id']}_{data['plan_key']}_{amount}"

    metadata = {'internal_payload': payload, 'user_id': user_id}
    items_for_receipt = [{"description": description, "quantity": "1.00", "amount": {"value": f"{float(amount):.2f}", "currency": "RUB"}, "vat_code": "1", "payment_subject": "service", "payment_mode": "full_payment"}]
    customer_info = {"phone": phone_number}

    payment_info = await create_yookassa_payment(
        amount=amount, description=description, metadata=metadata,
        items=items_for_receipt, customer_info=customer_info, payment_method='sbp'
    )

    if not (payment_info and payment_info.get('url')):
        await query.message.edit_text("❌ Не удалось создать ссылку на оплату. Попробуйте позже.")
        return ConversationHandler.END

    # --- НАЧАЛО БЛОКА ЗАПУСКА ПРОВЕРКИ ---
    payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']

    keyboard = [[InlineKeyboardButton("💳 Оплатить по СБП", url=payment_url)]]
    animated_message = await query.message.edit_text(
        f"Для оформления рассрочки, оплатите первый взнос: {final_amount:.2f} ₽.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

    if 'pending_payments' not in context.bot_data:
        context.bot_data['pending_payments'] = {}

    stop_animation_event = asyncio.Event()
    context.bot_data['pending_payments'][payment_id] = {
        'user_id': user_id, 'start_time': datetime.now(),
        'payload': metadata['internal_payload'], 'amount': final_amount,
        'animated_message_id': animated_message.message_id, 'url': payment_url,
        'animation_sequence': random.choice(PAYMENT_ANIMATIONS),
        'stop_animation_event': stop_animation_event
    }

    asyncio.create_task(animate_payment_message(context, payment_id))
    context.job_queue.run_repeating(
        callback=check_payment_status,
        interval=15,
        first=10,
        name=f"payment_{payment_id}",
        data={'yookassa_id': payment_id}
    )
    # --- КОНЕЦ БЛОКА ЗАПУСКА ПРОВЕРКИ ---

    return ConversationHandler.END


######## НАЧАЛО АРЕНДЫ ##########
######## НАЧАЛО АРЕНДЫ ##########
######## НАЧАЛО АРЕНДЫ ##########

# ==============================================================================
# ПОЛНАЯ И ИСПРАВЛЕННАЯ ВЕРСИЯ ФУНКЦИИ start_buyout
# ==============================================================================
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ start_buyout НА ЭТУ ВЕРСИЮ

# ШАГ 4: ПОЛНОСТЬЮ ЗАМЕНИТЕ ФУНКЦИЮ start_buyout

async def start_buyout(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ОБНОВЛЕННАЯ ВЕРСИЯ:
    - Удаляет предыдущее сообщение с фото.
    - Отправляет новое текстовое сообщение с планом выкупа.
    """
    query = update.callback_query
    await query.answer()

    bike_id = int(query.data.split('_')[1])
    context.user_data['buyout_bike_id'] = bike_id

    # Получаем данные плана выкупа из конкретного велосипеда
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute(
        "SELECT name, buyout_total_payments, buyout_payment_amount, buyout_period_days FROM bikes WHERE id=?", 
        (bike_id,)
    )
    result = cursor.fetchone()
    conn.close()

    if not result or not result[1] or result[1] <= 0:
        # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
        # Сначала удаляем старое сообщение
        await query.message.delete()
        # Затем отправляем новое
        await context.bot.send_message(
            chat_id=query.from_user.id,
            text="Для этого велосипеда не настроен план выкупа. Свяжитесь с поддержкой."
        )
        # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
        return ConversationHandler.END

    name, total_payments, payment_amount, period_days = result
    
    # Формируем текст с единственным планом выкупа
    plan_text = (
        f"💰 *План выкупа для «{name}»*\n\n"
        f" • Всего платежей: *{total_payments}*\n"
        f" • Сумма платежа: *{payment_amount} ₽*\n"
        f" • Периодичность: *каждые {period_days} дней*\n\n"
        "Нажимая 'Подтвердить', вы соглашаетесь с данными условиями."
    )
    
    context.user_data['buyout_plan_key'] = f"buyout_bike_{bike_id}"
    
    keyboard = [
        [InlineKeyboardButton("✅ Подтвердить и создать заявку", callback_data="confirm_buyout_payment")],
        [InlineKeyboardButton("⬅️ Назад", callback_data=f"info_{bike_id}")]
    ]
    
    # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
    # Удаляем старое сообщение (с фото)
    await query.message.delete()
    
    # Отправляем новое текстовое сообщение
    await context.bot.send_message(
        chat_id=query.from_user.id,
        text=plan_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

    return CONFIRM_BUYOUT

async def select_buyout_plan(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает выбор плана и запрашивает подтверждение."""
    query = update.callback_query
    await query.answer()

    plan_key = '_'.join(query.data.split('_')[2:])

    if plan_key not in BUYOUT_PLANS:
        logging.error(f"Неверный ключ плана выкупа получен: {plan_key}")
        await query.edit_message_text("Произошла ошибка, попробуйте снова.")
        return SELECT_BUYOUT_PLAN

    plan = BUYOUT_PLANS[plan_key]
    context.user_data['buyout_plan_key'] = plan_key

    text = (
        f"📝 *Подтверждение плана выкупа*\n\n"
        # ИСПРАВЛЕНИЕ: используем ключ 'full_label' для полного описания
        f"Вы выбрали: *{plan['full_label']}*\n\n"
        f"Первый платеж составит: *{plan['first_payment']} ₽*\n"
        f"Всего платежей: *{plan['total_payments']}*\n\n"
        "Нажимая 'Подтвердить и оплатить', вы соглашаетесь с условиями договора оферты и переходите к оплате первого взноса."
    )

    keyboard = [
        [InlineKeyboardButton("✅ Подтвердить и оплатить", callback_data="confirm_buyout_payment")],
        [InlineKeyboardButton("⬅️ Назад к выбору планов", callback_data=f"buyout_{context.user_data['buyout_bike_id']}")]
    ]

    await query.edit_message_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return CONFIRM_BUYOUT

# Замените вашу старую функцию на эту
# ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ confirm_buyout_payment НА ЭТУ:
# ЗАМЕНИТЕ СТАРУЮ ФУНКЦИЮ confirm_buyout_payment НА ЭТУ:
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ confirm_buyout_request НА ЭТУ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ confirm_buyout_request НА ЭТУ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ confirm_buyout_request НА ЭТУ

async def confirm_buyout_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    - Корректно обрабатывает заявки на выкуп для велосипедов с индивидуальными тарифами из БД.
    """
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    plan_key = context.user_data.get('buyout_plan_key')
    bike_model_id = context.user_data.get('buyout_bike_id')

    if not all([plan_key, bike_model_id]):
        await context.bot.send_message(
            chat_id=user_id,
            text="🚫 Ошибка: данные о выкупе не найдены. Начните заново."
        )
        return ConversationHandler.END

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    try:
        start_date = datetime.now().strftime('%d.%m.%Y')
        cursor.execute(
            """INSERT INTO bookings (user_id, bike_id, booking_date, status, booking_type, payment_plan_key)
               VALUES (?, ?, ?, ?, ?, ?)""",
            (user_id, bike_model_id, start_date, 'paid_unassigned', 'buyout', plan_key)
        )
        booking_id = cursor.lastrowid
        conn.commit()

        try:
            await query.message.delete()
        except Exception as e:
            logger.warning(f"Не удалось удалить сообщение: {e}")

        await context.bot.send_message(
            chat_id=user_id,
            text="✅ Ваша заявка создана! Администратор свяжется с вами для уточнения деталей и выставления счета. 🕒"
        )

        cursor.execute("SELECT first_name, last_name, username FROM users WHERE id=?", (user_id,))
        user_info = cursor.fetchone()
        user_name_raw = f"{user_info[0]} {user_info[1] or ''} (@{user_info[2] or 'no_username'})" if user_info else f"ID {user_id}"

        cursor.execute("SELECT name FROM bikes WHERE id=?", (bike_model_id,))
        bike_name = cursor.fetchone()[0]

        plan_label = ""
        button_text = "✍️ Обработать заявку"

        # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
        if plan_key == 'custom':
            plan_label = "Индивидуальные условия"
            button_text = "✍️ Создать сделку вручную"
        else:
            # Если это не кастомная сделка, значит, это выкуп с индивидуальным планом из БД
            cursor.execute(
                "SELECT buyout_total_payments, buyout_payment_amount, buyout_period_days FROM bikes WHERE id=?",
                (bike_model_id,)
            )
            plan_details = cursor.fetchone()
            if plan_details:
                total_payments, payment_amount, period_days = plan_details
                plan_label = f"{total_payments} платежей по {payment_amount} ₽ (раз в {period_days} дней)"
                button_text = "✍️ Обработать стандартный выкуп"
            else:
                plan_label = "План не найден в БД!"
        # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
        
        admin_notification = (
            f"🚨 *Новая заявка на ВЫКУП\\!*\n\n"
            f"👤 *Клиент:* {escape_markdown(user_name_raw, 2)}\n"
            f"🚲 *Модель:* {escape_markdown(bike_name, 2)}\n"
            f"📋 *План:* {escape_markdown(plan_label, 2)}\n\n"
            f"Нажмите, чтобы назначить велосипед и выставить счет:"
        )

        keyboard = [[InlineKeyboardButton(button_text, callback_data=f"assign_{booking_id}")]]

        for admin_id in ADMIN_IDS:
            await context.bot.send_message(
                admin_id, admin_notification,
                parse_mode="MarkdownV2",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )

        add_notification(f"Новая заявка на ВЫКУП от {user_name_raw} ({plan_label})")

    except Exception as e:
        logger.error(f"Ошибка в confirm_buyout_request: {e}", exc_info=True)
        await context.bot.send_message(
            chat_id=user_id,
            text="❌ Ошибка при создании заявки. Свяжитесь с поддержкой."
        )
    finally:
        if conn: conn.close()

    return ConversationHandler.END

async def arenda(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    bike_id = query.data.split("_")[1]
    
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT name, price FROM bikes WHERE id=?", (bike_id,))
    bike = cursor.fetchone()
    conn.close()

    if bike:
        # Выбор срока аренды с добавлением 7 дней
        keyboard = [
            # Новая кнопка на 7 дней
            [InlineKeyboardButton("На 7 дней", callback_data=f"prolong_7_{bike_id}")],
            [InlineKeyboardButton("На 14 дней", callback_data=f"prolong_14_{bike_id}")],
            [InlineKeyboardButton("На 30 дней", callback_data=f"prolong_30_{bike_id}")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.message.reply_text("Выберите срок аренды:", reply_markup=reply_markup)
    else:
        await query.message.reply_text("🚫 Ошибка: велосипед не найден.")


# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ select_rental_period НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ select_rental_period НА ЭТУ ВЕРСИЮ

# ШАГ 3: ПОЛНОСТЬЮ ЗАМЕНИТЕ ФУНКЦИЮ select_rental_period

import sqlite3
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

async def select_rental_period(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    ОБНОВЛЕННАЯ ВЕРСИЯ:
    Обрабатывает выбор срока аренды.
    1.  Получает цену аренды из ИНДИВИДУАЛЬНЫХ полей велосипеда в БД.
    2.  Проверяет и применяет персональную скидку пользователя.
    3.  Показывает финальное подтверждение с итоговой ценой и условиями.
    """
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    
    # --- Шаг 1: Разбираем данные из кнопки ---
    try:
        # Callback имеет формат: prolong_{days}_{bike_id}
        _, days_str, bike_id_str = query.data.split("_")
        days = int(days_str)
        bike_id = int(bike_id_str)
    except (ValueError, IndexError):
        await query.message.edit_text("🚫 Произошла ошибка. Пожалуйста, попробуйте выбрать велосипед заново.")
        return

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    try:
        # --- Шаг 2: Получаем цену из нужной колонки в БД ---
        # Динамически формируем имя колонки (rent_price_7d, rent_price_14d и т.д.)
        price_column = f"rent_price_{days}d"
        
        # Получаем название велосипеда и его ИНДИВИДУАЛЬНУЮ цену на выбранный срок
        cursor.execute(f"SELECT name, {price_column} FROM bikes WHERE id=?", (bike_id,))
        result = cursor.fetchone()
        
        if not result:
            await query.message.edit_text("🚫 Ошибка: велосипед не найден в базе данных.")
            return

        bike_name, total_price = result
        
        # Проверяем, установлена ли цена для этого велосипеда
        if not total_price or total_price <= 0:
            await query.message.edit_text(f"🚫 Для этого велосипеда не установлена цена аренды на {days} дней. Пожалуйста, выберите другой срок или велосипед.")
            return

        # --- Шаг 3: Проверяем и применяем скидку ---
        final_price = float(total_price)
        discount_amount = 0
        cursor.execute("""
            SELECT amount FROM discounts
            WHERE user_id = ? AND is_used = 0 AND expiry_date > CURRENT_TIMESTAMP
            ORDER BY created_at DESC LIMIT 1
        """, (user_id,))
        active_discount = cursor.fetchone()
        if active_discount:
            discount_amount = active_discount[0]
            # Используем вспомогательную функцию для расчета
            final_price = apply_discount(final_price, discount_amount)
        
        # --- Шаг 4: Сохраняем все данные для следующего шага ---
        context.user_data['rental_data'] = {
            'bike_id': bike_id,
            'days': days,
            'bike_name': bike_name,
            'total_price': final_price # Сохраняем итоговую цену со скидкой
        }

        # --- Шаг 5: Формируем и отправляем сообщение для подтверждения ---
        price_message = f"Сумма к оплате: *{final_price:.2f} ₽*.\n"
        if discount_amount > 0:
            price_message += f"_(с учетом вашей скидки в {discount_amount} ₽, обычная цена: {total_price:.2f} ₽)_\n"

        keyboard = [[InlineKeyboardButton("✅ Я согласен и подтверждаю", callback_data="confirm_agreement")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        final_text = (
            f"Вы выбрали аренду '{bike_name}' на {days} дней.\n\n"
            f"{price_message}\n"
            "⚠️ Нажимая кнопку «✅ Я согласен и подтверждаю», вы:\n"
            "1. Подтверждаете свое полное согласие с условиями "
            "[публичной оферты](https://badfoxbike.ru/oferta.html) и [политикой обработки персональных данных](https://badfoxbike.ru/privacy-policy.html).\n"
            "2. Подтверждаете, что ознакомились с условиями аренды и принимаете их.\n\n"
            "Для продолжения нажмите кнопку ниже:"
        )

        await query.message.edit_text(
            final_text,
            parse_mode='Markdown',
            disable_web_page_preview=True,
            reply_markup=reply_markup
        )
    
    except sqlite3.Error as e:
        logger.error(f"Ошибка БД в select_rental_period: {e}")
        await query.message.edit_text("🚫 Произошла ошибка при доступе к данным. Попробуйте позже.")
    finally:
        # Гарантированно закрываем соединение с базой данных
        conn.close()

from telegram import Update, LabeledPrice
from telegram.ext import ContextTypes, ApplicationBuilder  # Если используете ApplicationBuilder
from telegram import Update, LabeledPrice, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
import sqlite3
from datetime import datetime

# main.py
# Основной файл бота (например, PythonApplication12.py)

# Определяем состояния для нового диалог

# Основной файл бота

# Определяем состояния для нового диалога




async def cancel_processing(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет диалог обработки заявки."""
    query = update.callback_query
    await query.answer()

    # Редактируем сообщение, чтобы пользователь видел, что действие отменено
    await query.edit_message_text("Обработка заявки отменена.")

    # Очищаем временные данные
    context.user_data.clear()

    # Завершаем диалог
    return ConversationHandler.END


# Основной файл бота
import fpdf # Убедитесь, что этот импорт есть в начале файла
import fpdf
from fpdf.enums import XPos, YPos
import json
import os
from datetime import datetime
import locale
# Вставьте этот код вместо старой функции assign_bike_by_number
# НОВАЯ ФУНКЦИЯ ДЛЯ ГЕНЕРАЦИИ ДЕТАЛЬНОГО ДОГОВОРА В PDF

# НОВАЯ ФУНКЦИЯ ДЛЯ ГЕНЕРАЦИИ ДОГОВОРА В WORD (.DOCX)
# Убедитесь, что вы установили библиотеку: pip install python-docx
from docx import Document
from docx.shared import Pt, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from datetime import datetime
import locale
import sqlite3
import json
import os
import locale
from datetime import datetime

# Импорты для python-telegram-bot
from telegram import Update, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler

# Импорты для python-docx
from docx import Document
from docx.shared import Pt, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn

# --- КОНСТАНТЫ (убедитесь, что они у вас определены) ---
# PROCESS_APPLICATION_ENTER_NUMBER = range(1) # Ваше состояние
# DB_FILE = "your_database.db" # Путь к вашей базе данных
# PROVIDER_TOKEN = "YOUR_PAYMENT_PROVIDER_TOKEN" # Ваш токен для платежей
# import logging
# logger = logging.getLogger(__name__)

# --- ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ СОЗДАНИЯ КОЛОНТИТУЛА (ФУТЕРА) ---
# --- ПОЛНОСТЬЮ ИСПРАВЛЕННАЯ ФУНКЦИЯ ДЛЯ КОЛОНТИТУЛА ---
# Замените вашу старую версию этой функции на эту
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
# main.py

# --- КОД ДЛЯ ГЕНЕРАЦИИ ДОГОВОРА ---
# Убедитесь, что у вас установлена библиотека: pip install python-docx

import locale
import json
import os
from datetime import datetime
from docx import Document
from docx.shared import Pt, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn



# ШАГ 3: ПОЛНОСТЬЮ ЗАМЕНИТЕ ЭТУ ФУНКЦИЮ

# Установите библиотеки, если их нет:
# pip install python-docx
# pip install num2words

from docx import Document
from docx.shared import Pt, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from datetime import datetime
from num2words import num2words
import locale
import os

# Убедитесь, что библиотеки установлены:
# pip install python-docx
# pip install num2words

from docx import Document
from docx.shared import Pt, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from datetime import datetime
from num2words import num2words
import locale
import os

# Убедитесь, что библиотеки установлены:
# pip install python-docx
# pip install num2words

from docx import Document
from docx.shared import Pt, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from datetime import datetime
from num2words import num2words
import locale
import os

# ==============================================================================
# ПОЛНАЯ И ОКОНЧАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ ГЕНЕРАЦИИ ОБОИХ ДОГОВОРОВ
# ==============================================================================
import locale
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from num2words import num2words
from datetime import datetime
import os

# Устанавливаем русскую локаль для правильного отображения месяцев
try:
    locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')
except locale.Error:
    logger.warning("Не удалось установить локаль ru_RU.UTF-8. Названия месяцев могут быть на английском.")

# ==============================================================================
# ПОЛНАЯ И ОКОНЧАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ ГЕНЕРАЦИИ ОБОИХ ДОГОВОРОВ (С ФИКСАМИ)
# ==============================================================================
import locale
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from num2words import num2words
from datetime import datetime
import os

# Устанавливаем русскую локаль для правильного отображения месяцев
try:
    locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')
except locale.Error:
    logger.warning("Не удалось установить локаль ru_RU.UTF-8. Названия месяцев могут быть на английском.")

# ==============================================================================
# ПОЛНАЯ И ОКОНЧАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ ГЕНЕРАЦИИ ОБОИХ ДОГОВОРОВ
# ==============================================================================
import locale
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from num2words import num2words
from datetime import datetime
import os

# Устанавливаем русскую локаль для правильного отображения месяцев
try:
    locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')
except locale.Error:
    logger.warning("Не удалось установить локаль ru_RU.UTF-8. Названия месяцев могут быть на английском.")

# ==============================================================================
# ПОЛНАЯ И ОКОНЧАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ ГЕНЕРАЦИИ ОБОИХ ДОГОВОРОВ
# ==============================================================================
import locale
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from num2words import num2words
from datetime import datetime
import os

# Устанавливаем русскую локаль для правильного отображения месяцев
try:
    locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')
except locale.Error:
    logger.warning("Не удалось установить локаль ru_RU.UTF-8. Названия месяцев могут быть на английском.")

# ==============================================================================
# ПОЛНАЯ И ОКОНЧАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ ГЕНЕРАЦИИ ОБОИХ ДОГОВОРОВ (С ФИКСАМИ)
# ==============================================================================
import locale
from docx import Document
from docx.shared import Pt, Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from num2words import num2words
from datetime import datetime
import os

# Устанавливаем русскую локаль для правильного отображения месяцев
try:
    locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')
except locale.Error:
    logger.warning("Не удалось установить локаль ru_RU.UTF-8. Названия месяцев могут быть на английском.")

def generate_contract_docx(booking_id: int, deal_type: str, deal_data: dict, user_data: dict, bike_data: dict) -> str:
    """
    Генерирует нужный документ (.docx) - Акт для аренды или Соглашение для выкупа.
    """
    doc = Document()
    
    # --- Настройки форматирования для всего документа ---
    style = doc.styles['Normal']
    font = style.font
    font.name = 'Times New Roman'
    font.size = Pt(11)

    # Уменьшаем поля, чтобы влезло на 3 страницы
    section = doc.sections[0]
    section.left_margin = Cm(2.0)
    section.right_margin = Cm(1.0)
    section.top_margin = Cm(1.5)
    section.bottom_margin = Cm(1.5)

    now = datetime.now()
    month_names_ru = {
       1: "января", 2: "февраля", 3: "марта", 4: "апреля", 5: "мая", 6: "июня",
       7: "июля", 8: "августа", 9: "сентября", 10: "октября", 11: "ноября", 12: "декабря"
    }
    date_str = f'«{now.day}» {month_names_ru[now.month]} {now.year} г.'

    # =========================================================================
    # --- Логика для АКТА АРЕНДЫ (deal_type == 'rent') ---
    # =========================================================================
    if deal_type == 'rent':
        doc.add_heading('АКТ', level=1).alignment = WD_ALIGN_PARAGRAPH.CENTER
        doc.add_paragraph('приема-передачи к Публичной оферте о заключении договора аренды электровелосипеда в редакции от 29.06.2025 года').alignment = WD_ALIGN_PARAGRAPH.CENTER
        doc.add_paragraph(f'г. Москва\t\t\t\t\t{date_str}')
        
        p_preamble = doc.add_paragraph()
        p_preamble.paragraph_format.space_after = Pt(6)
        run_user = p_preamble.add_run(user_data.get('full_name', '___________________________'))
        run_user.bold = True
        p_preamble.add_run(f", именуемый в дальнейшем «Арендатор», с одной стороны и\n") # Пол всегда мужской
        run_owner = p_preamble.add_run('Кузнецов Владислав Игоревич')
        run_owner.bold = True
        p_preamble.add_run(', являющийся плательщиком налога на профессиональный доход на основании справки о регистрации плательщика налога на профессиональный доход от 26.05.2025 № 81914483, именуемый в дальнейшем «Арендодатель» с другой стороны, совместно именуемые «Стороны», а по отдельности «Сторона», составили настоящий акт приема-передачи (далее - Акт) о следующем:')
        
        doc.add_paragraph('1. В соответствии с Публичной офертой о заключении договора аренды электровелосипеда в редакции от 29.06.2025 года (далее - Договор) Арендодатель передал, а Арендатор принял следующее оборудование (далее - Оборудование):')
        doc.add_paragraph(f"- марка, модель: {bike_data.get('model', '________________')} \tVIN: {bike_data.get('vin', '__________________________')};")
        
        # --- Вставка номеров АКБ ---
        battery_nums = bike_data.get('battery_numbers', [])
        battery_count = bike_data.get('batteries_count', '___')
        if battery_nums:
            num_str = ", ".join([f"№{num}" for num in battery_nums])
            doc.add_paragraph(f"- батареи, шт.: {battery_count} ({num_str}).")
        else:
            doc.add_paragraph(f"- батареи, шт.: {battery_count}.")
        
        doc.add_paragraph('2. Оборудование оснащено следующим серийным оборудованием и комплектующими изделиями, установленными заводом-изготовителем, а также дополнительным оборудованием:\n- Резинка для багажника;\n- Велосипедный замок.')
        doc.add_paragraph('3. При осмотре повреждения и эксплуатационных дефектов Оборудование не обнаружено, нарушения комплектности отсутствуют.')
        
        price = deal_data.get('price', 0)
        price_in_words = num2words(int(price), lang='ru').capitalize()
        p4_text = (
            '4. Настоящее АКТ приема-передачи к Публичной оферте о заключении договора аренды электровелосипеда в редакции от 29.06.2025 (далее –АКТ) заключено Сторонами дистанционно путём совершения следующих конклюдентных действий, обеспечивающих надлежащую идентификацию Сторон: для заключения настоящего АКТа Арендатор осуществляет со своего банковского счёта на банковский счёт Арендодателя денежный перевод в размере '
            f'{price:,.0f} ({price_in_words}) рублей. Платеж должен быть совершен с использованием банковских данных Арендатора, указанных в настоящем АКТе. В целях определения актуальной (действующей) редакции АКТа в случае его обсуждения Сторонами каждая новая редакция АКТа обозначается новым (уникальным) номером. '
            'АКТа является редакция, утверждённая Сторонами посредством обмена сообщениями по Мобильному приложению — программе для мобильных операционных систем (телеграм-бот) https://t.me/badfoxbikebot.'
        ).replace(",", " ")
        doc.add_paragraph(f'\n{p4_text}')

        doc.add_paragraph('\n5. Скор аренды выбирается Арендатором через Мобильное приложение — программе для мобильных операционных систем (телеграм-бот) https://t.me/badfoxbikebot в рамках Публичной оферте о заключении договора аренды электровелосипеда в редакции от 29.06.2025 года.')
        doc.add_paragraph('\n6. Настоящий АКТ составлен в двух экземплярах, имеющих одинаковую юридическую силу, по одному экземпляру для каждой Стороны.')
        
        output_filename = f"Акт_№{booking_id}_от_{now.strftime('%d-%m-%Y')}.docx"

    # =========================================================================
    # --- Логика для СОГЛАШЕНИЯ О ВЫКУПЕ (deal_type == 'buyout') ---
    # =========================================================================
    elif deal_type == 'buyout':
        plan_data = deal_data
        
        doc.add_heading(
            'Дополнительное соглашение к Публичной оферте о заключении договора аренды\n'
            'электровелосипеда в редакции от 29.06.2025\n'
            'о выкупе арендуемого имущества',
            level=1
        ).alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        doc.add_paragraph(f'г. Москва\t\t\t\t\t{date_str}')

        p_preamble = doc.add_paragraph()
        p_preamble.paragraph_format.space_after = Pt(6)
        run_owner = p_preamble.add_run('Кузнецов Владислав Игоревич')
        run_owner.bold = True
        p_preamble.add_run(', являющийся плательщиком налога на профессиональный доход на основании справки о регистрации плательщика налога на профессиональный доход от 13.06.2025 № 83338912, именуемый в дальнейшем «Арендодатель», с одной стороны и\n')
        run_user = p_preamble.add_run(user_data.get('full_name', '_________________________________'))
        run_user.bold = True
        p_preamble.add_run(f", именуемый в дальнейшем «Арендатор», с другой стороны, именуемые вместе «Стороны», а по отдельности «Сторона», заключили настоящее Дополнительное соглашение к Публичной оферте о заключении договора аренды электровелосипеда в редакции от 29.06.2025 (далее - Соглашение) о нижеследующем:")
        
        doc.add_heading('1. Предмет Соглашения', level=2,).alignment = WD_ALIGN_PARAGRAPH.CENTER
        doc.add_paragraph('1.1. Настоящее Соглашение заключается в соответствии с п. 2 ст. 624 Гражданского кодекса Российской Федерации.')
        doc.add_paragraph(f"1.2. Арендодатель обязуется передать в собственность Арендатора имущество:\nЭлектровелосипед марки: {bike_data.get('model', '______________________')}, VIN {bike_data.get('vin', '_________________________')}\nколичество 1 шт.")
        doc.add_paragraph("Аксессуары:\nЗарядное устройство для аккумулятора 1 шт.,\nПротивоугонный замок 1 шт.,\nБагажник 1 шт.,\nНабор ключей (2 ключа + брелок сигнализации),\nРезинка для багажника 1 шт.,\nЗеркала 2 шт.,")

        # --- Вставка номеров АКБ ---
        battery_nums = bike_data.get('battery_numbers', [])
        battery_count = bike_data.get('batteries_count', '_')
        if battery_nums:
            num_str = ", ".join([f"№{num}" for num in battery_nums])
            doc.add_paragraph(f"Аккумуляторная батарея {battery_count} шт. ({num_str})")
        else:
            doc.add_paragraph(f"Аккумуляторная батарея {battery_count} шт.")
        
        doc.add_paragraph('(далее - Имущество), при условии внесения Арендатором всей обусловленной настоящим Соглашением выкупной цены), а Арендатор обязуется принять и оплатить это Имущество в порядке и в сроки, установленные настоящим Соглашением.')
        doc.add_paragraph('1.3. Арендодатель гарантирует, что передаваемое Имущество принадлежит ему на праве собственности, в споре или под арестом не состоит, не является предметом залога и не обременено другими правами третьих лиц, кроме заключенного между ним и Арендатором Договора аренды.')
        doc.add_paragraph('1.4. Право собственности на Имущество переходит к Арендатору с момента полной оплаты выкупной цены и подписания Сторонами Передаточного акта. Подписание Передаточного акта осуществляется исключительно после внесения всей суммы выкупной цены. Арендатор подтверждает отсутствие недостатков Имущества, в том числе скрытых.')
        
        doc.add_heading('2. Выкупная цена и порядок оплаты', level=2).alignment = WD_ALIGN_PARAGRAPH.CENTER
        total_price = plan_data.get('total_price', 0)
        total_price_words = num2words(int(total_price), lang='ru').capitalize()
        doc.add_paragraph(f'2.1. Выкупная цена Имущества составляет {total_price:,.0f} ({total_price_words}) рублей, НДС не облагается.'.replace(",", " "))
        
        weekly_payment = plan_data.get('weekly_payment', 0)
        weeks_count = plan_data.get('weeks_count', 0)
        weekly_payment_words = num2words(int(weekly_payment), lang='ru').capitalize()
        
        weeks_count_text = num2words(weeks_count, lang='ru')
        doc.add_paragraph(f'2.2. Оплата выкупной цены производится Арендатором еженедельно в течение {weeks_count_text} недель равными платежами по {weekly_payment:,.0f} ({weekly_payment_words}) рублей, распределенными следующим образом:'.replace(",", " "))
        
        for i in range(1, weeks_count + 1):
            p = doc.add_paragraph(f'{i}-я неделя месяца: {weekly_payment:,.0f} ({weekly_payment_words}) рублей'.replace(",", " "))
            p.paragraph_format.space_after = Pt(0)
        doc.add_paragraph(f'Платежи вносятся строго в течение календарной недели (понедельник-воскресенье). При подписании настоящего Соглашения вносится первый платеж в размере {weekly_payment:,.0f} ({weekly_payment_words}) рублей.'.replace(",", " "))

        doc.add_heading('3. Ответственность Сторон', level=2).alignment = WD_ALIGN_PARAGRAPH.CENTER
        doc.add_paragraph('3.1. Арендодатель несет ответственность по настоящему Соглашению в пределах выкупной цены.')
        doc.add_paragraph('3.1.1. В случае нарушения срока внесения платежа, установленного п. 2.2. Арендатор выплачивает Арендодателю неустойку в размере 0,5% выкупной цены Имущества за каждый день просрочки.')
        doc.add_paragraph('3.2. В случаях, не предусмотренных настоящим Соглашением, ответственность Сторон определяется Публичной офертой о заключении договора аренды электровелосипеда в редакции от 29.06.2025.')
        
        doc.add_heading('4. Прочие условия', level=2).alignment = WD_ALIGN_PARAGRAPH.CENTER
        doc.add_paragraph('4.1. Изменения, дополнения к настоящему Соглашению действительны только в том случае, если составлены в письменной форме и подписаны уполномоченными представителями Сторон.')
        doc.add_paragraph('4.2. Споры и разногласия, возникающие в связи с настоящим Соглашением, Стороны постараются урегулировать путем переговоров.')
        doc.add_paragraph('4.3. В случае невозможности урегулирования споров путем переговоров они передаются на рассмотрение в судебном порядке в соответствии с законодательством Российской Федерации.')
        p4_4_text = ('4.4. Настоящее Дополнительное соглашение к Публичной оферте о заключении договора аренды электровелосипеда в редакции от 29.06.2025 о выкупе арендуемого имущества (далее – Дополнительное соглашение) заключено Сторонами дистанционно путём совершения следующих конклюдентных деиствий, обеспечивающих надлежащую идентификацию Сторон: для заключения настоящего Дополнительного соглашения Арендатор осуществляет со своего банковского счёта на банковский счёт Арендодателя денежный перевод в размере '
                     f'{weekly_payment:,.0f} ({weekly_payment_words}) рублей. Платеж должен быть совершен с использованием банковских данных Арендатора, указанных в настоящем Дополнительном соглашении. В целях определения актуальной (действующей) редакции Дополнительного соглашения в случае его обсуждения Сторонами каждая новая редакция Дополнительного соглашения обозначается новым (уникальным) номером. Актуальной (действующей) редакцией Дополнительного соглашения является редакция, утверждённая Сторонами посредством обмена сообщениями по Мобильному приложению — программе для мобильных операционных систем (телеграм-бот) https://t.me/badfoxbikebot.').replace(",", " ")
        doc.add_paragraph(p4_4_text)
        
        doc.add_heading('5. Заключительная часть', level=2).alignment = WD_ALIGN_PARAGRAPH.CENTER
        doc.add_paragraph('5.1. Настоящее Соглашение составлено в двух экземплярах, имеющих одинаковую юридическую силу, по одному экземпляру для каждой Стороны.')
        
        output_filename = f"Соглашение_о_выкупе_№{booking_id}_от_{now.strftime('%d-%m-%Y')}.docx"

    else:
        raise ValueError(f"Неизвестный тип документа: {deal_type}. Используйте 'rent' или 'buyout'.")

    # --- Общая часть: Таблица с реквизитами ---
    table = doc.add_table(rows=1, cols=2)
    table.style = 'Table Grid'
    
    cell_left = table.cell(0, 0)
    cell_left.paragraphs[0].add_run('Арендодатель').bold = True
    cell_left.add_paragraph('Кузнецов Владислав Игоревич\nПаспорт серия: 0115 №127738 выдан Отделом УФМС России по Алтайскому краю в г. Славгороде 18.11.2015\n\nАдрес: МО, г. Балашиха, мкр. Железнодорожный, ул. Советская, д. 10, кв. 139.\n\nИНН 221004234151\nСправка о регистрации плательщика НПД № 83338912 от 13.06.2025\nНомер счёта: 40817810238068834312\nБанк получателя: ПАО Сбербанк')
    cell_left.add_paragraph('\n\n_____________________/Кузнецов В.И.\n(подпись)')
    
    cell_right = table.cell(0, 1)
    cell_right.paragraphs[0].add_run('Арендатор').bold = True
    passport_text = (
        f"Паспорт серия: {user_data.get('passport_series', '___')} № {user_data.get('passport_number', '_______________')}\n"
        f"выдан {user_data.get('passport_issued_by', '_________________________________')}\n"
        f"{user_data.get('passport_issue_date', '___________________________')}"
    )
    cell_right.add_paragraph(passport_text)
    cell_right.add_paragraph(f"\nАдрес: {user_data.get('address', '_____________________________')}")
    
    last_name = user_data.get('last_name', '____________').upper()
    cell_right.add_paragraph(f"\n\n_____________________/{last_name}\n(подпись)")

    # --- Сохранение файла ---
    output_path = os.path.join(DOCUMENTS_PATH, output_filename)
    doc.save(output_path)
    return output_path

# --- Конец кода для замены ---

# Замени свою старую функцию assign_bike_by_number на эту
# --- ИСПРАВЛЕННАЯ ФУНКЦИЯ assign_bike_by_number ---
# Просто замените вашу старую функцию на эту
# Замените вашу старую функцию на эту
import aiosqlite  # Добавьте этот импорт
import sqlite3    # Старый импорт можно пока оставить или убрать
import json
import os
from datetime import datetime

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ assign_bike_by_number НА ЭТУ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ assign_bike_by_number НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ assign_bike_by_number НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ
import random # Убедитесь, что этот импорт есть в начале файла

# Убедитесь, что эти импорты есть в начале вашего файла
import asyncio
import random
import aiosqlite
from datetime import datetime
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes, ConversationHandler

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ assign_bike_by_number НА ЭТУ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ
# Убедитесь, что эти импорты есть в начале вашего файла
import asyncio
import random
import aiosqlite
import os
import json
from datetime import datetime
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ
# ### НОВАЯ, ПОЛНОСТЬЮ ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
# ### ФИНАЛЬНАЯ, ИСПРАВЛЕННАЯ ВЕРСИЯ ###
# ### НОВАЯ, ОБНОВЛЕННАЯ ФУНКЦИЯ ###
# ### ФИНАЛЬНАЯ, ИСПРАВЛЕННАЯ ВЕРСИЯ ###
# main.py

# Убедитесь, что все эти импорты у вас есть в начале файла
import aiosqlite
import json
import os
from datetime import datetime
from telegram import Update, LabeledPrice, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler

# ... (другие ваши импорты и константы)


# ### ПОЛНОСТЬЮ ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ assign_bike_by_number НА ЭТУ ПОЛНУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ assign_bike_by_number НА ЭТУ ПОЛНУЮ И ИСПРАВЛЕННУЮ ВЕРСИЮ

# ### НОВАЯ, ПОЛНОСТЬЮ ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
# Убедитесь, что все эти импорты есть в начале вашего файла
import aiosqlite
import json
import os
from datetime import datetime
import asyncio
import random
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler


# Убедитесь, что все эти переменные и функции доступны в области видимости:
# DB_FILE, ADMIN_IDS, BUYOUT_PLANS, RENTAL_PRICES
# log_bike_action, add_notification
import asyncio # Убедитесь, что этот импорт есть в начале файла
import random  # Этот импорт тоже понадобится
# ШАГ 1: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ

def parse_bike_name_and_vin(full_name: str) -> dict:
    """
    "Умный" парсер: отделяет модель от VIN.
    Пример: "Wenbox U5 12345" -> {'model': 'Wenbox U5', 'vin': '12345'}
    """
    parts = full_name.strip().split(' ', 2)
    
    if len(parts) > 2:
        # Если в названии больше двух слов, например "Liming 2-АКБ ESM123"
        model = f"{parts[0]} {parts[1]}"
        vin = parts[2]
    elif len(parts) == 2:
        # Стандартный случай "Модель VIN"
        model = parts[0]
        vin = parts[1]
    else:
        # Если пробелов нет, используем старый метод поиска префиксов
        vin_starters = ['JL', 'ESM', 'CNHC']
        model = full_name.strip()
        vin = '(не указан)'
        
        full_name_lower = full_name.lower()
        for prefix in vin_starters:
            prefix_lower = prefix.lower()
            if prefix_lower in full_name_lower:
                start_index = full_name_lower.find(prefix_lower)
                model = full_name[:start_index].strip()
                vin = full_name[start_index:].strip()
                if not model:
                    model = vin
                    vin = '(не указан)'
                break
                
    return {'model': model, 'vin': vin}
# Вставьте эту функцию в ваш код, например, после функции assign_bike_by_number
# ### НОВЫЙ КОД: Функция для отправки уведомлений об оплате администраторам ###
async def send_admin_payment_notification(context: ContextTypes.DEFAULT_TYPE, user_name: str, amount: int, description: str, bike_name: str | None = None, owner_name: str | None = None):
    """
    Отправляет уведомление о успешном платеже всем администраторам,
    включая информацию о велосипеде и его владельце.
    """
    user_name_escaped = escape_markdown(user_name, version=2)
    amount_escaped = escape_markdown(str(amount), version=2)
    description_escaped = escape_markdown(description, version=2)

    message_parts = [
        f"✅ *Успешная оплата*",
        f"👤 *Клиент:* {user_name_escaped}",
        f"💰 *Сумма:* {amount_escaped} ₽",
        f"📝 *Назначение:* {description_escaped}"
    ]

    if bike_name:
        parsed_bike = parse_bike_name_and_vin(bike_name)
        bike_info_str = f"🚲 *Велосипед:* {escape_markdown(parsed_bike['model'], 2)} \\({escape_markdown(parsed_bike['vin'], 2)}\\)"
        
        owner_display_name = "Наш"
        if owner_name and owner_name != "Компания":
            owner_display_name = escape_markdown(owner_name, 2)
        
        owner_info_str = f"🏢 *Владелец:* {owner_display_name}"
        
        message_parts.extend(["", bike_info_str, owner_info_str])

    final_message = "\n".join(message_parts)

    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_message(
                chat_id=admin_id,
                text=final_message,
                parse_mode="MarkdownV2"
            )
        except Exception as e:
            logging.error(f"Не удалось отправить уведомление об оплате админу {admin_id}: {e}")


async def _get_bike_and_owner_info(conn: aiosqlite.Connection, bike_id: int) -> tuple[str | None, str | None]:
    """Вспомогательная функция для получения имени велосипеда и его владельца."""
    if not bike_id:
        return None, None
    cursor = await conn.execute(
        """SELECT b.name, u.first_name, u.last_name 
           FROM bikes b 
           LEFT JOIN users u ON b.investor_id = u.id 
           WHERE b.id = ?""",
        (bike_id,)
    )
    data = await cursor.fetchone()
    if not data:
        return "Неизвестный велосипед", "Неизвестно"
    
    bike_name = data['name']
    owner_name = "Компания"
    if data['first_name']:
        owner_name = f"{data['first_name']} {data['last_name'] or ''}".strip()
    
    return bike_name, owner_name
async def animate_payment_message(context: ContextTypes.DEFAULT_TYPE, payment_id: str):
    """
    Асинхронно анимирует сообщение с оплатой, циклически меняя эмодзи.
    Останавливается, когда событие stop_animation_event будет установлено.
    """
    try:
        # Получаем данные, сохраненные при создании платежа
        payment_data = context.bot_data['pending_payments'].get(payment_id)
        if not payment_data:
            logging.warning(f"Анимация для payment_id {payment_id} не может быть запущена: данные не найдены.")
            return

        chat_id = payment_data['user_id']
        message_id = payment_data['animated_message_id']
        animation_sequence = payment_data['animation_sequence']
        stop_event = payment_data['stop_animation_event']
        amount = payment_data['amount']

        # Индекс текущего кадра анимации
        frame_index = 0

        # Цикл работает, пока не будет подан сигнал к остановке
        while not stop_event.is_set():
            # Получаем текущий кадр (набор эмодзи) и склеиваем в строку
            current_frame_emojis = animation_sequence[frame_index]
            animation_text = " ".join(current_frame_emojis)

            # Формируем полный текст сообщения
            message_text = f"Нажмите кнопку для оплаты {amount} ₽\n\n{animation_text}"

            try:
                # Редактируем сообщение, чтобы показать новый кадр
                await context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=message_id,
                    text=message_text,
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("💳 Оплатить", url=payment_data['url'])]])
                )
            except Exception as e:
                # Если сообщение не найдено (удалено пользователем), просто останавливаем анимацию
                logging.info(f"Сообщение для анимации {message_id} не найдено, остановка. Ошибка: {e}")
                stop_event.set()
                break

            # Переключаемся на следующий кадр, зацикливая анимацию
            frame_index = (frame_index + 1) % len(animation_sequence)

            # Пауза между кадрами
            await asyncio.sleep(1.2) # 1.2 секунды

    except Exception as e:
        logging.error(f"Критическая ошибка в цикле анимации для payment_id {payment_id}: {e}", exc_info=True)
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ process_yookassa_success НА ЭТУ НОВУЮ ВЕРСИЮ
# Убедитесь, что эти импорты есть в начале вашего файла
import logging
import sqlite3
from datetime import datetime, timedelta
from telegram import Update
from telegram.ext import ContextTypes

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ process_yookassa_success НА ЭТУ

# Убедитесь, что эти импорты есть в начале вашего файла
import logging
import sqlite3
from datetime import datetime, timedelta
from telegram import Update
from telegram.ext import ContextTypes

# --- Полностью исправленная функция ---

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ АСИНХРОННУЮ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ АСИНХРОННУЮ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ПОЛНОСТЬЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
# ### НОВАЯ, ПОЛНОСТЬЮ АСИНХРОННАЯ ФУНКЦИЯ ###
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ process_successful_payment НА ЭТУ ПОЛНОСТЬЮ

import aiosqlite # Убедитесь, что этот импорт есть в начале файла
# =============================================================================
# УНИВЕРСАЛЬНЫЙ ОБРАБОТЧИК УСПЕШНЫХ ПЛАТЕЖЕЙ (ЗАМЕНИТЕ ВСЕ СТАРЫЕ ВЕРСИИ)
# =============================================================================
import aiosqlite
from datetime import datetime, timedelta

# =============================================================================
# УНИВЕРСАЛЬНЫЙ ОБРАБОТЧИК УСПЕШНЫХ ПЛАТЕЖЕЙ (ЗАМЕНИТЕ ВСЕ СТАРЫЕ ВЕРСИИ)
# =============================================================================

# ### ОБНОВЛЕННАЯ ФУНКЦИЯ: process_successful_payment с уведомлениями для админов ###

# ### ПОЛНАЯ ИСПРАВЛЕННАЯ ФУНКЦИЯ process_successful_payment ###

async def _get_bike_and_owner_info(conn, bike_id):
    """Получает название велосипеда и имя владельца по bike_id"""
    cursor = await conn.execute("""
        SELECT b.name as bike_name, 
               COALESCE(u.first_name || ' ' || u.last_name, u.username, 'Неизвестный владелец') as owner_name 
        FROM bikes b 
        LEFT JOIN users u ON b.owner_id = u.id 
        WHERE b.id = ?
    """, (bike_id,))
    result = await cursor.fetchone()
    if result:
        return result['bike_name'], result['owner_name']
    return "Неизвестный велосипед", "Неизвестный владелец"


import json
import time
from uuid import uuid4
from datetime import datetime, timedelta

import json
import time
from uuid import uuid4
from datetime import datetime, timedelta

# ────────────────────────────────────────────────────────────────────────────────
# ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ (НОВЫЕ / ИЗМЕНЁННЫЕ)
# ────────────────────────────────────────────────────────────────────────────────

async def _is_unlimited_battery(conn, bike_id: int) -> bool:
    """
    Возвращает True, если товар с данным bike_id помечен как безлимитный (is_unlimited=1).
    Для таких АКБ мы никогда не меняем available/owner_id, чтобы они всегда были доступны в каталоге.
    """
    cur = await conn.execute("SELECT is_unlimited FROM bikes WHERE id=?", (bike_id,))
    row = await cur.fetchone()
    return bool(row and row["is_unlimited"])

def _battery_model_from_name(name: str) -> str:
    """Определяет модель АКБ по названию ('60V21Ah' или '60V30Ah')."""
    return "60V21Ah" if "60V21Ah" in name else "60V30Ah"


# ────────────────────────────────────────────────────────────────────────────────
# ОСНОВНАЯ ФУНКЦИЯ С ПОДРОБНЫМ ЛОГИРОВАНИЕМ И ПОДДЕРЖКОЙ АКБ-БЕЗЛИМИТ
# ────────────────────────────────────────────────────────────────────────────────

async def process_successful_payment(
    context: ContextTypes.DEFAULT_TYPE,
    user_id: int,
    payload: str,
    amount_rub: int,
    discount_id_to_use: int | None = None,
    update: Update | None = None,
):
    """
    Универсальная обработка ВСЕХ успешных платежей:
    - аренда/выкуп велосипедов и АКБ (в т.ч. безлимитных доп АКБ),
    - последующие взносы/досрочное погашение,
    - продление аренды,
    - ремонт/штрафы.
    Везде есть commit(); подробные логи: кейс, снапшоты до/после, вычисленные даты, уведомления.
    """

    pay_evt_id = str(uuid4())[:8]  # корреляционный id для всей операции
    t0 = time.time()

    def _log(level: str, msg: str, **kv):
        lvl = getattr(logging, level.upper(), logging.INFO)
        base = {
            "pay_evt_id": pay_evt_id,
            "user_id": user_id,
            "payload": payload,
            "amount_rub": amount_rub,
        }
        base.update(kv)
        logging.log(lvl, f"[pay={pay_evt_id}] {msg} :: {json.dumps(base, ensure_ascii=False, default=str)}")

    async def _fetch_one_dict(conn, query, params=()):
        cur = await conn.execute(query, params)
        row = await cur.fetchone()
        return dict(row) if row else None

    async def _snapshot(conn, table: str, id_field: str, id_value, columns: list[str] | None = None):
        cols = ", ".join(columns) if columns else "*"
        return await _fetch_one_dict(conn, f"SELECT {cols} FROM {table} WHERE {id_field}=?", (id_value,))

    async def send_response(text: str, **kwargs):
        try:
            if update and update.effective_message:
                await update.effective_message.reply_text(text, **kwargs)
            else:
                await context.bot.send_message(chat_id=user_id, text=text, **kwargs)
            _log("info", "message_to_user_sent", text=text)
        except Exception as e:
            _log("error", "message_to_user_failed", error=str(e), text=text)

    conn = None
    _log("info", "payment_processing_start")

    try:
        async with aiosqlite.connect(DB_FILE, timeout=20) as conn:
            conn.row_factory = aiosqlite.Row
            await conn.execute("BEGIN")
            _log("debug", "tx_begin")

            # 0) Скидка (если была)
            if discount_id_to_use:
                before = await _snapshot(conn, "discounts", "id", discount_id_to_use, ["id", "is_used"])
                await conn.execute("UPDATE discounts SET is_used=1 WHERE id=?", (discount_id_to_use,))
                after = await _snapshot(conn, "discounts", "id", discount_id_to_use, ["id", "is_used"])
                _log("info", "discount_consumed", before=before, after=after)

            user_name_formatted = await get_user_info_for_notification(user_id, conn)
            _log("debug", "loaded_user_for_notifications", user_name=user_name_formatted)

            # ────────────────────────────────────────────────────────────────────
            # КЕЙСЫ
            # ────────────────────────────────────────────────────────────────────

            # 1) Аренда велосипеда
            if payload.startswith("rental_payment_"):
                case = "rental_payment_bike"
                booking_id = int(payload.split("_")[2])
                _log("info", "case_detected", case=case, booking_id=booking_id)

                before_booking = await _snapshot(conn, "bookings", "id", booking_id)
                await conn.execute("UPDATE bookings SET status='rented' WHERE id=?", (booking_id,))
                after_booking = await _snapshot(conn, "bookings", "id", booking_id)

                cur = await conn.execute("SELECT bike_id FROM bookings WHERE id=?", (booking_id,))
                bike_id = (await cur.fetchone())["bike_id"]

                before_bike = await _snapshot(conn, "bikes", "id", bike_id, ["id", "available", "owner_id", "name"])
                # велосипеды НЕ безлимитные → делаем недоступным
                await conn.execute("UPDATE bikes SET available=0 WHERE id=?", (bike_id,))
                after_bike = await _snapshot(conn, "bikes", "id", bike_id, ["id", "available", "owner_id", "name"])

                bike_name, owner_name = await _get_bike_and_owner_info(conn, bike_id)
                await log_bike_action(conn, bike_id, user_id, "Оплата аренды", f"Заявка #{booking_id}", amount=amount_rub)

                await conn.commit()
                _log("info", "tx_commit", case=case,
                     booking_before=before_booking, booking_after=after_booking,
                     bike_before=before_bike, bike_after=after_bike)

                await send_response(f"✅ Оплата за аренду велосипеда «{bike_name}» прошла успешно!")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, "Аренда велосипеда",
                                                         bike_name=bike_name, owner_name=owner_name)
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 2) Выкуп велосипеда (первый взнос)
            elif payload.startswith("buyout_payment_"):
                case = "buyout_bike_first"
                booking_id = int(payload.split("_")[2])
                _log("info", "case_detected", case=case, booking_id=booking_id)

                row = await _fetch_one_dict(conn, """
                    SELECT b.bike_id, bk.name AS bike_name, bk.buyout_period_days,
                           bk.buyout_total_payments, bk.buyout_payment_amount
                    FROM bookings b JOIN bikes bk ON b.bike_id=bk.id WHERE b.id=?
                """, (booking_id,))
                if not row:
                    raise ValueError(f"Не найдена сделка #{booking_id}")
                bike_id = row["bike_id"]
                bike_name = row["bike_name"]
                period_days = int(row["buyout_period_days"] or 0)
                if period_days <= 0:
                    raise ValueError(f"Для «{bike_name}» не настроен план выкупа.")
                next_date = (datetime.now() + timedelta(days=period_days)).strftime("%d.%m.%Y")

                before_booking = await _snapshot(conn, "bookings", "id", booking_id)
                await conn.execute(
                    "UPDATE bookings SET status='rented', payments_made=1, next_payment_date=? WHERE id=?",
                    (next_date, booking_id),
                )
                after_booking = await _snapshot(conn, "bookings", "id", booking_id)

                before_bike = await _snapshot(conn, "bikes", "id", bike_id, ["id", "available"])
                await conn.execute("UPDATE bikes SET available=0 WHERE id=?", (bike_id,))
                after_bike = await _snapshot(conn, "bikes", "id", bike_id, ["id", "available"])

                await log_bike_action(
                    conn, bike_id, user_id, "Выкуп (1-й взнос)",
                    f"План: {row['buyout_total_payments']} пл. по {row['buyout_payment_amount']} ₽",
                    amount=amount_rub
                )

                await conn.commit()
                _log("info", "tx_commit", case=case,
                     booking_before=before_booking, booking_after=after_booking,
                     bike_before=before_bike, bike_after=after_bike,
                     next_payment_date=next_date)

                _, owner_name = await _get_bike_and_owner_info(conn, bike_id)
                await send_response(f"✅ Первый взнос за выкуп «{bike_name}» принят! Следующий платеж до {next_date}.")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, "Первый взнос за выкуп",
                                                         bike_name=bike_name, owner_name=owner_name)
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 3) Быстрая аренда доп. АКБ (7 дней, безлимит поддержан)
            elif payload.startswith("quick_rent_akb_"):
                case = "quick_rent_akb"
                product_id = int(payload.split("_")[3])
                _log("info", "case_detected", case=case, product_id=product_id)

                cur = await conn.execute("SELECT name FROM bikes WHERE id=?", (product_id,))
                name = (await cur.fetchone())["name"]

                start = datetime.now()
                end = start + timedelta(days=7)
                await conn.execute(
                    "INSERT INTO bookings (user_id, bike_id, booking_date, end_date, status, booking_type) "
                    "VALUES (?, ?, ?, ?, 'rented', 'rent')",
                    (user_id, product_id, start.strftime("%d.%m.%Y"), end.strftime("%d.%m.%Y")),
                )

                # если это НЕ безлимитная АКБ — делаем недоступной
                if not await _is_unlimited_battery(conn, product_id):
                    before_bike = await _snapshot(conn, "bikes", "id", product_id, ["id", "available"])
                    await conn.execute("UPDATE bikes SET available=0 WHERE id=?", (product_id,))
                    after_bike = await _snapshot(conn, "bikes", "id", product_id, ["id", "available"])
                else:
                    before_bike = after_bike = await _snapshot(conn, "bikes", "id", product_id, ["id", "available", "is_unlimited"])

                await log_bike_action(conn, product_id, user_id, "Аренда доп. АКБ", "Срок: 7 дней", amount=amount_rub)
                await conn.commit()
                _log("info", "tx_commit", case=case,
                     bike_before=before_bike, bike_after=after_bike,
                     rental_period={"from": start.strftime("%d.%m.%Y"), "to": end.strftime("%d.%m.%Y")})

                await send_response(f"✅ Аренда «{name}» оформлена до {end.strftime('%d.%m.%Y')}!")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, f"Аренда доп. АКБ «{name}»")
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 4) Аренда АКБ (по прайсу, безлимит поддержан)
            elif payload.startswith("rent_battery_"):
                case = "rent_battery"
                product_id = int(payload.split("_")[2])
                _log("info", "case_detected", case=case, product_id=product_id)

                cur = await conn.execute("SELECT name FROM bikes WHERE id=?", (product_id,))
                name = (await cur.fetchone())["name"]
                model = _battery_model_from_name(name)
                plan = BATTERY_RENTAL_PRICES.get(model)
                start = datetime.now()
                end = start + timedelta(days=int(plan["initial_months"]) * 30)

                await conn.execute(
                    "INSERT INTO bookings (user_id, bike_id, booking_date, end_date, status, booking_type) "
                    "VALUES (?, ?, ?, ?, 'rented', 'rent')",
                    (user_id, product_id, start.strftime("%d.%m.%Y"), end.strftime("%d.%m.%Y")),
                )

                # если НЕ безлимит — делаем недоступной; иначе только выставим type='battery'
                if not await _is_unlimited_battery(conn, product_id):
                    before_bike = await _snapshot(conn, "bikes", "id", product_id, ["id", "available", "type"])
                    await conn.execute("UPDATE bikes SET available=0, type='battery' WHERE id=?", (product_id,))
                    after_bike = await _snapshot(conn, "bikes", "id", product_id, ["id", "available", "type"])
                else:
                    before_bike = await _snapshot(conn, "bikes", "id", product_id, ["id", "available", "type"])
                    await conn.execute("UPDATE bikes SET type='battery' WHERE id=?", (product_id,))
                    after_bike = await _snapshot(conn, "bikes", "id", product_id, ["id", "available", "type"])

                await log_bike_action(conn, product_id, user_id, "Аренда АКБ", "Первоначальный платеж", amount=amount_rub)
                await conn.commit()
                _log("info", "tx_commit", case=case, bike_before=before_bike, bike_after=after_bike)

                await send_response(f"✅ Аренда аккумулятора «{name}» оформлена до {end.strftime('%d.%m.%Y')}!")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, f"Аренда аккумулятора «{name}»")
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 5) Продление аренды (любой товар)
            elif payload.startswith("prolong_"):
                case = "prolong"
                _, booking_id_str, add_days_str = payload.split("_")
                booking_id, add_days = int(booking_id_str), int(add_days_str)
                _log("info", "case_detected", case=case, booking_id=booking_id, add_days=add_days)

                info = await _fetch_one_dict(conn, "SELECT end_date, bike_id FROM bookings WHERE id=?", (booking_id,))
                cur_end = datetime.strptime(info["end_date"], "%d.%m.%Y")
                new_end = (cur_end + timedelta(days=add_days)).strftime("%d.%m.%Y")

                before_booking = await _snapshot(conn, "bookings", "id", booking_id, ["id", "end_date"])
                await conn.execute("UPDATE bookings SET end_date=? WHERE id=?", (new_end, booking_id))
                after_booking = await _snapshot(conn, "bookings", "id", booking_id, ["id", "end_date"])

                bike_name, owner_name = await _get_bike_and_owner_info(conn, info["bike_id"])
                await log_bike_action(conn, info["bike_id"], user_id, "Продление аренды", f"Срок +{add_days} дней", amount=amount_rub)
                await conn.commit()
                _log("info", "tx_commit", case=case, booking_before=before_booking, booking_after=after_booking)

                await send_response(f"✅ Аренда продлена до {new_end}!")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, f"Продление аренды на {add_days} дн.",
                                                         bike_name=bike_name, owner_name=owner_name)
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 6) Индивидуальная сделка
            elif payload.startswith("custom_payment_"):
                case = "custom_payment"
                booking_id = int(payload.split("_")[2])
                _log("info", "case_detected", case=case, booking_id=booking_id)

                row = await _fetch_one_dict(conn, "SELECT bike_id FROM bookings WHERE id=?", (booking_id,))
                bike_id = row["bike_id"]

                before_booking = await _snapshot(conn, "bookings", "id", booking_id, ["id", "status"])
                await conn.execute("UPDATE bookings SET status='rented' WHERE id=?", (booking_id,))
                after_booking = await _snapshot(conn, "bookings", "id", booking_id, ["id", "status"])

                # индивидуальные сделки — по факту конкретный предмет (не безлимит)
                before_bike = await _snapshot(conn, "bikes", "id", bike_id, ["id", "available"])
                await conn.execute("UPDATE bikes SET available=0 WHERE id=?", (bike_id,))
                after_bike = await _snapshot(conn, "bikes", "id", bike_id, ["id", "available"])

                cur = await conn.execute("SELECT name FROM bikes WHERE id=?", (bike_id,))
                bike_name = (await cur.fetchone())["name"]

                await log_bike_action(conn, bike_id, user_id, "Оплата (индивид.)", f"Заявка #{booking_id}", amount=amount_rub)
                await conn.commit()
                _log("info", "tx_commit", case=case,
                     booking_before=before_booking, booking_after=after_booking,
                     bike_before=before_bike, bike_after=after_bike, bike_name=bike_name)

                await send_response(f"✅ Оплата по индивидуальной сделке за «{bike_name}» прошла успешно!")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, f"Индивидуальная сделка «{bike_name}»")
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 7) Выкуп АКБ (первый взнос) — фиксируем план в bikes, но безлимит не трогаем по available/owner
            elif payload.startswith("buyout_battery_"):
                case = "buyout_battery_first"
                parts = payload.split("_")
                product_id = int(parts[2])
                plan_key = "_".join(parts[3:-1])
                _log("info", "case_detected", case=case, product_id=product_id, plan_key=plan_key)

                cur = await conn.execute("SELECT name FROM bikes WHERE id=?", (product_id,))
                name = (await cur.fetchone())["name"]
                model = _battery_model_from_name(name)
                plan = BATTERY_BUYOUT_PLANS[model]["plans"][plan_key]  # keys: payment, count, period_days

                # Сохраняем план на самой АКБ (для удобного JOIN в последующих платежах)
                # available ставим 0 ТОЛЬКО если не безлимит.
                before_bike = await _snapshot(conn, "bikes", "id", product_id,
                                              ["id", "type", "available", "is_unlimited",
                                               "buyout_total_payments", "buyout_payment_amount", "buyout_period_days"])

                await conn.execute("""
                  UPDATE bikes
                  SET type='battery',
                      buyout_total_payments=?,
                      buyout_payment_amount=?,
                      buyout_period_days=?,
                      available=CASE WHEN is_unlimited=1 THEN available ELSE 0 END
                  WHERE id=?""",
                  (int(plan["count"]), int(plan["payment"]), int(plan["period_days"]), product_id)
                )

                after_bike = await _snapshot(conn, "bikes", "id", product_id,
                                             ["id", "type", "available", "is_unlimited",
                                              "buyout_total_payments", "buyout_payment_amount", "buyout_period_days"])

                start = datetime.now()
                next_date = (start + timedelta(days=int(plan["period_days"]))).strftime("%d.%m.%Y")
                await conn.execute(
                    "INSERT INTO bookings (user_id, bike_id, booking_date, status, booking_type, payment_plan_key, payments_made, next_payment_date) "
                    "VALUES (?, ?, ?, 'rented', 'buyout', ?, 1, ?)",
                    (user_id, product_id, start.strftime("%d.%m.%Y"), plan_key, next_date),
                )

                await log_bike_action(conn, product_id, user_id, "Выкуп АКБ (1-й взнос)", f"План: {plan['label']}", amount=amount_rub)
                await conn.commit()
                _log("info", "tx_commit", case=case, bike_before=before_bike, bike_after=after_bike, next_payment_date=next_date)

                await send_response(f"✅ Рассрочка на АКБ «{name}» оформлена! Следующий платеж до {next_date}.")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, f"Первый взнос по АКБ «{name}»")
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 8) Оплата ремонта
            elif payload.startswith("repair_payment_"):
                case = "repair_payment"
                request_id = int(payload.split("_")[2])
                _log("info", "case_detected", case=case, request_id=request_id)

                before = await _snapshot(conn, "repair_requests", "id", request_id, ["id", "status"])
                await conn.execute("UPDATE repair_requests SET status='oplacheno' WHERE id=?", (request_id,))
                after = await _snapshot(conn, "repair_requests", "id", request_id, ["id", "status"])

                cur = await conn.execute(
                    "SELECT rr.bike_id, b.name AS bike_name FROM repair_requests rr JOIN bikes b ON rr.bike_id=b.id WHERE rr.id=?",
                    (request_id,),
                )
                r = await cur.fetchone()
                bike_id = r["bike_id"] if r else None
                bike_name = r["bike_name"] if r else "Неизвестно"

                await log_bike_action(conn, bike_id, user_id, "Оплата ремонта", f"Заявка #{request_id}", amount=amount_rub)
                await conn.commit()
                _log("info", "tx_commit", case=case, request_before=before, request_after=after, bike_id=bike_id)

                await send_response(f"✅ Оплата за ремонт (заявка #{request_id}) прошла успешно!")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, f"Оплата ремонта «{bike_name}» (заявка #{request_id})")
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 9) Оплата штрафа
            elif payload.startswith("fine_"):
                case = "fine_payment"
                fine_id = int(payload.split("_")[1])
                _log("info", "case_detected", case=case, fine_id=fine_id)

                payment_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                before = await _snapshot(conn, "fines", "id", fine_id, ["id", "status", "payment_date"])
                await conn.execute("UPDATE fines SET status='paid', payment_date=? WHERE id=?", (payment_date, fine_id))
                after = await _snapshot(conn, "fines", "id", fine_id, ["id", "status", "payment_date"])

                await log_bike_action(conn, None, user_id, "Оплата штрафа", f"Оплачен штраф #{fine_id}", amount=amount_rub)
                await conn.commit()
                _log("info", "tx_commit", case=case, fine_before=before, fine_after=after)

                await send_response(f"✅ Штраф #{fine_id} оплачен.")
                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, f"Оплата штрафа #{fine_id}")
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            # 10) Следующий взнос / Полный выкуп (универсально для вело и АКБ; учитывает безлимит)
            elif payload.startswith("installment_") or payload.startswith("full_buyout_"):
                is_full_buyout = payload.startswith("full_buyout_")
                case = "full_buyout" if is_full_buyout else "installment"
                booking_id = int(payload.split("_")[2 if is_full_buyout else 1])
                _log("info", "case_detected", case=case, booking_id=booking_id)

                d = await _fetch_one_dict(conn, """
                    SELECT b.bike_id, IFNULL(b.payments_made, 0) AS payments_made,
                           bk.name AS item_name, bk.type AS item_type, bk.is_unlimited,
                           bk.buyout_total_payments, bk.buyout_payment_amount, bk.buyout_period_days
                    FROM bookings b JOIN bikes bk ON b.bike_id=bk.id
                    WHERE b.id=?
                """, (booking_id,))
                if not d:
                    raise ValueError("Запись о рассрочке не найдена.")

                bike_id = d["bike_id"]
                payments_made = int(d["payments_made"] or 0)
                total_payments = int(d["buyout_total_payments"] or 0)
                period_days = int(d["buyout_period_days"] or 0)
                item_name = d["item_name"]
                plan_type_str = "Велосипед" if d["item_type"] == "bike" else "АКБ"
                is_unlimited = bool(d["is_unlimited"])

                if not (total_payments and period_days):
                    raise ValueError(f"Для товара «{item_name}» (ID {bike_id}) не настроен план выкупа.")

                before_booking = await _snapshot(conn, "bookings", "id", booking_id,
                                                 ["id", "status", "payments_made", "next_payment_date"])
                before_bike = await _snapshot(conn, "bikes", "id", bike_id, ["id", "available", "owner_id", "is_unlimited"])

                if is_full_buyout:
                    await conn.execute("UPDATE bookings SET status='completed', next_payment_date=NULL WHERE id=?", (booking_id,))
                    if not is_unlimited:
                        await conn.execute("UPDATE bikes SET available=0, owner_id=? WHERE id=?", (user_id, bike_id))
                    action = "Досрочное погашение"
                    details = "Рассрочка полностью погашена"
                else:
                    new_payments = payments_made + 1
                    if new_payments >= total_payments:
                        await conn.execute(
                            "UPDATE bookings SET status='completed', payments_made=?, next_payment_date=NULL WHERE id=?",
                            (new_payments, booking_id),
                        )
                        if not is_unlimited:
                            await conn.execute("UPDATE bikes SET available=0, owner_id=? WHERE id=?", (user_id, bike_id))
                        action = f"Завершение выкупа ({plan_type_str})"
                        details = "Внесен последний платеж"
                    else:
                        next_date = (datetime.now() + timedelta(days=period_days)).strftime("%d.%m.%Y")
                        await conn.execute(
                            "UPDATE bookings SET payments_made=?, next_payment_date=? WHERE id=?",
                            (new_payments, next_date, booking_id),
                        )
                        action = f"Платеж по выкупу ({plan_type_str})"
                        details = f"Внесен платеж {new_payments}/{total_payments}"

                after_booking = await _snapshot(conn, "bookings", "id", booking_id,
                                                ["id", "status", "payments_made", "next_payment_date"])
                after_bike = await _snapshot(conn, "bikes", "id", bike_id, ["id", "available", "owner_id", "is_unlimited"])

                await log_bike_action(conn, bike_id, user_id, action, details, amount=amount_rub)
                await conn.commit()
                _log("info", "tx_commit", case=case,
                     booking_before=before_booking, booking_after=after_booking,
                     bike_before=before_bike, bike_after=after_bike,
                     action=action, details=details)

                bike_name, owner_name = await _get_bike_and_owner_info(conn, bike_id)
                # Ответ пользователю + уведомление админу
                if is_full_buyout:
                    await send_response("🎉 Поздравляем! Вы досрочно и полностью выкупили товар! Теперь он ваш.")
                    note = f"Досрочное погашение за «{item_name}» (ВЫКУПЛЕН)"
                else:
                    if after_booking["status"] == "completed":
                        await send_response(f"🎉 Поздравляем! Вы полностью выкупили товар «{item_name}»! Теперь он ваш.")
                        note = f"Последний платеж по рассрочке за «{item_name}» (ВЫКУПЛЕН)"
                    else:
                        await send_response(
                            f"✅ Платеж принят! Внесено {after_booking['payments_made']} из {total_payments}. "
                            f"Следующий платеж до {after_booking['next_payment_date']}."
                        )
                        note = f"Платеж по рассрочке за «{item_name}» ({after_booking['payments_made']}/{total_payments})"

                try:
                    await send_admin_payment_notification(context, user_name_formatted, amount_rub, note,
                                                         bike_name=bike_name, owner_name=owner_name)
                except Exception as e:
                    _log("error", "admin_notification_failed", case=case, error=str(e))

            else:
                _log("warning", "unknown_payload_type")
                await conn.commit()
                await send_response("✅ Оплата получена. Тип операции определён как общий платёж.")

    except Exception as e:
        _log("error", "critical_error", error=str(e))
        if conn:
            try:
                await conn.rollback()
                _log("info", "tx_rollback_done")
            except Exception as er:
                _log("error", "tx_rollback_failed", error=str(er))
        await send_response("❌ Произошла критическая ошибка при обработке вашего платежа. Пожалуйста, свяжитесь с поддержкой.")
    finally:
        _log("info", "payment_processing_end", elapsed_ms=int((time.time() - t0) * 1000))



# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ process_successful_payment НА ЭТУ ПОЛНУЮ ВЕРСИЮ

import aiosqlite # Убедитесь, что этот импорт есть в начале файла

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ process_successful_payment НА ЭТУ ПОЛНУЮ И ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ

import aiosqlite # Убедитесь, что этот импорт есть в начале файла

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ПОЛНУЮ И ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ
import aiosqlite # Убедитесь, что этот импорт есть в начале файла

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ПОЛНУЮ И ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ
import aiosqlite # Убедитесь, что этот импорт есть в начале файла



    # Соединение закрывается автоматически благодаря `with sqlite3.connect(...)`
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ confirm_agreement НА ЭТУ:
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ confirm_agreement НА ЭТУ:
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ confirm_agreement НА ЭТУ:

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ confirm_agreement НА ЭТУ:
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ confirm_agreement НА ЭТУ

# corrected_code.py

# main.py

# Убедитесь, что импорт aiosqlite у вас есть
import aiosqlite

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ
# Убедитесь, что все эти импорты есть в начале вашего файла
import aiosqlite
import asyncio
import logging
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
import sqlite3 # Для обработки исключений

# ... (остальные ваши импорты и константы)

async def confirm_agreement(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Создает заявку на аренду.
    ИСПРАВЛЕНО: Использует единую асинхронную транзакцию для предотвращения блокировки БД.
    """
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    rental_data = context.user_data.get('rental_data')
    if not rental_data:
        await query.message.edit_text("🚫 Ошибка: данные аренды не найдены. Начните заново.")
        return

    bike_id = rental_data['bike_id']
    is_custom_deal = (bike_id == 999) # Предполагаем, что 999 - это ID для кастомной сделки
    
    try:
        # --- НАЧАЛО ИСПРАВЛЕНИЙ ---
        # Открываем ОДНО соединение для ВСЕХ операций с БД в этой функции
        async with aiosqlite.connect(DB_FILE, timeout=15) as conn:
            conn.row_factory = aiosqlite.Row
            
            # Начинаем транзакцию, чтобы все операции были атомарными
            await conn.execute("BEGIN")

            start_date = datetime.now().strftime('%d.%m.%Y')
            end_date = (datetime.now() + timedelta(days=rental_data['days'])).strftime('%d.%m.%Y')

            # 1. Вставляем бронирование в БД
            cursor = await conn.execute(
                """INSERT INTO bookings (user_id, bike_id, booking_date, end_date, status, booking_type)
                   VALUES (?, ?, ?, ?, 'paid_unassigned', 'rent')""",
                (user_id, bike_id, start_date, end_date)
            )
            booking_id = cursor.lastrowid
            
            # 2. Получаем данные пользователя для уведомления (в той же транзакции)
            user_cursor = await conn.execute("SELECT first_name, last_name, username FROM users WHERE id=?", (user_id,))
            user_db_info = await user_cursor.fetchone()
            
            # 3. Завершаем транзакцию
            await conn.commit()
        # --- КОНЕЦ ИСПРАВЛЕНИЙ ---

        # Если мы дошли до сюда, значит запись в БД прошла успешно
        
        await query.message.edit_text(
            "✅ Ваша заявка принята!\n\n"
            "Пожалуйста, подождите. Администратор свяжется с вами для подтверждения деталей и выставления счета. 🕒"
        )
        
        user_name_raw = f"{user_db_info['first_name']} {user_db_info['last_name'] or ''} (@{user_db_info['username'] or 'no_username'})"
        user_name_escaped = escape_markdown(user_name_raw, version=2)
        days_escaped = escape_markdown(str(rental_data['days']), version=2)

        # Формируем уведомление для админа с правильным именем
        if is_custom_deal:
            admin_notification = (
                f"🚨 *Новая заявка на ИНДИВИДУАЛЬНУЮ АРЕНДУ\\!*\n\n"
                f"👤 *Клиент:* {user_name_escaped}\n"
                f"⏳ *Желаемый срок:* {days_escaped} дней\n\n"
                f"❗️*Требуется ручная обработка\\!* Нажмите, чтобы назначить сделку и выставить счет\\."
            )
            keyboard = [[InlineKeyboardButton("✍️ Обработать индивидуальную заявку", callback_data=f"assign_{booking_id}")]]
        else:
            bike_name_escaped = escape_markdown(rental_data['bike_name'], version=2)
            admin_notification = (
                f"🚨 *Новая заявка на АРЕНДУ\\!*\n\n"
                f"👤 *Клиент:* {user_name_escaped}\n"
                f"🚲 *Модель:* {bike_name_escaped}\n"
                f"⏳ *Срок:* {days_escaped} дней\n\n"
                f"Нажмите, чтобы назначить велосипед и выставить счет:"
            )
            keyboard = [[InlineKeyboardButton("✍️ Обработать заявку", callback_data=f"assign_{booking_id}")]]

        # Отправляем уведомления всем администраторам
        for admin_id in ADMIN_IDS:
            try:
                await context.bot.send_message(
                    admin_id, admin_notification,
                    parse_mode="MarkdownV2",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            except Exception as e:
                logger.warning(f"Не удалось отправить уведомление админу {admin_id}: {e}")

    except sqlite3.OperationalError as e:
        if "database is locked" in str(e):
            logger.error(f"БАЗА ДАННЫХ ЗАБЛОКИРОВАНА при создании заявки для user {user_id}. Повторная попытка...")
            await query.message.edit_text("⏳ Сервер немного перегружен, повторяю ваш запрос...")
            await asyncio.sleep(1.5)  # Даем базе "отдышаться"
            await confirm_agreement(update, context) # Рекурсивный вызов для повторной попытки
        else:
            logger.error(f"Ошибка БД в confirm_agreement для user {user_id}: {e}", exc_info=True)
            await query.message.edit_text("🚫 Произошла ошибка базы данных при создании заявки.")
            
    except Exception as e:
        logger.error(f"Общая ошибка в confirm_agreement для user {user_id}: {e}", exc_info=True)
        await query.message.edit_text("🚫 Произошла системная ошибка при создании заявки.")
# ДОБАВЬТЕ ЭТОТ БЛОК КОДА В ВАШ ПРОЕКТ
# Он содержит все необходимые функции для диалога

# Определяем состояния




def get_buyout_plans_with_gemini(deal_description: str) -> dict | None:
    """
    Отправляет описание комплекта в Gemini и просит сгенерировать
    несколько планов рассрочки в формате JSON.
    """
    try:
        model = genai.GenerativeModel('gemini-2.5-flash-lite')

        prompt = f"""
        Проанализируй описание комплекта для курьера: "{deal_description}".
        Это может быть электровелосипед, аккумуляторы или и то, и другое.
        Примерная рыночная стоимость такого комплекта около 80,000 - 120,000 рублей.

        Твоя задача - сгенерировать 3-4 варианта плана рассрочки (выкупа) для этого комплекта.
        Верни результат СТРОГО в формате JSON. Ответ должен быть только чистым JSON объектом,
        без лишних слов, комментариев или ```json ``` оберток.

        Ключами в JSON должны быть короткие идентификаторы (например, "plan_1", "plan_2"),
        а значениями - словари со следующими ключами:
        - "label": Короткое и понятное описание для кнопки (например, "3 мес / 16000 ₽").
        - "full_label": Полное описание для подтверждения (например, "3 месяца: 7 платежей по 16 000 ₽").
        - "first_payment": Сумма первого взноса (число).
        - "total_payments": Общее количество платежей (число).
        - "period_days": Периодичность платежей в днях (30 для месяца, 14 для 2 недель).

        Пример твоего идеального ответа:
        {{
            "plan_1": {{
                "label": "3 мес / 16000 ₽",
                "full_label": "3 месяца: 7 платежей по 16 000 ₽ (раз в 2 недели)",
                "first_payment": 16000,
                "total_payments": 7,
                "period_days": 14
            }},
            "plan_2": {{
                "label": "4 мес / 21000 ₽",
                "full_label": "4 месяца: 5 платежей по 21 000 ₽ (раз в месяц)",
                "first_payment": 21000,
                "total_payments": 5,
                "period_days": 30
            }}
        }}
        """

        response = model.generate_content(prompt, stream=False)
        response.resolve()

        cleaned_response_text = response.text.strip().replace("`", "")
        if cleaned_response_text.lower().startswith("json"):
             cleaned_response_text = cleaned_response_text[4:].strip()

        logger.info(f"Получены планы выкупа от Gemini: {cleaned_response_text}")
        data = json.loads(cleaned_response_text)

        if isinstance(data, dict) and all(isinstance(v, dict) for v in data.values()):
            return data
        else:
            logger.error(f"Ответ от Gemini (планы выкупа) имеет неверную структуру: {data}")
            return None

    except Exception as e:
        logger.error(f"Ошибка при генерации планов выкупа с Gemini: {e}", exc_info=True)
        return None

# Замените старые состояния на этот новый, более подробный список
from passport_recognition_gemini import get_buyout_plans_with_gemini

# Определяем состояния для нового диалога
(
    DEAL_SELECT_USER, DEAL_ENTER_BIKE_DESC, DEAL_SELECT_BATTERY_COUNT,
    DEAL_ENTER_BATTERY_NUMS, DEAL_SELECT_TYPE,
    DEAL_RENT_DAYS, DEAL_RENT_PRICE,
    DEAL_SELECT_BUYOUT_PLAN,
    DEAL_CONFIRM
) = range(200, 209)

# ID "виртуального" товара, который мы создали в БД
VIRTUAL_BIKE_ID = 999


# Импортируем новую функцию из другого файла
from passport_recognition_gemini import get_buyout_plans_with_gemini



# ==============================================================================
# КОНЕЦ БЛОКА ПОЛНОЙ ЗАМЕНЫ
# ==============================================================================




# Убедитесь, что все эти импорты есть в начале вашего файла
import json
import os
import asyncio
import random
import aiosqlite
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler




async def electrobike_cancel_rental(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Отмена аренды и возврат в главное меню.
    """
    await update.message.reply_text(
        "Возврат в главное меню.",
        reply_markup=get_main_menu(update.effective_user.id)
    )
    context.user_data.clear()
    return ConversationHandler.END

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ check_payment_status НА ЭТУ:
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
async def check_payment_status(context: ContextTypes.DEFAULT_TYPE):
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    Проверяет статус платежа в YooKassa и обрабатывает результат.
    Теперь корректно передает информацию о скидке для погашения.
    """
    job = context.job
    if not job or not job.data or 'yookassa_id' not in job.data:
        logging.error(f"Задача проверки платежа запущена без yookassa_id. Удаляю.")
        if job: job.schedule_removal()
        return

    yookassa_id = job.data['yookassa_id']
    pending_payments = context.bot_data.get('pending_payments', {})
    payment_data = pending_payments.get(yookassa_id)

    if not payment_data:
        logging.warning(f"Данные для проверки платежа {yookassa_id} не найдены. Задача удалена.")
        job.schedule_removal()
        return

    user_id = payment_data['user_id']
    animated_message_id = payment_data.get('animated_message_id')
    stop_animation_event = payment_data.get('stop_animation_event')

    # Останавливаем анимацию, если она есть
    if stop_animation_event and not stop_animation_event.is_set():
        stop_animation_event.set()

    try:
        payment = Payment.find_one(yookassa_id)

        if payment.status == 'succeeded':
            logging.info(f"Платеж {yookassa_id} для user_id {user_id} УСПЕШЕН.")

            # Извлекаем ID скидки из метаданных, если он там был
            metadata = payment.metadata
            discount_id_to_use = metadata.get('discount_id') # Это может быть None

            # Удаляем сообщение с анимацией и кнопкой оплаты
            if animated_message_id:
                try:
                    await context.bot.delete_message(chat_id=user_id, message_id=animated_message_id)
                except Exception as e:
                    logging.info(f"Не удалось удалить сообщение {animated_message_id}: {e}")

            # Вызываем основную функцию обработки, передавая все данные
            await process_successful_payment(
                context=context,
                user_id=user_id,
                payload=metadata.get('internal_payload', ''),
                amount_rub=int(float(payment.amount.value)),
                discount_id_to_use=discount_id_to_use # Передаем ID скидки
            )

        elif payment.status in ['canceled', 'failed']:
            logging.warning(f"Платеж {yookassa_id} для user_id {user_id} отменен или неудачен (статус: {payment.status}).")
            if animated_message_id:
                try:
                    await context.bot.edit_message_text(
                        chat_id=user_id,
                        message_id=animated_message_id,
                        text="❌ Платеж был отменен или не удался. Попробуйте снова."
                    )
                except Exception:
                     await context.bot.send_message(user_id, "❌ Платеж был отменен или не удался.")

        else: # Если статус 'pending' или 'waiting_for_capture'
            # Проверяем время жизни задачи
            if datetime.now() - payment_data.get('start_time', datetime.now()) > timedelta(minutes=15):
                logging.warning(f"Время ожидания платежа {yookassa_id} истекло.")
                if animated_message_id:
                     try:
                        await context.bot.edit_message_text(chat_id=user_id, message_id=animated_message_id, text="Время ожидания оплаты истекло.")
                     except Exception:
                        await context.bot.send_message(user_id, "Время ожидания оплаты истекло.")
                job.schedule_removal() # Удаляем задачу, если время вышло
                if yookassa_id in pending_payments: del pending_payments[yookassa_id]
            return # Если время не вышло, просто выходим и ждем следующей проверки

        # Если платеж завершен (успешно, отменен, провален), удаляем задачу и данные
        job.schedule_removal()
        if yookassa_id in pending_payments:
            del pending_payments[yookassa_id]

    except Exception as e:
        logging.error(f"Ошибка при проверке статуса платежа {yookassa_id}: {e}", exc_info=True)
        job.schedule_removal()
        if yookassa_id in pending_payments:
            del pending_payments[yookassa_id]

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
#========================================================================================
# НАЧАЛО ИСПРАВЛЕННОЙ ФУНКЦИИ
#========================================================================================

#========================================================================================
# НАЧАЛО ИСПРАВЛЕННОЙ ФУНКЦИИ
#========================================================================================




async def pre_checkout_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.pre_checkout_query
    await query.answer(ok=True)

# Обработка запроса о бронировании 📅
### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
async def book_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Начинает процесс бронирования. Шаг 1: Выбор даты.
    """
    query = update.callback_query
    await query.answer()

    # Сохраняем ID модели велосипеда
    try:
        context.user_data['booking_bike_id'] = int(query.data.split("_")[1])
    except (IndexError, ValueError):
        await query.edit_message_text("🚫 Ошибка: не удалось определить велосипед. Попробуйте снова.")
        return ConversationHandler.END

    # Удаляем предыдущее сообщение с информацией о велосипеде, чтобы не было путаницы
    await query.message.delete()

    # Отправляем новое сообщение с календарем
    await context.bot.send_message(
        chat_id=query.from_user.id,
        text="📅 *Выберите дату бронирования:*\n\n(Доступны ближайшие 3 дня)",
        reply_markup=create_calendar(),
        parse_mode="Markdown"
    )
    # Переходим в состояние выбора времени
    return SELECTING_DATE

# Подтверждение бронирования 📋
async def send_sticker(message, sticker_id: str) -> None:
    await message.reply_sticker(sticker_id)
# Завершение бронирования в зависимости от выбора пользователя ✔️❌
logger = logging.getLogger(__name__)  # Создаем логгер на уровне модуля

### НОВАЯ, ПОЛНОСТЬЮ АСИНХРОННАЯ И ИНФОРМАТИВНАЯ ФУНКЦИЯ ###
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

async def finalize_booking(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Завершает процесс бронирования: сохраняет данные в БД асинхронно
    и отправляет информативное уведомление администратору.
    """
    query = update.callback_query
    await query.answer()

    if query.data == 'reject_booking':
        await query.edit_message_text("❌ Бронирование отменено.")
        context.user_data.clear()
        return ConversationHandler.END

    user_id = query.from_user.id
    user_data = context.user_data
    bike_id = user_data.get('booking_bike_id')
    booking_date = user_data.get('booking_date')
    booking_time = user_data.get('booking_time')

    if not all([bike_id, booking_date, booking_time]):
        await query.edit_message_text("🚫 Ошибка сессии. Данные утеряны. Пожалуйста, начните заново.")
        return ConversationHandler.END

    full_booking_datetime_str = f"{booking_date.strftime('%d.%m.%Y')} {booking_time}"

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("SELECT first_name, last_name, username FROM users WHERE id=?", (user_id,))
            user_info = await cursor.fetchone()
            user_name_raw = f"{user_info[0]} {user_info[1] or ''} (@{user_info[2] or 'no_username'})" if user_info else f"ID {user_id}"

            cursor = await conn.execute("SELECT name FROM bikes WHERE id=?", (bike_id,))
            bike_name_row = await cursor.fetchone()
            bike_name = bike_name_row[0] if bike_name_row else "Неизвестный велосипед"

            await conn.execute(
                "INSERT INTO bookings (user_id, bike_id, booking_date, status) VALUES (?, ?, ?, 'pending')",
                (user_id, bike_id, full_booking_datetime_str)
            )

            cursor = await conn.execute("SELECT last_insert_rowid()")
            booking_id_row = await cursor.fetchone()
            booking_id = booking_id_row[0]

            await conn.commit()

        await query.edit_message_text("✅ Ваша заявка на бронь принята и отправлена на подтверждение администратору. Ожидайте! 🐱")

        user_name_escaped = escape_markdown(user_name_raw, version=2)
        bike_name_escaped = escape_markdown(bike_name, version=2)
        booking_datetime_escaped = escape_markdown(full_booking_datetime_str, version=2)

        notification_message = (
            f"📝 *Новый запрос на бронь\\!*\n\n"
            f"👤 *Пользователь:* {user_name_escaped}\n"
            f"🚲 *Велосипед:* {bike_name_escaped} \\(ID: {bike_id}\\)\n"
            f"📅 *Дата и время:* {booking_datetime_escaped}\n"
            f"🆔 *ID брони:* `{booking_id}`"
        )

        keyboard = [[
            InlineKeyboardButton("✅ Подтвердить", callback_data=f"confirm_{booking_id}"),
            InlineKeyboardButton("❌ Отменить", callback_data=f"cancel_{booking_id}")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        for admin_id in ADMIN_IDS:
            await context.bot.send_message(
                admin_id,
                notification_message,
                reply_markup=reply_markup,
                parse_mode="MarkdownV2"
            )

        # <<< ИСПРАВЛЕНИЕ: Добавляем await >>>
        await add_notification(f"Новая бронь от {user_name_raw} на {bike_name}")

    except Exception as e:
        logger.error(f"Ошибка в finalize_booking: {e}", exc_info=True)
        await query.edit_message_text("🚫 Произошла ошибка при сохранении брони. Пожалуйста, попробуйте снова.")
    finally:
        context.user_data.clear()
        return ConversationHandler.END
QUANTITY_PROMPT = 5 # Добавляем новое состояние для количества
# Команда для добавления велосипеда (доступна только администратору) ➕


EDIT_MENU, EDIT_NAME, EDIT_DESCRIPTION, EDIT_PRICE, EDIT_AVAILABLE, EDIT_SEARCH = range(6)
STATS_AWAIT_DATE_RANGE = range(990, 991)

async def start_detailed_report_date_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Запрашивает период для выбранного типа отчета."""
    query = update.callback_query
    await query.answer()

    # Извлекаем тип отчета из callback_data (например, 'own', 'investor', 'combined')
    # Формат callback_data: stats_detailed_{report_type}_{optional_investor_id}
    report_type = query.data.split('_')[2]
    
    # Сохраняем тип отчета, который нужно будет сгенерировать
    context.user_data['detailed_report_type'] = report_type
    
    # Если это отчет по конкретному инвестору, сохраняем и его ID
    if len(query.data.split('_')) > 3:
        context.user_data['detailed_report_investor_id'] = int(query.data.split('_')[3])

    message_text = (
        "📅 *Отчет за период*\n\n"
        "Введите период для отчета в формате `ДД.ММ.ГГГГ-ДД.ММ.ГГГГ`\n"
        "Или используйте быстрые команды: `сегодня`, `неделя`, `месяц`."
    )
    
    await query.edit_message_text(message_text, parse_mode="Markdown")
    return STATS_AWAIT_DATE_RANGE

async def process_detailed_report_dates(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 2: Принимает даты, вызывает нужный генератор и отправляет отчет.
    """
    user_input = update.message.text.strip().lower()
    today = datetime.now()
    start_date, end_date = None, None

    try:
        if user_input == 'сегодня':
            start_date = end_date = today
        elif user_input == 'неделя':
            start_date = today - timedelta(days=today.weekday())
            end_date = today
        elif user_input == 'месяц':
            start_date = today.replace(day=1)
            end_date = today
        else:
            start_str, end_str = user_input.split('-')
            start_date = datetime.strptime(start_str.strip(), '%d.%m.%Y')
            end_date = datetime.strptime(end_str.strip(), '%d.%m.%Y')
    except (ValueError, IndexError):
        await update.message.reply_text("❌ Неверный формат. Попробуйте еще раз.")
        return STATS_AWAIT_DATE_RANGE

    status_message = await update.message.reply_text("⏳ Генерирую Excel-отчет, это может занять до минуты...")

    report_type = context.user_data.get('detailed_report_type')
    investor_id = context.user_data.get('detailed_report_investor_id')
    filename = None
    
    try:
        # <<< ГЛАВНОЕ ИЗМЕНЕНИЕ: ВЫЗЫВАЕМ НОВУЮ УНИВЕРСАЛЬНУЮ ФУНКЦИЮ С ДАТАМИ >>>
        if report_type == 'expenses':
             filename = generate_expense_report(start_date, end_date)
        else:
             filename = await generate_unified_report(
                 report_type=report_type, 
                 start_date=start_date, 
                 end_date=end_date, 
                 investor_id=investor_id
             )

        if filename and os.path.exists(filename):
            with open(filename, 'rb') as file:
                await context.bot.send_document(
                    chat_id=update.effective_chat.id,
                    document=file,
                    caption=f"✅ Ваш детальный отчет за период с {start_date.strftime('%d.%m.%Y')} по {end_date.strftime('%d.%m.%Y')} готов."
                )
            os.remove(filename)
            await status_message.delete()
        else:
            await status_message.edit_text("😔 В этой категории нет данных для отчета за указанный период.")

    except Exception as e:
        logger.error(f"Ошибка при генерации отчета по датам: {e}", exc_info=True)
        await status_message.edit_text(f"❌ Произошла ошибка: {e}")

    context.user_data.clear()
    return ConversationHandler.END
# Вспомогательная функция для генерации клавиатуры с пагинацией
def generate_edit_bikes_keyboard(context):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем поисковый запрос из контекста
    search_query = context.user_data.get('search_query')
    if search_query:
        cursor.execute("SELECT id, name FROM bikes WHERE name LIKE ?", ('%' + search_query + '%',))
    else:
        cursor.execute("SELECT id, name FROM bikes")

    bikes = cursor.fetchall()
    conn.close()

    page = context.user_data.get('edit_page', 0)  # Текущая страница
    items_per_page = 5  # Количество велосипедов на странице
    total_pages = (len(bikes) + items_per_page - 1) // items_per_page  # Общее количество страниц

    # Корректируем номер страницы, если он выходит за пределы
    page = max(0, min(page, total_pages - 1))

    # Выбираем велосипеды для текущей страницы
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    current_bikes = bikes[start_idx:end_idx]

    # Формируем кнопки с велосипедами
    keyboard = [
        [InlineKeyboardButton(bike[1], callback_data=f"edit_{bike[0]}")]
        for bike in current_bikes
    ]

    # Добавляем кнопки пагинации
    pagination = []
    if page > 0:
        pagination.append(InlineKeyboardButton("<", callback_data="prev_edit_page"))
    if page < total_pages - 1:
        pagination.append(InlineKeyboardButton(">", callback_data="next_edit_page"))

    if pagination:
        keyboard.append(pagination)

    # Добавляем кнопки поиска/сброса
    search_buttons = []
    if context.user_data.get('search_query'):
        search_buttons.append(InlineKeyboardButton("❌ Сбросить поиск", callback_data="reset_search"))
    else:
        search_buttons.append(InlineKeyboardButton("🔍 Поиск", callback_data="start_search"))

    if search_buttons:
        keyboard.append(search_buttons)

    # Добавляем кнопку "Назад"
    keyboard.append([InlineKeyboardButton("🗡 Назад", callback_data="cancel_edit")])

    # Текст с информацией о текущей странице
    text = f"🖊️ Выберите велосипед (Страница {page + 1}/{total_pages}):"
    return text, InlineKeyboardMarkup(keyboard)

# Функция для отображения списка велосипедов с пагинацией
async def edit_bikes(update: Update, context) -> None:
    """
    Отображает список велосипедов с пагинацией для редактирования.
    """
    # Генерация клавиатуры и текста
    text, reply_markup = generate_edit_bikes_keyboard(context)

    # Отправка сообщения
    if update.message:
        await update.message.reply_text(text, reply_markup=reply_markup)
    else:
        await update.callback_query.edit_message_text(text, reply_markup=reply_markup)

# Функция для обработки навигации по страницам
async def navigate_edit_pages(update: Update, context):
    query = update.callback_query
    await query.answer()

    # Обработка поиска
    if query.data == "start_search":
        await query.message.reply_text("✏️ Введите название для поиска:")
        return EDIT_SEARCH

    elif query.data == "reset_search":
        if 'search_query' in context.user_data:
            del context.user_data['search_query']
        context.user_data['edit_page'] = 0
        await edit_bikes(update, context)
        return ConversationHandler.END

    # Обработка пагинации
    current_page = context.user_data.get('edit_page', 0)
    if query.data == "prev_edit_page":
        current_page = max(0, current_page - 1)
    elif query.data == "next_edit_page":
        current_page += 1

    # Сохраняем новую страницу
    context.user_data['edit_page'] = current_page

    # Обновляем сообщение
    await edit_bikes(update, context)

# Обработка ввода поискового запроса
async def handle_search_input(update: Update, context):
    search_text = update.message.text
    context.user_data['search_query'] = search_text
    context.user_data['edit_page'] = 0
    await edit_bikes(update, context)
    return ConversationHandler.END

# Начало редактирования велосипеда
async def start_editing_bike(update: Update, context) -> int:
    query = update.callback_query
    await query.answer()

    # Сохраняем текущую страницу для возврата
    context.user_data['prev_page'] = context.user_data.get('edit_page', 0)

    bike_id = query.data.split("_")[1]

    # Проверка существования велосипеда
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id FROM bikes WHERE id=?", (bike_id,))
    if not cursor.fetchone():
        await query.message.reply_text("🚫 Велосипед не найден")
        return ConversationHandler.END
    conn.close()

    context.user_data['editing_bike'] = bike_id
    return await show_edit_menu(update, context)

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ show_edit_menu НА ЭТУ ВЕРСИЮ
async def show_edit_menu(update: Update, context):
    keyboard = [
        [
            InlineKeyboardButton("✏️ Название", callback_data="edit_name"),
            InlineKeyboardButton("📝 Описание", callback_data="edit_description")
        ],
        [
            InlineKeyboardButton("💰 Цена", callback_data="edit_price"),
            InlineKeyboardButton("🔄 Наличие", callback_data="edit_available")
        ],
        # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
        [InlineKeyboardButton("🗑️ Удалить", callback_data="edit_delete")],
        [InlineKeyboardButton("✅ Завершить", callback_data="edit_finish")]
        # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    if update.callback_query:
        # Используем message.reply_text вместо edit_message_text, чтобы избежать ошибок
        # при возврате из других состояний
        await update.callback_query.message.reply_text(
            "🛠 Выберите параметр для редактирования:",
            reply_markup=reply_markup
        )
    else:
        await update.message.reply_text(
            "🛠 Выберите параметр для редактирования:",
            reply_markup=reply_markup
        )
    return EDIT_MENU
# ADD THIS NEW CODE BLOCK
async def handle_delete_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1 (Удаление): Проверяет, свободен ли товар, и запрашивает подтверждение."""
    query = update.callback_query
    await query.answer()
    
    bike_id = context.user_data.get('editing_bike')
    
    async with aiosqlite.connect(DB_FILE) as conn:
        # Проверка на активные сделки
        cursor = await conn.execute("SELECT COUNT(*) FROM bookings WHERE bike_id = ? AND status = 'rented'", (bike_id,))
        active_deals_count = (await cursor.fetchone())[0]

    if active_deals_count > 0:
        await query.answer(
            f"🚫 Невозможно удалить! Этот товар находится в {active_deals_count} активных сделках (аренда/выкуп).",
            show_alert=True
        )
        return EDIT_MENU # Возвращаемся в меню редактирования

    # Если товар свободен, запрашиваем подтверждение
    keyboard = [
        [InlineKeyboardButton("ДА, УДАЛИТЬ", callback_data="confirm_delete_bike_yes")],
        [InlineKeyboardButton("Нет, вернуться", callback_data="confirm_delete_bike_no")]
    ]
    await query.edit_message_text(
        "🚨 ВЫ УВЕРЕНЫ?\n\nЭто действие необратимо удалит товар из базы данных.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return EDIT_CONFIRM_DELETE_BIKE

async def delete_bike_confirmed(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (Удаление): Обрабатывает подтверждение и удаляет товар."""
    query = update.callback_query
    await query.answer()

    if query.data == "confirm_delete_bike_no":
        # Если админ передумал, возвращаем его в меню редактирования
        return await show_editing_menu(query, context)

    bike_id = context.user_data.get('editing_bike')
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute("DELETE FROM bikes WHERE id = ?", (bike_id,))
            await conn.commit()
        
        await query.edit_message_text("✅ Товар успешно удален.")
    except Exception as e:
        logger.error(f"Ошибка при удалении товара {bike_id}: {e}", exc_info=True)
        await query.edit_message_text(f"❌ Произошла ошибка: {e}")

    # После удаления возвращаем админа к обновленному списку велосипедов
    await edit_bikes(update, context)
    return ConversationHandler.END
async def handle_delete_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1 (Удаление): Проверяет, свободен ли товар, и запрашивает подтверждение."""
    query = update.callback_query
    await query.answer()
    
    bike_id = context.user_data.get('editing_bike')
    
    async with aiosqlite.connect(DB_FILE) as conn:
        # Проверка на активные сделки
        cursor = await conn.execute("SELECT COUNT(*) FROM bookings WHERE bike_id = ? AND status = 'rented'", (bike_id,))
        active_deals_count = (await cursor.fetchone())[0]

    if active_deals_count > 0:
        await query.answer(
            f"🚫 Невозможно удалить! Этот товар находится в {active_deals_count} активных сделках (аренда/выкуп).",
            show_alert=True
        )
        return EDIT_MENU # Возвращаемся в меню редактирования

    # Если товар свободен, запрашиваем подтверждение
    keyboard = [
        [InlineKeyboardButton("ДА, УДАЛИТЬ", callback_data="confirm_delete_bike_yes")],
        [InlineKeyboardButton("Нет, вернуться", callback_data="confirm_delete_bike_no")]
    ]
    await query.edit_message_text(
        "🚨 ВЫ УВЕРЕНЫ?\n\nЭто действие необратимо удалит товар из базы данных.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return EDIT_CONFIRM_DELETE_BIKE

async def delete_bike_confirmed(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (Удаление): Обрабатывает подтверждение и удаляет товар."""
    query = update.callback_query
    await query.answer()

    if query.data == "confirm_delete_bike_no":
        # Если админ передумал, возвращаем его в меню редактирования
        return await show_editing_menu(query, context)

    bike_id = context.user_data.get('editing_bike')
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute("DELETE FROM bikes WHERE id = ?", (bike_id,))
            await conn.commit()
        
        await query.edit_message_text("✅ Товар успешно удален.")
    except Exception as e:
        logger.error(f"Ошибка при удалении товара {bike_id}: {e}", exc_info=True)
        await query.edit_message_text(f"❌ Произошла ошибка: {e}")

    # После удаления возвращаем админа к обновленному списку велосипедов
    await edit_bikes(update, context)
    return ConversationHandler.END

# ДОБАВЬТЕ ЭТОТ БЛОК КОДА РЯДОМ С ДРУГИМИ ФУНКЦИЯМИ РЕДАКТИРОВАНИЯ

async def handle_delete_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1 (Удаление): Проверяет, свободен ли товар, и запрашивает подтверждение."""
    query = update.callback_query
    await query.answer()
    
    bike_id = context.user_data.get('editing_bike')
    
    async with aiosqlite.connect(DB_FILE) as conn:
        # Проверка на активные сделки
        cursor = await conn.execute("SELECT COUNT(*) FROM bookings WHERE bike_id = ? AND status = 'rented'", (bike_id,))
        active_deals_count = (await cursor.fetchone())[0]

    if active_deals_count > 0:
        await query.answer(
            f"🚫 Невозможно удалить! Этот товар находится в {active_deals_count} активных сделках (аренда/выкуп).",
            show_alert=True
        )
        return EDIT_MENU # Возвращаемся в меню редактирования

    # Если товар свободен, запрашиваем подтверждение
    keyboard = [
        [InlineKeyboardButton("ДА, УДАЛИТЬ", callback_data="confirm_delete_bike_yes")],
        [InlineKeyboardButton("Нет, вернуться", callback_data="confirm_delete_bike_no")]
    ]
    await query.edit_message_text(
        "🚨 ВЫ УВЕРЕНЫ?\n\nЭто действие необратимо удалит товар из базы данных.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return EDIT_CONFIRM_DELETE_BIKE

async def delete_bike_confirmed(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (Удаление): Обрабатывает подтверждение и удаляет товар."""
    query = update.callback_query
    await query.answer()

    if query.data == "confirm_delete_bike_no":
        # Если админ передумал, возвращаем его в меню редактирования
        return await show_editing_menu(query, context)

    bike_id = context.user_data.get('editing_bike')
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute("DELETE FROM bikes WHERE id = ?", (bike_id,))
            await conn.commit()
        
        await query.edit_message_text("✅ Товар успешно удален.")
    except Exception as e:
        logger.error(f"Ошибка при удалении товара {bike_id}: {e}", exc_info=True)
        await query.edit_message_text(f"❌ Произошла ошибка: {e}")

    # После удаления возвращаем админа к обновленному списку велосипедов
    await edit_bikes(update, context)
    return ConversationHandler.END

async def handle_edit_choice(update: Update, context):
    query = update.callback_query
    await query.answer()
    choice = query.data

    if choice == "edit_name":
        await query.message.reply_text(
            "Введите новое название:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("↩️ Отменить ввод", callback_data="cancel_input")]
            ])
        )
        return EDIT_NAME

    elif choice == "edit_description":
        await query.message.reply_text(
            "Введите новое описание:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("↩️ Отменить ввод", callback_data="cancel_input")]
            ])
        )
        return EDIT_DESCRIPTION

    elif choice == "edit_price":
        await query.message.reply_text(
            "Введите новую цену (руб./неделя):",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("↩️ Отменить ввод", callback_data="cancel_input")]
            ])
        )
        return EDIT_PRICE

    elif choice == "edit_available":
        keyboard = [
            [
                InlineKeyboardButton("✅ В наличии", callback_data="set_available_1"),
                InlineKeyboardButton("❌ Нет в наличии", callback_data="set_available_0")
            ],
            [InlineKeyboardButton("↩️ Назад", callback_data="back_to_menu")]
        ]
        await query.message.reply_text(
            "Выберите статус наличия:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return EDIT_AVAILABLE

    elif choice == "edit_finish":
        await query.message.reply_text("✅ Редактирование завершено")
        return ConversationHandler.END

    return EDIT_MENU

async def save_name(update: Update, context):
    if update.message:
        new_name = update.message.text
        bike_id = context.user_data['editing_bike']

        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("UPDATE bikes SET name=? WHERE id=?", (new_name, bike_id))
        conn.commit()
        conn.close()

        await update.message.reply_text("✅ Название обновлено!")
    return await show_edit_menu(update, context)

async def save_description(update: Update, context):
    if update.message:
        new_desc = update.message.text
        bike_id = context.user_data['editing_bike']

        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("UPDATE bikes SET description=? WHERE id=?", (new_desc, bike_id))
        conn.commit()
        conn.close()

        await update.message.reply_text("✅ Описание обновлено!")
    return await show_edit_menu(update, context)

async def save_price(update: Update, context):
    if update.message:
        try:
            new_price = float(update.message.text)
            bike_id = context.user_data['editing_bike']

            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            cursor.execute("UPDATE bikes SET price=? WHERE id=?", (new_price, bike_id))
            conn.commit()
            conn.close()

            await update.message.reply_text("✅ Цена обновлена!")
        except ValueError:
            await update.message.reply_text("❌ Неверный формат цены!")
    return await show_edit_menu(update, context)

async def set_availability(update: Update, context):
    query = update.callback_query
    await query.answer()
    available = query.data.split("_")[-1]
    bike_id = context.user_data['editing_bike']

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("UPDATE bikes SET available=? WHERE id=?", (available, bike_id))
    conn.commit()
    conn.close()

    await query.message.edit_text("✅ Статус наличия обновлен!")
    return await show_edit_menu(update, context)

async def cancel_input(update: Update, context):
    query = update.callback_query
    await query.answer()
    await query.message.reply_text("❌ Ввод отменен")
    return await show_edit_menu(update, context)

async def cancel_edit(update: Update, context):
    await update.message.reply_text("✅ Редактирование завершено")
    return ConversationHandler.END

import re



# Определение состояний
# Замени весь блок определения состояний на этот:

# main.py

# ### ИЗМЕНЕНИЕ: Добавлены новые состояния для регистрации иностранцев ###
# main.py

# ### ИЗМЕНЕНИЕ: Перегруппированы состояния для переиспользования ###
# main.py

# ### ИЗМЕНЕНИЕ: Перегруппированы состояния для переиспользования ###
# --- СОСТОЯНИЯ И КОНСТАНТЫ ДЛЯ РЕГИСТРАЦИИ И ВЕРИФИКАЦИИ ---

# Определяем состояния для нового, гибкого диалога
# Старый код с ошибкой
# Исправленный код
# ЗАМЕНИТЕ СТАРЫЙ БЛОК СОСТОЯНИЙ
(
    REG_AWAIT_INPUT, REG_AWAIT_COUNTRY, REG_AWAIT_DOCS,
    REG_AWAIT_VERIFICATION,
    AWAIT_REWORK_REASON, AWAIT_REJECT_REASON,
    REG_AWAIT_LICENSE_CHOICE,   # <-- НОВОЕ СОСТОЯНИЕ
    REG_AWAIT_LICENSE_PHOTO     # <-- НОВОЕ СОСТОЯНИЕ
) = range(30, 38)



# Ключи для хранения данных в user_data
REG_FORM_DATA = 'reg_form_data'
CURRENT_REG_STEP = 'current_reg_step'
MEDIA_GROUP_CACHE = 'media_group_cache'  # <<< ДОБАВЛЕНА ЭТА СТРОКА

# Шаги регистрации (структура "мастера")
# ИЗМЕНЕНИЕ: Список шагов регистрации сокращен в соответствии с требованием
# ЗАМЕНИТЕ СТАРЫЙ СПИСОК
REGISTRATION_STEPS = [
    'terms', 'first_name', 'last_name', 'phone_number',
    'has_license', # <-- НОВЫЙ ШАГ
    'delivery_service', 'select_country', 'documents'
]


(
    EDIT_USER_MENU,               # Главное меню редактирования (название, описание, тарифы)
    EDIT_AWAIT_NAME,              # Ожидание нового названия
    EDIT_AWAIT_DESCRIPTION,       # Ожидание нового описания
    EDIT_TARIFFS_MENU,            # Меню выбора (Аренда/Выкуп)
    AWAIT_RENT_PRICES,            # Ожидание цен аренды (7, 14, 30 дней)
    AWAIT_BUYOUT_PAYMENTS,        # Ожидание кол-ва платежей выкупа
    AWAIT_BUYOUT_AMOUNT,          # Ожидание суммы платежа выкупа
    AWAIT_BUYOUT_PERIOD,          # Ожидание периода платежа выкупа
    EDIT_AVAILABILITY,            # Состояние для изменения наличия
    EDIT_CONFIRM_DELETE_BIKE      # <-- ВАШЕ НОВОЕ СОСТОЯНИЕ
) = range(750, 760) # Увеличиваем диапазон на 1

# --- ГЛАВНАЯ ТОЧКА ВХОДА ---
async def show_bike_list_for_editing(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Показывает список велосипедов для выбора с пагинацией.
    ИСПРАВЛЕНО: Добавлена обработка ошибки "Message not modified".
    """
    page = context.user_data.get('edit_page', 0)
    bikes_per_page = 5
    offset = page * bikes_per_page

    async with aiosqlite.connect(DB_FILE) as conn:
        cursor = await conn.execute("SELECT COUNT(*) FROM bikes")
        total_bikes = (await cursor.fetchone())[0]
        
        cursor = await conn.execute(
            "SELECT id, name FROM bikes ORDER BY name LIMIT ? OFFSET ?",
            (bikes_per_page, offset)
        )
        bikes = await cursor.fetchall()

    keyboard = [[InlineKeyboardButton(b[1], callback_data=f"edit_bike_{b[0]}")] for b in bikes]

    nav = []
    total_pages = (total_bikes + bikes_per_page - 1) // bikes_per_page
    # Показываем кнопки, только если они нужны
    if page > 0: 
        nav.append(InlineKeyboardButton("⬅️", callback_data="edit_page_prev"))
    if page < total_pages - 1: 
        nav.append(InlineKeyboardButton("➡️", callback_data="edit_page_next"))

    if nav: 
        keyboard.append(nav)
    keyboard.append([InlineKeyboardButton("❌ Завершить", callback_data="edit_cancel")])

    text = f"Выберите велосипед для редактирования (Стр. {page + 1}/{total_pages}):"
    reply_markup = InlineKeyboardMarkup(keyboard)

    # --- Обработка ошибки ---
    try:
        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup)
        else:
            await update.message.reply_text(text, reply_markup=reply_markup)
    except telegram.error.BadRequest as e:
        if "Message is not modified" in str(e):
            # Просто игнорируем эту ошибку, она не критична
            pass
        else:
            # Выводим в лог другие, более серьезные ошибки
            logger.error(f"Ошибка при редактировании сообщения: {e}")

    # Возвращаем состояние для ConversationHandler
    return EDIT_USER_MENU

# --- ОСНОВНОЕ МЕНЮ РЕДАКТИРОВАНИЯ ---
# REPLACED FUNCTION
async def show_main_edit_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Показывает главное меню редактирования, включая статус наличия и кнопку для его изменения."""
    query = update.callback_query
    if query:
        await query.answer()
        if query.data.startswith("edit_bike_"):
            context.user_data['editing_bike_id'] = int(query.data.split('_')[-1])

    bike_id = context.user_data['editing_bike_id']
    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        cursor = await conn.execute("SELECT name, available FROM bikes WHERE id = ?", (bike_id,))
        bike = await cursor.fetchone()

    availability_text = "✅ В наличии" if bike['available'] else "❌ Нет в наличии"
    
    text = (
        f"Что вы хотите изменить для велосипеда *{bike['name']}*?\n\n"
        f"Текущий статус: *{availability_text}*"
    )
    # <<< НАЧАЛО ИЗМЕНЕНИЙ В КЛАВИАТУРЕ >>>
    keyboard = [
        [InlineKeyboardButton("📝 Название", callback_data="edit_field_name")],
        [InlineKeyboardButton("ℹ️ Описание", callback_data="edit_field_description")],
        [InlineKeyboardButton("💰 Тарифы", callback_data="edit_field_tariffs")],
        [InlineKeyboardButton("🔄 Изменить наличие", callback_data="edit_field_availability")],
        # Новая кнопка удаления
        [InlineKeyboardButton("🗑️ Удалить велосипед", callback_data="edit_action_delete")],
        [InlineKeyboardButton("⬅️ К списку велосипедов", callback_data="edit_back_to_list")]
    ]
    # <<< КОНЕЦ ИЗМЕНЕНИЙ В КЛАВИАТУРЕ >>>
    
    message_to_use = query.message if query else update.message
    if hasattr(message_to_use, 'edit_text'):
        await message_to_use.edit_text(
            text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown"
        )
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id, text=text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown"
        )

    return EDIT_USER_MENU

    # ADD THIS NEW CODE BLOCK
async def handle_delete_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1 (Удаление): Проверяет, свободен ли товар, и запрашивает подтверждение."""
    query = update.callback_query
    await query.answer()
    
    bike_id = context.user_data.get('editing_bike_id')
    
    async with aiosqlite.connect(DB_FILE) as conn:
        # Проверка на активные сделки (аренда или выкуп)
        cursor = await conn.execute("SELECT COUNT(*) FROM bookings WHERE bike_id = ? AND status = 'rented'", (bike_id,))
        active_deals_count = (await cursor.fetchone())[0]

    if active_deals_count > 0:
        await query.answer(
            f"🚫 Невозможно удалить! Этот велосипед находится в {active_deals_count} активных сделках.",
            show_alert=True
        )
        return EDIT_USER_MENU # Возвращаемся в меню редактирования

    # Если велосипед свободен, запрашиваем подтверждение
    keyboard = [
        [InlineKeyboardButton("ДА, УДАЛИТЬ", callback_data="confirm_delete_bike_yes")],
        [InlineKeyboardButton("Нет, вернуться", callback_data="confirm_delete_bike_no")]
    ]
    await query.edit_message_text(
        "🚨 ВЫ УВЕРЕНЫ?\n\nЭто действие необратимо удалит велосипед из базы данных.",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return EDIT_CONFIRM_DELETE_BIKE

async def delete_bike_confirmed(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (Удаление): Обрабатывает подтверждение и удаляет товар."""
    query = update.callback_query
    await query.answer()

    if query.data == "confirm_delete_bike_no":
        # Если админ передумал, возвращаем его в меню редактирования этого же велосипеда
        return await show_main_edit_menu(update, context)

    bike_id = context.user_data.get('editing_bike_id')
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute("DELETE FROM bikes WHERE id = ?", (bike_id,))
            await conn.commit()
        
        await query.edit_message_text("✅ Велосипед успешно удален.")
    except Exception as e:
        logger.error(f"Ошибка при удалении велосипеда {bike_id}: {e}", exc_info=True)
        await query.edit_message_text(f"❌ Произошла ошибка: {e}")

    # После удаления возвращаем админа к обновленному списку всех велосипедов
    await show_bike_list_for_editing(update, context)
    return ConversationHandler.END

# <<< НАЧАЛО НОВОГО БЛОКА КОДА >>>

async def request_availability_change(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 1 (Наличие): Запрашивает новый статус наличия у администратора.
    """
    query = update.callback_query
    await query.answer()

    text = "Выберите новый статус наличия:"
    keyboard = [
        [
            InlineKeyboardButton("✅ В наличии", callback_data="set_availability_1"),
            InlineKeyboardButton("❌ Нет в наличии", callback_data="set_availability_0")
        ],
        # Кнопка "Назад" вернет нас в главное меню редактирования
        [InlineKeyboardButton("⬅️ Назад", callback_data="back_to_edit_menu")]
    ]
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    
    # Переходим в новое состояние, где ждем нажатия одной из этих кнопок
    return EDIT_AVAILABILITY

async def save_availability(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 2 (Наличие): Сохраняет новый статус в БД и возвращает в главное меню редактирования.
    """
    query = update.callback_query
    await query.answer()

    # Если админ нажал "Назад", просто возвращаем его в главное меню редактирования
    if "back_to_edit_menu" in query.data:
        return await show_main_edit_menu(update, context)

    # Получаем новый статус (1 или 0) из callback_data
    new_status = int(query.data.split('_')[-1])
    bike_id = context.user_data['editing_bike_id']

    async with aiosqlite.connect(DB_FILE) as conn:
        await conn.execute("UPDATE bikes SET available = ? WHERE id = ?", (new_status, bike_id))
        await conn.commit()
    
    status_text = "✅ В наличии" if new_status else "❌ Нет в наличии"
    # Показываем всплывающее уведомление
    await query.answer(f"Статус изменен на: {status_text}", show_alert=True)
    
    # Возвращаемся в главное меню редактирования, чтобы увидеть обновленный статус
    return await show_main_edit_menu(update, context)

# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>

# --- ОБРАБОТЧИКИ НАЗВАНИЯ И ОПИСАНИЯ ---
async def request_new_value(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Запрашивает новое значение для названия или описания."""
    query = update.callback_query
    await query.answer()
    field = query.data.split('_')[-1]
    context.user_data['editing_field'] = field
    
    prompt = "новое название" if field == "name" else "новое описание"
    await query.message.edit_text(f"Введите {prompt}:")
    
    return EDIT_AWAIT_NAME if field == "name" else EDIT_AWAIT_DESCRIPTION

async def save_text_value(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Сохраняет новое текстовое значение (имя/описание)."""
    field = context.user_data.pop('editing_field')
    bike_id = context.user_data['editing_bike_id']
    new_value = update.message.text

    async with aiosqlite.connect(DB_FILE) as conn:
        await conn.execute(f"UPDATE bikes SET {field} = ? WHERE id = ?", (new_value, bike_id))
        await conn.commit()
    
    await update.message.reply_text(f"✅ {field.capitalize()} успешно обновлено!")
    return await show_main_edit_menu(update, context)

# --- МЕНЮ РЕДАКТИРОВАНИЯ ТАРИФОВ ---
async def show_tariffs_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Показывает текущие тарифы и кнопки для их редактирования."""
    query = update.callback_query
    await query.answer()
    
    bike_id = context.user_data['editing_bike_id']
    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        cursor = await conn.execute("SELECT * FROM bikes WHERE id = ?", (bike_id,))
        bike = await cursor.fetchone()

    text_parts = [
        f"💰 *Текущие тарифы для «{bike['name']}»*\n",
        "*Аренда:*",
        f" • 7 дней: *{bike['rent_price_7d']} ₽*",
        f" • 14 дней: *{bike['rent_price_14d']} ₽*",
        f" • 30 дней: *{bike['rent_price_30d']} ₽*\n",
        "*Выкуп:*",
        f" • Платежей: *{bike['buyout_total_payments']}*",
        f" • Сумма платежа: *{bike['buyout_payment_amount']} ₽*",
        f" • Период: *каждые {bike['buyout_period_days']} дней*",
    ]
    
    keyboard = [
        [InlineKeyboardButton("✏️ Ред. Аренду", callback_data="tariffs_edit_rent")],
        [InlineKeyboardButton("✏️ Ред. Выкуп", callback_data="tariffs_edit_buyout")],
        [InlineKeyboardButton("⬅️ Назад", callback_data="tariffs_back_to_main")]
    ]

    await query.message.edit_text(
        "\n".join(text_parts),
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    return EDIT_TARIFFS_MENU

# --- РЕДАКТИРОВАНИЕ АРЕНДЫ ---
async def start_rent_edit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.message.edit_text("Введите новые цены для аренды на 7, 14 и 30 дней через пробел.\n\n*Пример:* `3500 6500 12000`")
    return AWAIT_RENT_PRICES

async def save_rent_prices(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        prices = [float(p) for p in update.message.text.split()]
        if len(prices) != 3: raise ValueError
    except ValueError:
        await update.message.reply_text("❌ Ошибка. Введите 3 числа через пробел. Попробуйте снова.")
        return AWAIT_RENT_PRICES

    async with aiosqlite.connect(DB_FILE) as conn:
        await conn.execute(
            "UPDATE bikes SET rent_price_7d = ?, rent_price_14d = ?, rent_price_30d = ? WHERE id = ?",
            (*prices, context.user_data['editing_bike_id'])
        )
        await conn.commit()
        
    await update.message.reply_text("✅ Тарифы аренды обновлены!")
    return await show_tariffs_menu(update, context)

# --- РЕДАКТИРОВАНИЕ ВЫКУПА (пошаговый ввод) ---
async def start_buyout_edit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.message.edit_text("Введите *общее количество* еженедельных платежей для выкупа:")
    return AWAIT_BUYOUT_PAYMENTS

async def get_buyout_payments(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        context.user_data['new_buyout_payments'] = int(update.message.text)
        await update.message.reply_text("Теперь введите *сумму одного* платежа:")
        return AWAIT_BUYOUT_AMOUNT
    except ValueError:
        await update.message.reply_text("❌ Введите целое число.")
        return AWAIT_BUYOUT_PAYMENTS

async def get_buyout_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        context.user_data['new_buyout_amount'] = float(update.message.text)
        await update.message.reply_text("Введите *периодичность* платежей в днях (например, 7 для еженедельных):")
        return AWAIT_BUYOUT_PERIOD
    except ValueError:
        await update.message.reply_text("❌ Введите корректную сумму.")
        return AWAIT_BUYOUT_AMOUNT

async def save_buyout_plan(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        period = int(update.message.text)
        bike_id = context.user_data['editing_bike_id']
        total_payments = context.user_data['new_buyout_payments']
        payment_amount = context.user_data['new_buyout_amount']

        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute(
                "UPDATE bikes SET buyout_total_payments = ?, buyout_payment_amount = ?, buyout_period_days = ? WHERE id = ?",
                (total_payments, payment_amount, period, bike_id)
            )
            await conn.commit()

        await update.message.reply_text("✅ План выкупа обновлен!")
        return await show_tariffs_menu(update, context)
    except ValueError:
        await update.message.reply_text("❌ Введите целое число дней.")
        return AWAIT_BUYOUT_PERIOD

# --- ФУНКЦИЯ ОТМЕНЫ ---
async def cancel_edit_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Завершает диалог редактирования."""
    query = update.callback_query
    await query.answer()
    await query.message.edit_text("Редактирование завершено.")
    context.user_data.clear()
    return ConversationHandler.END

async def handle_screenshot_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Специализированный обработчик для шага загрузки скриншота.
    """
    step_key = 'courier_app_screenshot'
    form_data = context.user_data.setdefault(REG_FORM_DATA, {})

    # Сохраняем file_id фото
    form_data[step_key] = update.message.photo[-1].file_id
    await update.message.reply_text("👍 Скриншот принят!")

    # Переходим к следующему шагу
    current_step_index = REGISTRATION_STEPS.index(step_key)
    context.user_data[CURRENT_REG_STEP] = REGISTRATION_STEPS[current_step_index + 1]
    return await display_registration_step(update, context)
# --- ГЛАВНАЯ ФУНКЦИЯ ДЛЯ ОТОБРАЖЕНИЯ ШАГОВ ---
async def cancel_registration(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет и сбрасывает диалог регистрации."""
    user_id = update.effective_user.id
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text("Регистрация отменена.")
    else:
        await update.message.reply_text("Регистрация отменена.")

    context.user_data.clear()
    await context.bot.send_message(user_id, "Вы вернулись в главное меню.", reply_markup=get_main_menu(user_id))
    return ConversationHandler.END


async def cancel_admin_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Универсальная функция для отмены админских диалогов (доработка/отклонение).
    """
    await update.effective_message.reply_text("Действие отменено.")
    context.user_data.clear()
    return ConversationHandler.END
# ==============================================================================
# ПОЛНАЯ И ИСПРАВЛЕННАЯ ВЕРСИЯ display_registration_step (ЗАМЕНИТЕ СТАРУЮ)
# ==============================================================================

# ==============================================================================
# ПОЛНАЯ И ИСПРАВЛЕННАЯ ВЕРСИЯ display_registration_step (ЗАМЕНИТЬ СТАРУЮ)
# ==============================================================================

# ==============================================================================
# ОБНОВЛЕННАЯ ВЕРСИЯ display_registration_step (БЕЗ НУМЕРАЦИИ)
# ==============================================================================

async def display_registration_step(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Отображает текущий шаг регистрации без нумерации шагов.
    """
    step_key = context.user_data.get(CURRENT_REG_STEP)
    message = update.effective_message
    chat_id = update.effective_chat.id

    text = ""
    keyboard_buttons = []
    use_reply_keyboard = False
    reply_markup = None

    # --- Навигационные кнопки ---
    nav_buttons = []
    # Не показываем кнопку "Назад" на первом шаге и после запроса телефона
    if step_key not in ['terms', 'phone_number']:
        nav_buttons.append(InlineKeyboardButton("⬅️ Назад", callback_data="reg_nav_back"))
    nav_buttons.append(InlineKeyboardButton("🔄 Начать заново", callback_data="reg_nav_restart"))

    # --- Логика для каждого шага (без нумерации) ---
    if step_key == 'terms':
        text = (
            "🔒 *Согласие с обработкой персональных данных*\n\n"
            "Нажимая «✅ Принимаю условия», вы соглашаетесь с [обработкой ваших персональных данных](https://badfoxbike.ru/privacy-policy.html) и правилами сервиса\\."
        )
        keyboard_buttons.append([InlineKeyboardButton("✅ Принимаю условия", callback_data="reg_input_accept_terms")])

    elif step_key == 'first_name':
        text = "✍️ *Ваше имя*\n\nВведите ваше имя, как в паспорте \\(например, _Иван_\\)\\."

    elif step_key == 'last_name':
        text = "✍️ *Ваша фамилия*\n\nВведите вашу фамилию \\(например, _Иванов_\\)\\."

    elif step_key == 'phone_number':
        use_reply_keyboard = True
        text = "📱 *Номер телефона*\n\nНажмите кнопку ниже или введите номер вручную в формате `+7...`"
        reply_markup = ReplyKeyboardMarkup(
            [[KeyboardButton("📲 Поделиться контактом", request_contact=True)]],
            resize_keyboard=True, one_time_keyboard=True
        )
    
    # --- НОВЫЙ БЛОК ДЛЯ ВОДИТЕЛЬСКИХ ПРАВ ---
    elif step_key == 'has_license':
        text = "🚙 *Водительские права*\n\nЕсть ли у вас водительские права?"
        keyboard_buttons.extend([
            [InlineKeyboardButton("✅ Да, есть", callback_data="reg_license_yes")],
            [InlineKeyboardButton("❌ Нет", callback_data="reg_license_no")]
        ])
    # --- КОНЕЦ НОВОГО БЛОКА ---

    elif step_key == 'delivery_service':
        text = "🚚 *Место работы*\n\nВыберите вашу службу доставки:"
        keyboard_buttons.extend([
            [InlineKeyboardButton("🌿 ВкусВилл", callback_data='reg_input_ВкусВилл')],
            [InlineKeyboardButton("🟡 Яндекс Еда/Лавка", callback_data='reg_input_Яндекс')],
            [InlineKeyboardButton("🔴 Магнит Доставка", callback_data='reg_input_Магнит')],
            [InlineKeyboardButton("🍔 Бургер Кинг / KFC", callback_data='reg_input_Бургер Кинг/KFC')],
            [InlineKeyboardButton("🛴 Самокат", callback_data='reg_input_Самокат')],
            [InlineKeyboardButton("🍏 Другой магазин", callback_data='reg_input_Другой магазин')],
            [InlineKeyboardButton("❓ Другая служба", callback_data='reg_input_Другое')],
        ])

    elif step_key == 'select_country':
        text = "🌍 *Гражданство*\n\nВыберите ваше гражданство:"
        keyboard_buttons.extend([
            [InlineKeyboardButton("🇷🇺 Российская Федерация", callback_data="reg_country_РФ")],
            [InlineKeyboardButton("🌍 Другая страна", callback_data="reg_country_Другая")]
        ])

    elif step_key == 'documents':
        country = context.user_data.get(REG_FORM_DATA, {}).get('country')
        doc_list_raw = ""
        photos_count_text = ""
        if country == 'РФ':
            doc_list_raw = "1. Основной разворот паспорта.\n2. Разворот с пропиской."
            photos_count_text = "отправьте *2 фотографии*"
        else:
            doc_list_raw = "1. Основной разворот паспорта.\n2. Документ о регистрации в РФ.\n3. Патент на работу."
            photos_count_text = "отправьте *3 фотографии*"

        doc_list_escaped = escape_markdown(doc_list_raw, version=2)

        text = (
            f"📸 *Документы*\n\n"
            f"Пожалуйста, *ОДНИМ СООБЩЕНИЕМ* {photos_count_text}:\n{doc_list_escaped}\n\n"
            f"💡 _Выделите нужные фото в галерее и нажмите 'Отправить'_\\."
        )

    # --- Сборка клавиатуры и отправка/редактирование сообщения ---
    if not use_reply_keyboard:
        if nav_buttons:
            keyboard_buttons.append(nav_buttons)
        if keyboard_buttons:
            reply_markup = InlineKeyboardMarkup(keyboard_buttons)

    try:
        if update.callback_query:
            await message.edit_text(text, reply_markup=reply_markup, parse_mode="MarkdownV2", disable_web_page_preview=True)
        else:
            # Удаляем старое сообщение с ReplyKeyboard, если оно было
            if step_key == 'has_license' and context.user_data.get('last_reply_message_id'):
                 try:
                     await context.bot.delete_message(chat_id, context.user_data.pop('last_reply_message_id'))
                 except: pass

            sent_message = await context.bot.send_message(chat_id, text, reply_markup=reply_markup, parse_mode="MarkdownV2", disable_web_page_preview=True)
            if use_reply_keyboard:
                context.user_data['last_reply_message_id'] = sent_message.message_id
    except Exception as e:
        if "Message is not modified" not in str(e):
            logger.error(f"Ошибка в display_registration_step: {e}")

    # --- Определение следующего состояния для ConversationHandler ---
    if step_key == 'select_country':
        return REG_AWAIT_COUNTRY
    if step_key == 'documents':
        return REG_AWAIT_DOCS
    if step_key == 'has_license':
        return REG_AWAIT_LICENSE_CHOICE
    else:
        return REG_AWAIT_INPUT
    
# ДОБАВЬТЕ ЭТИ ДВЕ НОВЫЕ ФУНКЦИИ В ВАШ КОД

async def handle_license_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает выбор 'Да/Нет' о наличии водительских прав."""
    query = update.callback_query
    await query.answer()

    choice = query.data.split('_')[-1] # yes или no
    form_data = context.user_data.setdefault(REG_FORM_DATA, {})
    form_data['has_license'] = "Да" if choice == "yes" else "Нет"

    if choice == "yes":
        # Если есть права, запрашиваем фото
        await query.message.edit_text("Пожалуйста, отправьте фотографию ваших водительских прав.")
        return REG_AWAIT_LICENSE_PHOTO
    else:
        # Если прав нет, переходим к следующему шагу
        current_step_index = REGISTRATION_STEPS.index('has_license')
        context.user_data[CURRENT_REG_STEP] = REGISTRATION_STEPS[current_step_index + 1]
        return await display_registration_step(update, context)

async def handle_license_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Принимает фото водительских прав и переходит к следующему шагу."""
    if not update.message or not update.message.photo:
        await update.message.reply_text("Пожалуйста, отправьте именно фотографию.")
        return REG_AWAIT_LICENSE_PHOTO

    form_data = context.user_data.setdefault(REG_FORM_DATA, {})
    form_data['license_photo_file_id'] = update.message.photo[-1].file_id
    await update.message.reply_text("✅ Фото прав принято!")

    # Переходим к следующему шагу
    current_step_index = REGISTRATION_STEPS.index('has_license')
    context.user_data[CURRENT_REG_STEP] = REGISTRATION_STEPS[current_step_index + 1]
    return await display_registration_step(update, context)

# --- ТОЧКИ ВХОДА И ОБРАБОТЧИКИ ---

async def register(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Начинает или перезапускает процесс регистрации."""
    context.user_data.clear()
    context.user_data[CURRENT_REG_STEP] = 'terms'
    context.user_data[REG_FORM_DATA] = {}
    return await display_registration_step(update, context)

async def handle_registration_nav(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает навигацию: Назад и Начать заново."""
    query = update.callback_query
    await query.answer()
    action = query.data.split('_')[-1]

    if action == 'restart':
        await register(update, context) # Полный сброс
        return REG_AWAIT_INPUT

    elif action == 'back':
        current_step_index = REGISTRATION_STEPS.index(context.user_data.get(CURRENT_REG_STEP))
        if current_step_index > 0:
            # Просто удаляем последний заполненный ответ и возвращаемся на шаг назад
            last_step_key = REGISTRATION_STEPS[current_step_index - 1]
            context.user_data.get(REG_FORM_DATA, {}).pop(last_step_key, None)
            context.user_data[CURRENT_REG_STEP] = last_step_key

    return await display_registration_step(update, context)

async def handle_registration_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обрабатывает любой ввод пользователя на текущем шаге."""
    step_key = context.user_data.get(CURRENT_REG_STEP)
    form_data = context.user_data.setdefault(REG_FORM_DATA, {})

    user_input = None
    if update.callback_query:
        await update.callback_query.answer()
        if update.callback_query.data.startswith("reg_input_"):
            user_input = update.callback_query.data.replace("reg_input_", "")
    elif update.message:
        if update.message.text: user_input = update.message.text.strip()
        elif update.message.contact:
            raw_phone = update.message.contact.phone_number
            user_input = '+' + re.sub(r"[^\d]", "", raw_phone)
        elif update.message.photo:
            user_input = update.message.photo[-1].file_id

    # Валидация
    # (Здесь можно добавить более строгие проверки, как в ваших старых функциях)
    if user_input:
        form_data[step_key] = user_input
        if step_key == 'phone_number':
             await update.message.reply_text(f"✅ Номер принят.", reply_markup=ReplyKeyboardRemove())
    else:
        # Если ввод не подходит (например, текст вместо фото), просто ничего не делаем
        return REG_AWAIT_INPUT

    # Переход к следующему шагу
    current_step_index = REGISTRATION_STEPS.index(step_key)
    context.user_data[CURRENT_REG_STEP] = REGISTRATION_STEPS[current_step_index + 1]
    return await display_registration_step(update, context)

# Замените вашу старую функцию handle_country_selection на эту

# ==============================================================================
# ИСПРАВЛЕННАЯ ВЕРСИЯ handle_country_selection
# ==============================================================================
async def handle_country_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Обрабатывает выбор страны.
    Если выбрана "Другая страна", предлагает загрузить документы ИЛИ пропустить.
    """
    query = update.callback_query
    await query.answer()

    country = query.data.split('_')[-1]
    form_data = context.user_data.setdefault(REG_FORM_DATA, {})
    form_data['country'] = country

    # --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ ЗДЕСЬ ---

    if country == 'РФ':
        # Для граждан РФ сразу переходим к загрузке документов без вариантов
        context.user_data[CURRENT_REG_STEP] = 'documents'
        return await display_registration_step(update, context)

    elif country == 'Другая':
        # Для иностранцев показываем новый экран с выбором: загрузить или пропустить
        text = "🌍 Вы выбрали 'Другая страна'.\n\nДальнейшие действия:"
        keyboard = [
            # Кнопка для старта загрузки документов
            [InlineKeyboardButton("📸 Загрузить документы", callback_data="reg_action_uploaddocs")],
            # Кнопка для пропуска
            [InlineKeyboardButton("⏩ Пропустить этот шаг", callback_data="reg_action_skipdocs")]
        ]
        await query.message.edit_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

        # Мы остаемся в том же состоянии, но ждем нажатия на одну из новых кнопок
        return REG_AWAIT_COUNTRY

# ==============================================================================
# НОВЫЙ ОБРАБОТЧИК ДЛЯ ДЕЙСТВИЙ ИНОСТРАНЦА
# ==============================================================================
async def handle_foreigner_doc_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Обрабатывает выбор иностранного гражданина: загрузить документы или пропустить.
    """
    query = update.callback_query
    await query.answer()

    action = query.data.split('_')[-1] # uploaddocs или skipdocs
    form_data = context.user_data.get(REG_FORM_DATA, {})

    if action == 'uploaddocs':
        # Если решили загружать, переходим на шаг 'documents'
        context.user_data[CURRENT_REG_STEP] = 'documents'
        return await display_registration_step(update, context)

    elif action == 'skipdocs':
        # Если решили пропустить, вызываем финальную функцию сохранения с пустыми данными
        await query.message.edit_text("✅ Вы пропустили шаг загрузки документов. Завершаю регистрацию...")
        await finalize_registration_and_save(
            chat_id=query.message.chat_id,
            user_id=query.from_user.id,
            form_data=form_data,
            recognized_data={"статус": "Документы не загружены"},
            context=context
        )
        return ConversationHandler.END

# --- ОБРАБОТКА ГРУППЫ ФОТО ---
# Добавьте эту функцию в блок с другими функциями регистрации

async def handle_verification_result(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обрабатывает ответ пользователя после сверки данных с Gemini."""
    query = update.callback_query
    await query.answer()

    if query.data == 'reg_verify_ok':
        # Если все верно, вызываем финальную функцию сохранения
        await query.message.edit_text("Отлично! Сохраняю ваш профиль...")
        # Передаем данные в финальную функцию
        await finalize_registration_and_save(
            chat_id=query.message.chat_id,
            user_id=query.from_user.id,
            form_data=context.user_data.get(REG_FORM_DATA, {}),
            recognized_data=context.user_data.get('recognized_passport_data', {}),
            context=context
        )
        return ConversationHandler.END # Завершаем диалог

    elif query.data == 'reg_verify_retry':
        # Если нужно отправить заново, очищаем кэш фото и возвращаем на шаг загрузки
        context.user_data.pop(MEDIA_GROUP_CACHE, None)
        context.user_data[CURRENT_REG_STEP] = 'documents'
        return await display_registration_step(update, context)
# ==============================================================================
# УПРОЩЕННЫЙ ОБРАБОТЧИК ФОТО (ЗАМЕНИТЬ СТАРЫЙ)
# ==============================================================================
# ==============================================================================
# ПОЛНАЯ РАБОЧАЯ ВЕРСИЯ handle_document_photos (ЗАМЕНИТЬ СТАРУЮ)
# ==============================================================================
# ==============================================================================
# ИСПРАВЛЕННАЯ ВЕРСИЯ handle_document_photos (с разным кол-вом фото)
# ==============================================================================
# ==============================================================================
# ФИНАЛЬНАЯ ИСПРАВЛЕННАЯ ВЕРСИЯ handle_document_photos
# ==============================================================================
# ==============================================================================
# ФИНАЛЬНАЯ ИСПРАВЛЕННАЯ ВЕРСИЯ handle_document_photos
# ==============================================================================
# Убедитесь, что все эти импорты есть в начале вашего основного файла
from pathlib import Path
import os
import json
import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold
from PIL import Image
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# ... (остальные ваши импорты и константы) ...

async def handle_document_photos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Принимает ОДНУ фотографию, кэширует ее и, если все фото собраны,
    запускает Gemini, распознает данные и переходит к шагу верификации.
    """
    message = update.message
    user_id = message.from_user.id

    if MEDIA_GROUP_CACHE not in context.user_data:
        context.user_data[MEDIA_GROUP_CACHE] = []

    context.user_data[MEDIA_GROUP_CACHE].append(message.photo[-1].file_id)
    photo_count = len(context.user_data[MEDIA_GROUP_CACHE])

    # --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
    country = context.user_data.get(REG_FORM_DATA, {}).get('country')
    required_photos = 3 if country != 'РФ' else 2

    if photo_count < required_photos:
        await message.reply_text(f"✅ Фото {photo_count}/{required_photos} принято. Пожалуйста, отправьте следующее.")
        return REG_AWAIT_DOCS
    # --- КОНЕЦ ИЗМЕНЕНИЯ ---

    await message.reply_text(f"✅ Все {required_photos} фото получены. Запускаю распознавание... Это может занять до 45 секунд. 🕒")

    photo_ids = context.user_data.pop(MEDIA_GROUP_CACHE)
    context.user_data[REG_FORM_DATA]['document_file_ids'] = photo_ids

    temp_dir = Path("temp_passport_photos")
    temp_dir.mkdir(exist_ok=True)
    paths = []

    try:
        for i, file_id in enumerate(photo_ids):
            photo_file = await context.bot.get_file(file_id)
            path = temp_dir / f"{user_id}_doc_{i+1}.jpg"
            await photo_file.download_to_drive(path)
            paths.append(str(path))

        recognized_data = {}

        safety_settings = {
            HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_NONE,
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_NONE,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_NONE,
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_NONE,
        }
        model = genai.GenerativeModel('gemini-2.5-flash-lite', safety_settings=safety_settings)
        images_for_gemini = [Image.open(p) for p in paths]

        # --- ИЗМЕНЕНИЕ ЗДЕСЬ (Промпт для иностранцев) ---
        if country == 'РФ':
            prompt = """
            Проанализируй эти три изображения: основной разворот паспорта РФ, страница с пропиской и селфи с паспортом.
            Извлеки все данные и верни их в виде ОДНОГО плоского JSON объекта.
            Ключи: "Фамилия", "Имя", "Отчество", "Дата рождения", "Серия и номер паспорта", "Кем выдан", "Дата выдачи", "Адрес регистрации".
            Если поле не найдено, значение должно быть пустой строкой.
            Ответ должен быть только чистым JSON.
            """
        else:
            prompt = """
            Проанализируй эти четыре изображения: паспорт иностранного гражданина, регистрация в РФ, патент и селфи с паспортом.
            Извлеки все данные и верни их в виде ОДНОГО плоского JSON объекта.
            Ключи: "ФИО", "Гражданство", "Дата рождения", "Номер паспорта", "Адрес регистрации в РФ", "Номер патента".
            Если поле не найдено, значение должно быть пустой строкой.
            Ответ должен быть только чистым JSON.
            """
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---

        response = model.generate_content([prompt] + images_for_gemini, request_options={"timeout": 120})
        response.resolve()

        cleaned_text = response.text.strip().replace("`", "").lstrip("json").strip()
        recognized_data = json.loads(cleaned_text)

        if not recognized_data or not isinstance(recognized_data, dict):
            raise ValueError("Gemini не вернул корректный словарь.")

        context.user_data['recognized_passport_data'] = recognized_data

        verification_text = "🤖 **Давайте сверим данные:**\n\n"
        for key, value in recognized_data.items():
            if value:
                verification_text += f"▪️ {escape_markdown(key, 2)}: `{escape_markdown(str(value), 2)}`\n"
        verification_text += "\nВсе ли данные верны?"

        keyboard = [
            [InlineKeyboardButton("✅ Да, всё верно", callback_data="reg_verify_ok")],
            [InlineKeyboardButton("🔄 Отправить фото заново", callback_data="reg_verify_retry")],
        ]

        await message.reply_text(verification_text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="MarkdownV2")

        return REG_AWAIT_VERIFICATION

    except Exception as e:
        logger.error(f"Ошибка при обработке документов для {user_id}: {e}", exc_info=True)
        await message.reply_text("😔 Ошибка распознавания. Попробуйте еще раз с более четкими фото. Нажмите '⬅️ Назад', чтобы вернуться к шагу загрузки документов.")
        context.user_data.pop(MEDIA_GROUP_CACHE, None)
        return REG_AWAIT_DOCS
    finally:
        for p in paths:
            if os.path.exists(p):
                try:
                    os.remove(p)
                except OSError as e:
                    logger.error(f"Ошибка удаления временного файла {p}: {e}")




async def process_document_group(context: ContextTypes.DEFAULT_TYPE):
    """
    Проверяет количество фото, запускает Gemini и переходит к верификации,
    используя данные, полученные из JobQueue.
    """
    job = context.job
    # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
    # Извлекаем все данные из job.data
    chat_id = job.chat_id
    media_group_id = job.data['media_group_id']
    user_id = job.data['user_id']
    form_data = job.data['form_data']
    current_reg_step = job.data['current_reg_step']
    # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

    media_group_data = context.bot_data.pop(media_group_id, None)
    if not media_group_data: return

    photo_ids = media_group_data['photos']

    if len(photo_ids) != 3:
        await context.bot.send_message(
            chat_id,
            f"❌ **Ошибка!** Вы отправили {len(photo_ids)} фото, а нужно ровно 3. "
            "Нажмите '⬅️ Назад', чтобы вернуться к шагу загрузки документов."
        )
        return

    await context.bot.send_message(chat_id, "✅ 3 фото получены. Запускаю распознавание... Это может занять до 45 секунд. 🕒")

    # <<< ИЗМЕНЕНИЕ: Мы уже получили form_data, просто добавляем в него file_ids >>>
    form_data['document_file_ids'] = photo_ids

    # --- Логика Gemini ---
    temp_dir = Path("temp_passport_photos")
    temp_dir.mkdir(exist_ok=True)
    paths = []
    try:
        for i, file_id in enumerate(photo_ids):
            photo_file = await context.bot.get_file(file_id)
            path = temp_dir / f"{user_id}_doc_{i+1}.jpg"
            await photo_file.download_to_drive(path)
            paths.append(str(path))

        country = form_data.get('country')
        recognized_data = {}
        if country == 'РФ':
            recognized_data = get_passport_data_with_gemini(image_path=paths[0])
            reg_data = get_registration_data_with_gemini(image_path=paths[1])
            if reg_data: recognized_data.update(reg_data)
        else:
            recognized_data = get_foreign_documents_data_with_gemini(paths[0], paths[1], paths[2])

        if not recognized_data: raise ValueError("Gemini не вернул данные.")

        # <<< ИЗМЕНЕНИЕ: Вызываем финальную функцию, передавая ей все данные явно >>>
        await finalize_registration_and_save(chat_id, user_id, form_data, recognized_data, context)

    except Exception as e:
        logger.error(f"Ошибка при обработке документов для {chat_id}: {e}", exc_info=True)
        await context.bot.send_message(chat_id, "😔 Ошибка распознавания. Попробуйте еще раз с более четкими фото. Нажмите '⬅️ Назад'.")
    finally:
        for p in paths:
            if os.path.exists(p): os.remove(p)
# <<< НАЧАЛО НОВОГО БЛОКА КОДА ДЛЯ ОБРАБОТКИ ВЕРИФИКАЦИИ >>>
# ==============================================================================
# ПОЛНАЯ ИСПРАВЛЕННАЯ ВЕРСИЯ finalize_registration_and_save
# ==============================================================================

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

async def finalize_registration_and_save(chat_id: int, user_id: int, form_data: dict, recognized_data: dict, context: ContextTypes.DEFAULT_TYPE):
    """
    Финальная универсальная функция:
    1. Сохраняет фото документов (включая права) в папку.
    2. Сохраняет все данные в БД.
    3. Отправляет АДМИНИСТРАТОРАМ уведомление с фото и кнопками.
    """
    await context.bot.send_message(chat_id, "⏳ Сохраняю ваш профиль, это займет несколько секунд...")

    if not form_data:
        logger.error(f"Критическая ошибка: нет данных для сохранения user_id: {user_id}")
        await context.bot.send_message(chat_id, "Произошла внутренняя ошибка. Пожалуйста, начните регистрацию заново.")
        return ConversationHandler.END

    country = form_data.get('country', 'Не указано')
    photo_ids = form_data.get('document_file_ids', [])
    license_photo_id = form_data.get('license_photo_file_id') # <-- ПОЛУЧАЕМ ID ФОТО ПРАВ
    user_tg_username = (await context.bot.get_chat(user_id)).username

    # --- 1. Сохранение фотографий на диск ---
    passport_folder_path = None
    try:
        base_path = Path(DOCUMENTS_PATH)
        user_folder_name = f"{country}_{form_data.get('last_name', 'user')}_{user_id}"
        user_path = base_path / user_folder_name
        user_path.mkdir(parents=True, exist_ok=True)
        passport_folder_path = str(user_path)

        filenames = (
            ["1_main_passport.jpg", "2_registration_passport.jpg"]
            if country == 'РФ' else
            ["1_foreign_passport.jpg", "2_registration.jpg", "3_patent.jpg"]
        )

        for i, file_id in enumerate(photo_ids):
            if i < len(filenames):
                photo_file = await context.bot.get_file(file_id)
                await photo_file.download_to_drive(user_path / filenames[i])
        
        # <-- СОХРАНЯЕМ ФОТО ПРАВ, ЕСЛИ ОНО ЕСТЬ -->
        if license_photo_id:
            photo_file = await context.bot.get_file(license_photo_id)
            await photo_file.download_to_drive(user_path / "4_drivers_license.jpg")

        logger.info(f"Фото для пользователя {user_id} сохранены в папку: {passport_folder_path}")
    except Exception as e:
        logger.error(f"Ошибка при скачивании фото для user_id {user_id}: {e}", exc_info=True)

    # --- 2. Сохранение данных в БД ---
    try:
        passport_data_json = json.dumps(recognized_data, ensure_ascii=False) if recognized_data else None

        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("SELECT id FROM users WHERE id = ?", (user_id,))
            exists = await cursor.fetchone()

            db_data = {
                "username": user_tg_username,
                "first_name": form_data.get('first_name'),
                "last_name": form_data.get('last_name'),
                "phone_number": form_data.get('phone_number'),
                "delivery_service": form_data.get('delivery_service'),
                "passport_photo": passport_folder_path,
                "verified": 0,
                "country": country,
                "passport_data": passport_data_json,
                "has_license": form_data.get('has_license'),      # <-- НОВОЕ ПОЛЕ
                "license_photo": license_photo_id,                # <-- НОВОЕ ПОЛЕ
            }

            if exists:
                set_clause = ", ".join([f"{key} = ?" for key in db_data.keys()])
                sql = f'UPDATE users SET {set_clause} WHERE id = ?'
                values = list(db_data.values()) + [user_id]
                await conn.execute(sql, values)
            else:
                db_data['id'] = user_id
                columns = ', '.join(db_data.keys())
                placeholders = ', '.join('?' * len(db_data))
                sql = f'INSERT INTO users ({columns}) VALUES ({placeholders})'
                await conn.execute(sql, tuple(db_data.values()))

            await conn.commit()
        logger.info(f"Данные для пользователя {user_id} сохранены/обновлены в БД.")

    except Exception as e:
        logger.error(f"Ошибка при сохранении данных пользователя {user_id} в БД: {e}", exc_info=True)
        await context.bot.send_message(chat_id, "❌ Произошла ошибка при сохранении профиля в базу данных.")
        return ConversationHandler.END

    # --- 3. Финальные уведомления ---
    try:
        notification_text = (
            f"🚀 *Новый пользователь на верификацию\\!* \n\n"
            f"**ФИО:** {escape_markdown(form_data.get('first_name', ''), 2)} {escape_markdown(form_data.get('last_name', ''), 2)}\n"
            f"**ID:** `{user_id}`\n"
            f"**Телефон:** `{escape_markdown(form_data.get('phone_number', 'нет'), 2)}`\n"
            f"**Гражданство:** {escape_markdown(country, 2)}\n"
            f"**Вод\\. права:** {escape_markdown(form_data.get('has_license', 'Нет'), 2)}\n\n" # <-- ИНФО О ПРАВАХ
            f"*Распознанные данные:*\n"
        )
        if recognized_data:
            for key, value in recognized_data.items():
                if value:
                    notification_text += f" • {escape_markdown(key, 2)}: `{escape_markdown(str(value), 2)}`\n"
        else:
             notification_text += "_Распознавание документов не проводилось\\._\n"


        # <-- ФОРМИРУЕМ ГРУППУ ФОТО ДЛЯ АДМИНА -->
        media_group = []
        if photo_ids:
            media_group.extend([InputMediaPhoto(media=file_id) for file_id in photo_ids])
        if license_photo_id:
            media_group.append(InputMediaPhoto(media=license_photo_id, caption="Водительские права"))

        keyboard = [
            [InlineKeyboardButton("✅ Подтвердить", callback_data=f"verify_{user_id}")],
            [InlineKeyboardButton("✏️ На доработку", callback_data=f"rework_{user_id}")],
            [InlineKeyboardButton("❌ Отклонить", callback_data=f"reject_verification_{user_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        for admin_id in ADMIN_IDS:
            if media_group:
                # Отправляем все фото (паспорт + права) одной группой
                await context.bot.send_media_group(admin_id, media=media_group)
            # Отправляем текстовую информацию с кнопками
            await context.bot.send_message(admin_id, notification_text, parse_mode="MarkdownV2", reply_markup=reply_markup)

    except Exception as e:
        logger.error(f"Ошибка отправки уведомления админам для user {user_id}: {e}")

    await context.bot.send_message(
        chat_id,
        "✅ **Регистрация успешно завершена\\!**\n\nВаши данные отправлены на проверку\\.",
        parse_mode="MarkdownV2",
        reply_markup=get_main_menu(user_id)
    )
    return ConversationHandler.END
# --- ОБЩАЯ ФУНКЦИЯ ДЛЯ ОТМЕНЫ ДИАЛОГОВ ---
async def cancel_verification_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет диалог ввода причины доработки/отклонения."""
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text("Действие отменено.")
    else:
        await update.message.reply_text("Действие отменено.")
    context.user_data.clear()
    return ConversationHandler.END

# --- ЛОГИКА ДЛЯ КНОПКИ "НА ДОРАБОТКУ" ---

async def cancel_verification_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет диалог ввода причины доработки/отклонения."""
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text("Действие отменено.")
    else:
        await update.message.reply_text("Действие отменено.")
    context.user_data.clear()
    return ConversationHandler.END

# --- ЛОГИКА ДЛЯ КНОПКИ "НА ДОРАБОТКУ" ---

async def start_rework_verification(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1 (Доработка): Запрашивает у админа причину для доработки."""
    query = update.callback_query
    await query.answer()

    user_id_to_rework = int(query.data.split('_')[1])
    context.user_data['user_id_for_action'] = user_id_to_rework

    # Скрываем кнопки у исходного сообщения, чтобы избежать повторных нажатий
    await query.edit_message_reply_markup(reply_markup=None)

    await query.message.reply_text(
        f"✍️ Введите причину, по которой пользователю ID {user_id_to_rework} нужно доработать заявку.\n"
        "Этот текст будет отправлен пользователю."
    )
    return AWAIT_REWORK_REASON


async def send_rework_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 2 (Доработка): Отправляет сообщение пользователю, УДАЛЯЕТ его запись из БД
    для принудительной повторной регистрации и завершает диалог.
    """
    rework_reason = update.message.text
    user_id = context.user_data.get('user_id_for_action')
    admin_user = update.message.from_user

    if not user_id:
        await update.message.reply_text("🚫 Ошибка: не найден ID пользователя. Операция отменена.")
        return ConversationHandler.END

    try:
        # 1. Сначала уведомляем пользователя
        user_message = (
            f"⚠️ **Ваша заявка на верификацию требует доработки.**\n\n"
            f"**Комментарий от администратора:**\n_{rework_reason}_\n\n"
            "Пожалуйста, исправьте указанные недочеты и пройдите регистрацию заново, нажав на кнопку '📝 Зарегистрироваться' в главном меню."
        )
        await context.bot.send_message(chat_id=user_id, text=user_message, parse_mode="Markdown")

        # <<< ГЛАВНОЕ ИЗМЕНЕНИЕ: Удаляем пользователя из БД >>>
        # Это заставит его пройти регистрацию с нуля.
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM users WHERE id = ?", (user_id,))
        conn.commit()
        conn.close()
        # <<< КОНЕЦ ИЗМЕНЕНИЯ >>>

        # 2. Уведомляем администратора об успехе
        await update.message.reply_text(f"✅ Сообщение о доработке отправлено. Профиль пользователя ID {user_id} сброшен для повторной регистрации.")

        # 3. Логируем действие
        log_bike_action(None, user_id, "Верификация: доработка", f"Админ {admin_user.full_name} отправил на доработку. Причина: {rework_reason}")

    except Exception as e:
        logger.error(f"Ошибка в send_rework_reason для пользователя {user_id}: {e}")
        await update.message.reply_text(f"🚫 Произошла ошибка: {e}")

    context.user_data.clear()
    return ConversationHandler.END

# --- ЛОГИКА ДЛЯ КНОПКИ "ОТКЛОНИТЬ" ---

async def start_reject_verification(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1 (Отклонение): Запрашивает у админа причину отклонения."""
    query = update.callback_query
    await query.answer()

    user_id_to_reject = int(query.data.split('_')[2])
    context.user_data['user_id_for_action'] = user_id_to_reject

    await query.edit_message_reply_markup(reply_markup=None)
    await query.message.reply_text(
        f"✍️ Введите причину отклонения верификации для пользователя ID {user_id_to_reject}.\n"
        "Этот текст будет отправлен пользователю."
    )
    return AWAIT_REJECT_REASON


async def send_reject_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (Отклонение): Отправляет сообщение пользователю и удаляет его из БД."""
    reject_reason = update.message.text
    user_id = context.user_data.get('user_id_for_action')
    admin_user = update.message.from_user

    if not user_id:
        await update.message.reply_text("🚫 Ошибка: не найден ID пользователя. Операция отменена.")
        return ConversationHandler.END

    try:
        # Уведомляем пользователя
        user_message = (
            f"❌ **Ваша заявка на верификацию была отклонена.**\n\n"
            f"**Причина:**\n_{reject_reason}_\n\n"
            "Если вы считаете, что это ошибка, свяжитесь с поддержкой."
        )
        await context.bot.send_message(chat_id=user_id, text=user_message, parse_mode="Markdown")

        # Удаляем пользователя из БД
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM users WHERE id = ?", (user_id,))
        conn.commit()
        conn.close()

        await update.message.reply_text(f"✅ Верификация для пользователя ID {user_id} отклонена. Пользователь уведомлен и удален из базы данных.")
        log_bike_action(None, user_id, "Верификация: отклонена", f"Админ {admin_user.full_name} отклонил заявку. Причина: {reject_reason}")

    except Exception as e:
        logger.error(f"Ошибка при отклонении верификации для пользователя {user_id}: {e}")
        await update.message.reply_text(f"🚫 Произошла ошибка: {e}")

    context.user_data.clear()
    return ConversationHandler.END

# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>
# Функция для получения главного меню (заглушка)


from PIL import Image, ImageDraw, ImageFont

from datetime import datetime

import os
from datetime import datetime
from PIL import Image, ImageDraw, ImageFont
import sqlite3

import os
from datetime import datetime
from PIL import Image, ImageDraw, ImageFont
import sqlite3

def create_apple_style_profile_image(user_data):
    # Определяем путь к папке users
    users_dir = r"C:\Users\Kerpat\source\repos\PythonApplication12\PythonApplication12\users"

    # Создаем папку, если она не существует
    os.makedirs(users_dir, exist_ok=True)

    # Путь к шрифтам
    font_path_bold = r"C:\Users\Kerpat\Downloads\sf-ui-display-black.ttf"  # Для заголовков
    font_path_italic = r"C:\Users\Kerpat\Downloads\sf-ui-text-heavy-italic.ttf"  # Для значений (курсив)

    # Путь к фоновому изображению
    background_image_path = "apple.png"

    # Загрузка фонового изображения
    try:
        background = Image.open(background_image_path).convert('RGB')
        background = background.resize((1280, 720))  # Уменьшенный размер изображения
    except IOError:
        print("Фоновое изображение не найдено. Используется однотонный фон.")
        background = Image.new('RGB', (1280, 720), color=(240, 240, 240))  # Запасной фон

    image_width, image_height = background.size

    # Размеры шрифтов
    name_font_size = int(image_width * 0.06)  # Крупный шрифт для имени и фамилии
    text_font_size = int(image_width * 0.025)  # Размер для заголовков и значений

    # Отступы
    margin_x = int(image_width * 0.05)  # Уменьшенный отступ по горизонтали
    margin_y = int(image_height * 0.05)  # Уменьшенный отступ сверху

    # Шаг для вертикального смещения
    y_offset_increment = int(image_height * 0.03)  # Уменьшенный шаг для вертикального смещения

    draw = ImageDraw.Draw(background)

    # Загрузка шрифтов
    try:
        name_font = ImageFont.truetype(font_path_bold, name_font_size)  # Шрифт для имени и фамилии
        header_font = ImageFont.truetype(font_path_bold, text_font_size)  # Шрифт для заголовков
        value_font = ImageFont.truetype(font_path_italic, text_font_size)  # Шрифт для значений (курсив)
    except IOError:
        print("Шрифт не найден. Используются стандартные шрифты.")
        name_font = ImageFont.load_default()
        header_font = ImageFont.load_default()
        value_font = ImageFont.load_default()

    # Имя и фамилия (крупный шрифт)
    name = f"{user_data.get('first_name', '')} {user_data.get('last_name', '')}"
    name_bbox = draw.textbbox((0, 0), name, font=name_font)
    name_width = name_bbox[2] - name_bbox[0]
    name_height = name_bbox[3] - name_bbox[1]

    # Позиция имени и фамилии по центру
    x_center = (image_width - name_width) // 2  # Центр по горизонтали
    y_offset = margin_y  # Отступ сверху
    draw.text((x_center, y_offset), name, font=name_font, fill=(255, 255, 255))  # Белый текст

    # Отступ после имени и фамилии
    y_offset += name_height + y_offset_increment * 2  # Больше отступ после заголовка

    # Получаем статусы аренды и очереди из базы данных
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем последний статус бронирования пользователя
    cursor.execute("""
        SELECT status, booking_date, end_date
        FROM bookings
        WHERE user_id = ?
        ORDER BY booking_date DESC
        LIMIT 1
    """, (user_data['id'],))
    last_booking = cursor.fetchone()

    # Получаем место пользователя в очереди
    cursor.execute("""
        SELECT q.user_id, q.created_at, q.status, u.first_name, u.last_name
        FROM queue q
        JOIN users u ON q.user_id = u.id
        ORDER BY q.created_at
    """)
    queue = cursor.fetchall()

    # Определяем место пользователя в очереди
    user_position = None
    queue_pending = False
    is_first_user = False  # Флаг для статуса first_user
    if queue:
        for idx, (queued_user_id, created_at, status, first_name, last_name) in enumerate(queue, start=1):
            if queued_user_id == user_data['id']:
                user_position = idx
                if status == "pending":
                    queue_pending = True
                if status == "first_user":
                    is_first_user = True
                break

    conn.close()

    # Формируем строку со статусами
    status_info = []
    if last_booking:
        status, booking_date, end_date = last_booking
        if status == "pending":
            # Преобразуем booking_date в формат дд.мм.гггг
            try:
                booking_date_obj = datetime.strptime(booking_date, "%Y-%m-%d %H:%M:%S")
                formatted_date = booking_date_obj.strftime("%d.%m.%Y")
                status_info.append(f"Ожидает ({formatted_date})")
            except ValueError:
                status_info.append("Ожидает (дата не указана)")
        elif status == "confirmed":
            status_info.append(f"Подтверждено на {booking_date}")
        elif status == "rented":
            status_info.append(f"Арендовано с {booking_date} по {end_date}")
        # Статусы canceled и returned не отображаем

    # Добавляем информацию о месте в очереди
    if is_first_user:
        status_info.append("Первое место в очереди")  # Явно указываем, что пользователь первый
    elif queue_pending and user_position is not None:
        status_info.append(f"В очереди на {user_position} месте")

    # Если статусов нет, добавляем "Нет активных статусов"
    if not status_info:
        status_info.append("Нет активных статусов")

    # Блоки информации
    info_blocks = [
        ("телефон", user_data.get('phone_number', 'не указано')),
        ("доставка", user_data.get('delivery_service', 'не указано')),  # Разделено: доставка
        ("план оплаты", user_data.get('payment_plan', 'не указано')),  # Разделено: план оплаты
        ("опыт", user_data.get('experience', 'не указано')),  # Разделено: опыт
        ("хранение", user_data.get('storage', 'не указано')),  # Разделено: хранение
        ("источник", user_data.get('source_of_info', 'не указано')),
        ("паспорт", "загружен" if user_data.get('passport_photo') else "отсутствует"),  # Проверка наличия фото паспорта
        ("статус", ", ".join(status_info)),  # Все статусы
        ("верификация", "верифицирован" if user_data.get('verified', 0) else "не верифицирован"),  # Проверка верификации
        ("ожидание", user_data.get('rental_period', 'не указано')),
    ]

    # Отрисовка блоков информации
    for label, value in info_blocks:
        # Заголовок (с двоеточием)
        header_text = f"{label}:"
        header_bbox = draw.textbbox((0, 0), header_text, font=header_font)
        header_height = header_bbox[3] - header_bbox[1]
        draw.text((margin_x, y_offset), header_text, font=header_font, fill=(255, 255, 255))  # Белый текст

        # Значение (курсив)
        value_bbox = draw.textbbox((0, 0), value, font=value_font)
        value_height = value_bbox[3] - value_bbox[1]
        draw.text((margin_x + int(image_width * 0.3), y_offset), value, font=value_font, fill=(200, 200, 200))  # Светло-серый текст

        # Смещение для следующего блока
        y_offset += max(header_height, value_height) + y_offset_increment

    # Сохранение изображения в папку users
    image_name = f"user_{user_data['id']}_apple_style_profile.png"
    image_path = os.path.join(users_dir, image_name)  # Полный путь к файлу
    background.save(image_path)
    print(f"Изображение сохранено: {image_path}")

    return image_path


from datetime import datetime, timedelta

# Функция для склонения слова "рубль"
def format_rubles(amount):
    if isinstance(amount, str):
        amount = int(''.join(filter(str.isdigit, amount)))  # Извлекаем число из строки
    last_digit = amount % 10
    last_two_digits = amount % 100

    if last_two_digits in [11, 12, 13, 14]:
        return f"{amount} рублей"
    elif last_digit == 1:
        return f"{amount} рубль"
    elif last_digit in [2, 3, 4]:
        return f"{amount} рубля"
    else:
        return f"{amount} рублей"

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ show_profile НА ЭТУ ПОЛНУЮ И ИСПРАВЛЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_profile НА ЭТУ ПОЛНУЮ И ИСПРАВЛЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_profile НА ЭТУ ПОЛНУЮ И ИСПРАВЛЕННУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_profile НА ЭТУ ПОЛНУЮ И ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_profile НА ЭТУ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_profile НА ЭТУ УЛУЧШЕННУЮ ВЕРСИЮ

### НОВАЯ ВЕРСИЯ с отображением ремонта к оплате и асинхронным доступом к БД ###
### НОВАЯ ВЕРСИЯ с ИСПРАВЛЕНИЕМ ТИПОВ ДАННЫХ и ПОЛНОЙ ЛОГИКОЙ ###
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_profile НА ЭТУ ПОЛНУЮ И ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_profile НА ЭТУ ПОЛНУЮ И ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ show_profile НА ЭТУ ПОЛНУЮ И ОКОНЧАТЕЛЬНУЮ ВЕРСИЮ

from datetime import datetime
from telegram.helpers import escape_markdown
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
import aiosqlite
import logging

# Предположим, у вас есть эти переменные где-то в коде
# logger = logging.getLogger(__name__)
# DB_FILE = "your_db.sqlite"
# PRODUCT_TYPE_BIKE = 'bike'
# PRODUCT_TYPE_BATTERY = 'battery'
# BUYOUT_PLANS = {} # Ваши планы рассрочек
# BATTERY_BUYOUT_PLANS = {} # Ваши планы рассрочек на аккумуляторы


import aiosqlite
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
from datetime import datetime

import aiosqlite
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
from datetime import datetime

async def show_profile(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    ПОЛНАЯ И ВОССТАНОВЛЕННАЯ ВЕРСИЯ:
    - Корректно отображает всю информацию по арендам, выкупам, ремонтам, штрафам и скидкам.
    - Возвращает все необходимые кнопки: "Продлить", "Оплатить", "Сдать товар" и т.д.
    - Использует индивидуальные тарифы выкупа из таблицы `bikes`.
    """
    user_id = update.message.from_user.id

    def escape(text: any) -> str:
        return escape_markdown(str(text or ''), version=2)

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row

            # 1. Получаем базовую информацию о пользователе
            cursor = await conn.execute("SELECT first_name, last_name, verified, passport_photo FROM users WHERE id=?", (user_id,))
            user_base_info = await cursor.fetchone()

            if not user_base_info:
                await update.message.reply_text("🚫 Вы не зарегистрированы. Пожалуйста, пройдите регистрацию.")
                return

            first_name = user_base_info['first_name']
            last_name = user_base_info['last_name']
            verified = user_base_info['verified']
            passport_photo = user_base_info['passport_photo']

            profile_parts = [
                f"🌼 *Добро пожаловать, {escape(first_name)}\! Это ваш личный кабинет*\!\n",
                f"📛 *ФИО:* {escape(first_name)} {escape(last_name)}",
                f"🟢 *Статус верификации:* {'✅ Верифицирован' if verified else '🚫 Не верифицирован'}"
            ]
            keyboard = []

            if not passport_photo:
                profile_parts.append("📄 *Фотография паспорта*: Не отправлена\\.")
                keyboard.append([InlineKeyboardButton("Отправить фотографии паспорта", callback_data='send_passport')])

            # 2. Ищем товары в собственности
            cursor = await conn.execute("SELECT name, type FROM bikes WHERE owner_id = ?", (user_id,))
            owned_items = await cursor.fetchall()
            if owned_items:
                profile_parts.append("\n🎉 *В вашей собственности:*")
                for item in owned_items:
                    emoji = "🚲" if item['type'] == 'bike' else "🔋"
                    profile_parts.append(f"• {emoji} {escape(item['name'])}")

            # 3. Ищем активные аренды и рассрочки
            cursor = await conn.execute("""
                SELECT b.id, bk.name, bk.type, b.booking_type, b.end_date,
                       b.payments_made, b.next_payment_date,
                       bk.buyout_total_payments, bk.buyout_payment_amount
                FROM bookings b
                JOIN bikes bk ON b.bike_id = bk.id
                WHERE b.user_id = ? AND b.status = 'rented'
            """, (user_id,))
            active_bookings = await cursor.fetchall()
            
            # <<< ЭТО САМАЯ ВАЖНАЯ ВОССТАНОВЛЕННАЯ ЧАСТЬ >>>
            rentals_part = []
            buyouts_part = []
            has_active_items = bool(active_bookings)

            if active_bookings:
                for booking in active_bookings:
                    booking_id = booking['id']
                    name, item_type = booking['name'], booking['type']
                    emoji = "🚲" if item_type == 'bike' else "🔋"

                    if booking['booking_type'] == 'rent':
                        end_date = booking['end_date']
                        status = " \\(дата не указана\\)"
                        if end_date:
                            try:
                                end_date_obj = datetime.strptime(end_date, '%d.%m.%Y')
                                remaining_days = (end_date_obj.date() - datetime.now().date()).days
                                status = f" \\(осталось {remaining_days} дн\\.\\)" if remaining_days >= 0 else f" \\(просрочено {-remaining_days} дн\\!\\)"
                            except (ValueError, TypeError):
                                status = " \\(ошибка в дате\\)"
                        rentals_part.append(f"• {emoji} *{escape(name)}*{status}")
                        keyboard.append([InlineKeyboardButton(f"🗓️ Продлить аренду ({name[:15]}...)", callback_data=f"auto_prolong_7_{booking_id}")])

                    elif booking['booking_type'] == 'buyout':
                        payments_made = booking['payments_made']
                        next_payment_date = booking['next_payment_date']
                        total_payments = booking['buyout_total_payments']
                        payment_amount = booking['buyout_payment_amount']
                        
                        plan_info_str = f"{total_payments} пл\\. по {payment_amount:,.0f} ₽".replace(",", " ")

                        buyouts_part.append(
                            f"\n• {emoji} *{escape(name)}*\n"
                            f"  ┣ План: {escape(plan_info_str)}\n"
                            f"  ┣ Внесено: {payments_made} из {total_payments} платежей\n"
                            f"  ┗ Следующий платеж: *до {escape(next_payment_date)}*"
                        )
                        keyboard.append([InlineKeyboardButton(f"💳 Оплатить след. платеж ({name[:15]}...)", callback_data=f"pay_next_{booking_id}")])
                        keyboard.append([InlineKeyboardButton(f"💵 Погасить досрочно ({name[:15]}...)", callback_data=f"pay_full_{booking_id}")])

            if rentals_part:
                profile_parts.append("\n*Ваши активные аренды:*")
                profile_parts.extend(rentals_part)
            if buyouts_part:
                profile_parts.append("\n*Ваши рассрочки:*")
                profile_parts.extend(buyouts_part)
            # <<< КОНЕЦ ВОССТАНОВЛЕННОЙ ЧАСТИ >>>

            # 4. Проверяем неоплаченные ремонты
            cursor = await conn.execute("SELECT rr.id, rr.estimated_price, b.name as bike_name FROM repair_requests rr JOIN bikes b ON rr.bike_id = b.id WHERE rr.user_id = ? AND rr.status = 'completed'", (user_id,))
            unpaid_repairs = await cursor.fetchall()
            if unpaid_repairs:
                profile_parts.append("\n*Ремонт к оплате:*")
                for repair in unpaid_repairs:
                    price = float(repair['estimated_price'] or 0)
                    if price > 0:
                        price_str = f"{price:.2f}"
                        profile_parts.append(f"• 🛠️ {escape(repair['bike_name'])} \\- *{escape(price_str)} ₽*")
                        keyboard.append([InlineKeyboardButton(f"💳 Оплатить ремонт ({repair['bike_name'][:15]}...)", callback_data=f"pay_repair_{repair['id']}")])

            # 5. Проверяем неоплаченные штрафы
            cursor = await conn.execute("SELECT id, amount, reason FROM fines WHERE user_id = ? AND status = 'unpaid'", (user_id,))
            unpaid_fines = await cursor.fetchall()
            if unpaid_fines:
                profile_parts.append("\n🚨 *У вас есть неоплаченные штрафы:*")
                for fine in unpaid_fines:
                    amount_str = f"{fine['amount']:.2f}"
                    profile_parts.append(f"• Штраф №{fine['id']}: *{escape(amount_str)} ₽* \\(Причина: _{escape(fine['reason'])}_\\)")
                    keyboard.append([InlineKeyboardButton(f"💳 Оплатить штраф №{fine['id']}", callback_data=f"pay_fine_{fine['id']}")])

            # 6. Кнопка "Сдать товар"
            if has_active_items:
                if keyboard: keyboard.append([InlineKeyboardButton("─" * 20, callback_data="noop")])
                keyboard.append([InlineKeyboardButton("↩️ Сдать товар", callback_data="return_bike_start")])

            # 7. Проверяем наличие скидки
            cursor = await conn.execute("SELECT amount, reason FROM discounts WHERE user_id = ? AND is_used = 0 AND expiry_date > CURRENT_TIMESTAMP LIMIT 1", (user_id,))
            discount = await cursor.fetchone()
            if discount:
                profile_parts.append(f"\n🎁 *У вас есть скидка на {discount['amount']} ₽ \\({escape(discount['reason'])}\\)\\!*")

    except Exception as e:
        logger.error(f"Ошибка при формировании профиля для user {user_id}: {e}", exc_info=True)
        await update.message.reply_text("🚫 Произошла ошибка при загрузке вашего профиля.")
        return

    final_message = "\n".join(profile_parts)
    reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None

    await update.message.reply_text(final_message, parse_mode='MarkdownV2', reply_markup=reply_markup)

# <<< НАЧАЛО НОВОГО БЛОКА КОДА >>>

async def start_fine_payment_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Вызывается, когда пользователь нажимает кнопку "Оплатить штраф" в ЛК.
    Формирует и отправляет счет на оплату через ЮKassa.
    """
    query = update.callback_query
    await query.answer()

    fine_id = int(query.data.split("_")[2])
    user_id = query.from_user.id

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            # Получаем данные о штрафе и номер телефона пользователя для чека
            cursor = await conn.execute("""
                SELECT f.amount, f.reason, u.phone_number
                FROM fines f
                JOIN users u ON f.user_id = u.id
                WHERE f.id=? AND f.user_id=?
            """, (fine_id, user_id))
            data = await cursor.fetchone()

        if not data:
            await query.message.edit_text("🚫 Ошибка: штраф не найден или уже оплачен.")
            return

        price = float(data['amount'])
        if not data['phone_number']:
            await query.message.edit_text("🚫 Ошибка: не указан номер телефона в вашем профиле для отправки чека.")
            return

        # Формируем данные для платежа
        description = f"Оплата штрафа №{fine_id}"
        payload = f"fine_{fine_id}" # Этот payload уже обрабатывается вашей функцией process_successful_payment
        metadata = {'internal_payload': payload, 'user_id': user_id}
        items = [{"description": description, "quantity": "1.00", "amount": {"value": f"{price:.2f}", "currency": "RUB"}, "vat_code": "1"}]
        customer = {"phone": data['phone_number']}

        payment_info = await create_yookassa_payment(price, description, metadata, items, customer, 'sbp')
        if not payment_info:
            await query.message.edit_text("❌ Не удалось создать ссылку на оплату. Попробуйте позже.")
            return
            
        await query.message.delete()

        # Запускаем анимацию и проверку статуса
        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']
        keyboard = [[InlineKeyboardButton("💳 Оплатить штраф", url=payment_url)]]
        animated_message = await context.bot.send_message(
            user_id,
            f"🚨 Для оплаты штрафа, пожалуйста, оплатите {final_amount:.2f} ₽.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        if 'pending_payments' not in context.bot_data:
            context.bot_data['pending_payments'] = {}
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {
            'user_id': user_id, 'start_time': datetime.now(),
            'payload': payload, 'amount': final_amount,
            'animated_message_id': animated_message.message_id, 'url': payment_url,
            'animation_sequence': random.choice(PAYMENT_ANIMATIONS),
            'stop_animation_event': stop_animation_event
        }

        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(
            callback=check_payment_status, interval=15, first=10,
            name=f"payment_{payment_id}", data={'yookassa_id': payment_id}
        )

    except Exception as e:
        logger.error(f"Ошибка в start_fine_payment_user для штрафа #{fine_id}: {e}", exc_info=True)
        await query.message.reply_text("🚫 Произошла ошибка при создании счета на оплату.")

# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>
# ШАГ 3: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ В ВАШ КОД

async def auto_prolong_rental(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    Продлевает аренду, получая цену из индивидуального тарифа велосипеда в БД.
    """
    query = update.callback_query
    await query.answer()

    # Разбираем callback_data: auto_prolong_7_{booking_id}
    parts = query.data.split('_')
    days_to_extend = int(parts[2])
    booking_id = int(parts[3])
    user_id = query.from_user.id

    await query.message.edit_text("⏳ Готовлю счет на продление аренды...")

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            # --- НАЧАЛО ИЗМЕНЕНИЙ: Запрашиваем индивидуальную цену из таблицы bikes ---
            # Динамически формируем имя колонки с ценой
            price_column_name = f"rent_price_{days_to_extend}d"
            
            cursor = await conn.execute(
                f"""SELECT u.phone_number, b.name as bike_name, b.{price_column_name} as price
                   FROM bookings bo
                   JOIN users u ON bo.user_id = u.id
                   JOIN bikes b ON bo.bike_id = b.id
                   WHERE bo.id=?
                """,
                (booking_id,)
            )
            data = await cursor.fetchone()
        # --- КОНЕЦ ИЗМЕНЕНИЙ ---

        if not data:
            raise ValueError("Не найдена активная аренда для продления.")
        if not data['phone_number']:
            raise ValueError("Не найден ваш номер телефона для чека.")

        bike_name = data['bike_name']
        
        # <<< ГЛАВНОЕ ИЗМЕНЕНИЕ: Берем цену напрямую из результата запроса >>>
        price = data['price']
        if price is None or price <= 0:
            # Эта ошибка сработает, если для велосипеда в БД не установлена цена на нужный срок
            raise ValueError(f"Для велосипеда '{bike_name}' не установлен тариф аренды на {days_to_extend} дней.")
        # <<< КОНЕЦ ИЗМЕНЕНИЯ >>>

        # --- Дальнейший код остается без изменений, так как он уже использует переменную 'price' ---
        
        # Формируем данные для YooKassa
        description = f"Продление аренды '{bike_name}' на {days_to_extend} дней"
        payload = f"prolong_{booking_id}_{days_to_extend}"
        
        metadata = {'internal_payload': payload, 'user_id': user_id}
        items_for_receipt = [{"description": description, "quantity": "1.00", "amount": { "value": f"{float(price):.2f}", "currency": "RUB" }, "vat_code": "1", "payment_subject": "service"}]
        
        payment_info = await create_yookassa_payment(
            amount=price, 
            description=description, 
            metadata=metadata, 
            items=items_for_receipt, 
            customer_info={"phone": data['phone_number']}, 
            payment_method='sbp'
        )
        
        if not payment_info:
            raise ValueError("Не удалось создать ссылку на оплату.")

        # Отправляем счет и запускаем проверку
        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']
        
        keyboard = [[InlineKeyboardButton("💳 Оплатить продление", url=payment_url)]]
        animated_message = await query.message.edit_text(
            f"Для продления аренды на {days_to_extend} дней, пожалуйста, оплатите {final_amount:.2f} ₽.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        if 'pending_payments' not in context.bot_data: 
            context.bot_data['pending_payments'] = {}
            
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {
            'user_id': user_id, 
            'start_time': datetime.now(), 
            'payload': payload, 
            'amount': final_amount, 
            'animated_message_id': animated_message.message_id, 
            'url': payment_url, 
            'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 
            'stop_animation_event': stop_animation_event
        }
        
        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(
            callback=check_payment_status, 
            interval=15, 
            first=10, 
            name=f"payment_{payment_id}", 
            data={'yookassa_id': payment_id}
        )

    except Exception as e:
        logger.error(f"Ошибка в auto_prolong_rental: {e}", exc_info=True)
        # Отправляем пользователю осмысленное сообщение об ошибке
        await query.message.edit_text(f"❌ Произошла ошибка: {e}")
### НОВАЯ ВЕРСИЯ для клиентской кнопки "Оплатить ремонт" ###
async def start_complete_repair_user(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Вызывается, когда пользователь нажимает кнопку "Оплатить ремонт" в ЛК.
    Сразу формирует и отправляет счет на оплату.
    """
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])
    user_id = query.from_user.id

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute("""
                SELECT rr.estimated_price, rr.bike_id, u.phone_number, b.name as bike_name
                FROM repair_requests rr
                JOIN users u ON rr.user_id = u.id
                JOIN bikes b ON rr.bike_id = b.id
                WHERE rr.id=? AND rr.user_id=?
            """, (request_id, user_id))
            data = await cursor.fetchone()

        if not data or not data['estimated_price'] or float(data['estimated_price']) <= 0:
            await query.message.reply_text("🚫 Ошибка: не найдена сумма для оплаты или ремонт бесплатный.")
            return

        price = float(data['estimated_price'])

        if not data['phone_number']:
            await query.message.reply_text("🚫 Ошибка: не указан номер телефона в вашем профиле для отправки чека.")
            return

        # Формируем и отправляем платеж
        description = f"Оплата ремонта велосипеда '{data['bike_name']}' (заявка #{request_id})"
        payload = f"repair_payment_{request_id}"
        metadata = {'internal_payload': payload, 'user_id': user_id}
        items = [{"description": description, "quantity": "1.00", "amount": {"value": f"{price:.2f}", "currency": "RUB"}, "vat_code": "1"}]
        customer = {"phone": data['phone_number']}

        payment_info = await create_yookassa_payment(price, description, metadata, items, customer, 'sbp')
        if not payment_info:
            await query.message.reply_text("❌ Не удалось создать ссылку на оплату. Попробуйте позже.")
            return

        # Удаляем старое сообщение с кнопкой, чтобы не было дублей
        await query.message.delete()

        # Запускаем анимацию и проверку статуса
        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']
        keyboard = [[InlineKeyboardButton("💳 Оплатить ремонт", url=payment_url)]]
        animated_message = await context.bot.send_message(
            user_id,
            f"🛠️ Для оплаты ремонта, пожалуйста, оплатите {final_amount:.2f} ₽.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        if 'pending_payments' not in context.bot_data:
            context.bot_data['pending_payments'] = {}
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {
            'user_id': user_id, 'start_time': datetime.now(),
            'payload': payload, 'amount': final_amount,
            'animated_message_id': animated_message.message_id, 'url': payment_url,
            'animation_sequence': random.choice(PAYMENT_ANIMATIONS),
            'stop_animation_event': stop_animation_event
        }

        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(
            callback=check_payment_status, interval=15, first=10,
            name=f"payment_{payment_id}", data={'yookassa_id': payment_id}
        )

    except Exception as e:
        logger.error(f"Ошибка в start_complete_repair_user для заявки #{request_id}: {e}", exc_info=True)
        await query.message.reply_text("🚫 Произошла ошибка при создании счета на оплату.")
    # ### ИЗМЕНЕНИЕ: Убираем кота и змейку ###
    # snake_text = "Если вам скучно на работе или нет заказов, то можете поиграть в змейку :)\n/snake"
    # await update.message.reply_text(snake_text)
    # await update.message.reply_sticker("CAACAgIAAxkBAAEMt4tntcpyCUvi-YuNEGexnPmrq6Y_ZQACPyYAAgSZiUrBETgwCwOM1jYE")

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ### НОВАЯ, ОБНОВЛЕННАЯ ФУНКЦИЯ ###
# ### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
import aiosqlite
import asyncio
import random
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# Убедитесь, что эти функции уже определены в вашем коде:
# async def _get_deal_details_from_db(booking_id: int, conn: aiosqlite.Connection) -> dict | None: ...
# async def create_yookassa_payment(...) -> dict | None: ...
# async def animate_payment_message(context: ContextTypes.DEFAULT_TYPE, payment_id: str): ...
# async def check_payment_status(context: ContextTypes.DEFAULT_TYPE): ...

async def pay_next_installment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    ОБНОВЛЕННАЯ ВЕРСИЯ:
    Обрабатывает запрос на оплату очередного взноса по рассрочке (выкупу).
    1.  Получает все детали сделки, включая индивидуальный тариф велосипеда, из БД.
    2.  Проверяет наличие номера телефона для чека.
    3.  Формирует и отправляет пользователю счет на оплату через ЮKassa.
    4.  Запускает фоновую проверку статуса платежа.
    """
    query = update.callback_query
    await query.answer()

    # Извлекаем ID бронирования из callback_data (например, "pay_next_123")
    booking_id = int(query.data.split('_')[2])
    user_id = query.from_user.id

    await query.message.edit_text("⏳ Готовлю счет на оплату...")

    try:
        # --- Шаг 1: Получаем все детали сделки из БД ---
        async with aiosqlite.connect(DB_FILE) as conn:
            # Используем универсальную вспомогательную функцию
            deal_data = await _get_deal_details_from_db(booking_id, conn)

        if not deal_data:
            await query.message.edit_text("❌ Рассрочка не найдена или уже завершена.")
            return

        # --- Шаг 2: Извлекаем данные для платежа ---
        price = deal_data.get('buyout_payment_amount')
        phone_number = deal_data.get('phone_number')
        item_name = deal_data.get('bike_name')
        
        # Проверяем, что все необходимые данные на месте
        if not price or price <= 0:
            await query.message.edit_text("❌ Ошибка: для этой сделки не установлена сумма платежа. Свяжитесь с поддержкой.")
            return
        if not phone_number:
            await query.message.edit_text("🚫 Ошибка: не найден ваш номер телефона для отправки чека. Пожалуйста, обратитесь в поддержку, чтобы добавить его.")
            return

        # --- Шаг 3: Формируем и отправляем счет через ЮKassa ---
        description = f"Очередной взнос по рассрочке за {item_name}"
        payload = f"installment_{booking_id}"
        metadata = {'internal_payload': payload, 'user_id': user_id}
        customer_data = {"phone": phone_number}
        items_for_receipt = [{
            "description": description,
            "quantity": "1.00",
            "amount": {"value": f"{price:.2f}", "currency": "RUB"},
            "vat_code": "1",
            "payment_subject": "service",
            "payment_mode": "full_payment"
        }]

        # Вызываем функцию создания платежа, которая уже учитывает скидки
        payment_info = await create_yookassa_payment(
            amount=price, 
            description=description, 
            metadata=metadata, 
            items=items_for_receipt, 
            customer_info=customer_data, 
            payment_method='sbp'
        )

        if not payment_info:
            await query.message.edit_text("❌ Не удалось создать ссылку на оплату. Попробуйте позже.")
            return

        payment_url = payment_info['url']
        payment_id = payment_info['id']
        final_amount = payment_info['final_amount']
        
        # --- Шаг 4: Отправляем сообщение с кнопкой и запускаем проверку платежа ---
        keyboard = [[InlineKeyboardButton("💳 Оплатить взнос", url=payment_url)]]
        animated_message = await query.message.edit_text(
            f"Требуется оплата очередного взноса: {final_amount:.2f} ₽. Нажмите кнопку для перехода к оплате.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        if 'pending_payments' not in context.bot_data:
            context.bot_data['pending_payments'] = {}
            
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {
            'user_id': user_id, 
            'start_time': datetime.now(), 
            'payload': metadata['internal_payload'], 
            'amount': final_amount, 
            'animated_message_id': animated_message.message_id, 
            'url': payment_url, 
            'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 
            'stop_animation_event': stop_animation_event 
        }
        
        asyncio.create_task(animate_payment_message(context, payment_id))
        
        context.job_queue.run_repeating(
            callback=check_payment_status, 
            interval=15, 
            first=10, 
            name=f"payment_{payment_id}", 
            data={'yookassa_id': payment_id}
        )

    except Exception as e:
        logger.error(f"Критическая ошибка в pay_next_installment для booking_id={booking_id}: {e}", exc_info=True)
        await query.message.edit_text("Произошла непредвиденная ошибка. Пожалуйста, свяжитесь с поддержкой.")

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ pay_full_amount НА ЭТУ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ### НОВАЯ, ОБНОВЛЕННАЯ ФУНКЦИЯ ###
# ### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
async def pay_full_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    ОБНОВЛЕННАЯ ВЕРСИЯ:
    Рассчитывает и выставляет счет на досрочное погашение,
    используя индивидуальный план выкупа из базы данных.
    """
    query = update.callback_query
    await query.answer()
    booking_id = int(query.data.split('_')[2])
    user_id = query.from_user.id

    try:
        # --- Шаг 1: Получаем все детали сделки из БД ---
        async with aiosqlite.connect(DB_FILE) as conn:
            deal_data = await _get_deal_details_from_db(booking_id, conn)

        if not deal_data:
            await query.message.reply_text("❌ Рассрочка не найдена или уже завершена.")
            return
        
        # --- Шаг 2: Рассчитываем остаток долга ---
        total_payments = deal_data.get('buyout_total_payments', 0)
        payment_amount = deal_data.get('buyout_payment_amount', 0)
        payments_made = deal_data.get('payments_made', 0)
        
        if total_payments <= 0 or payment_amount <= 0:
            await query.message.reply_text("❌ Ошибка: для этой сделки не настроен план выкупа. Свяжитесь с поддержкой.")
            return

        payments_left = total_payments - payments_made
        remaining_amount = payments_left * payment_amount

        if remaining_amount <= 0:
            await query.message.reply_text("✅ Рассрочка уже полностью погашена!")
            return

        # --- Шаг 3: Формируем и отправляем счет (логика та же, но с новыми данными) ---
        item_name = deal_data.get('bike_name')
        phone_number = deal_data.get('phone_number')

        if not phone_number:
            await query.message.reply_text("🚫 Ошибка: не найден ваш номер телефона для отправки чека.")
            return

        description = f"Полное досрочное погашение рассрочки за {item_name}"
        metadata = {'internal_payload': f"full_buyout_{booking_id}", 'user_id': user_id}
        # ... (остальной код для создания платежа YooKassa)
        
        customer_data = {"phone": phone_number}
        items_for_receipt = [{"description": description, "quantity": "1.00", "amount": {"value": str(float(remaining_amount)), "currency": "RUB"}, "vat_code": "1", "payment_subject": "service", "payment_mode": "full_payment"}]

        payment_info = await create_yookassa_payment(amount=remaining_amount, description=description, metadata=metadata, items=items_for_receipt, customer_info=customer_data, payment_method='sbp')

        if not payment_info:
            await query.message.reply_text("❌ Не удалось создать ссылку на оплату.")
            return

        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']

        # ... (код для отправки сообщения с кнопкой и запуска проверки)
        keyboard = [[InlineKeyboardButton("💳 Погасить досрочно", url=payment_url)]]
        animated_message = await query.message.reply_text(
            f"Сумма для досрочного погашения: {final_amount:.2f} ₽. Нажмите для перехода к оплате.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        if 'pending_payments' not in context.bot_data: context.bot_data['pending_payments'] = {}
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {'user_id': user_id, 'start_time': datetime.now(), 'payload': metadata['internal_payload'], 'amount': final_amount, 'animated_message_id': animated_message.message_id, 'url': payment_url, 'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 'stop_animation_event': stop_animation_event }
        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(callback=check_payment_status, interval=15, first=10, name=f"payment_{payment_id}", data={'yookassa_id': payment_id})

    except Exception as e:
        logger.error(f"Ошибка в pay_full_amount: {e}", exc_info=True)
        await query.message.reply_text("Произошла непредвиденная ошибка.")


from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# Словари для меток
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ConversationHandler,
    ContextTypes,
)

# Определяем состояния
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler, MessageHandler, CommandHandler, ConversationHandler, filters
from datetime import datetime
import sqlite3
import os

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Константы для состояний
MAIN_MENU, FILTERS_MENU, SORT_MENU, AWAITING_INPUT, SHOW_RESULTS, SHOW_REGISTERED_USERS = range(6)

# Константы для фильтров и сортировки
# Константы для фильтров и сортировки
# Константы для фильтров и сортировки
SORT_LABELS = {
    'last_name': 'Фамилии', 'first_name': 'Имени', 'end_date': 'Дате окончания аренды'
}
# --- ИЗМЕНЕНИЕ: Заменена 'pending' на 'no_rental' ---
FILTER_LABELS = {
    'rented': '✅ Аренда',
    'overdue': '🔴 Просрочка',
    'no_rental': '🚫 Нет аренды' # Заменили 'Очередь' на 'Нет аренды'
}






# --- НОВЫЙ БЛОК: Улучшенная система поиска и фильтрации пользователей ---

# Определяем состояния
USER_SEARCH_MENU, AWAITING_SEARCH_INPUT = range(2)

# Константы для фильтров и сортировки
SORT_LABELS = {
    'last_name': 'Фамилии', 'first_name': 'Имени', 'end_date': 'Дате окончания аренды'
}
FILTER_LABELS = {
    'rented': '✅ Аренда', 'overdue': '🔴 Просрочка', 'pending': '⏳ Очередь'
}
from typing import Tuple
### НОВАЯ ВЕРСИЯ - строит меню поиска ###
### ФИНАЛЬНАЯ ВЕРСИЯ - строит меню поиска ###
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
def build_user_search_menu(context: ContextTypes.DEFAULT_TYPE) -> Tuple[str, InlineKeyboardMarkup]:
    """Строит текст и клавиатуру для главного меню поиска."""
    filters = context.user_data.get('user_filters', set())
    search_term = context.user_data.get('user_search_term')

    filters_text = ""
    if search_term:
        filters_text = f"поиск по фамилии: '{search_term}'"
    elif filters:
        filters_text = ", ".join(FILTER_LABELS.get(f, f) for f in filters)
    else:
        filters_text = "не выбраны"

    text = (
        f"⚙️ *Поиск пользователей*\n\n"
        f"Текущие настройки:\n"
        f"┣ Фильтры: *{filters_text}*\n\n"
        "Выберите действие:"
    )

    # --- ИЗМЕНЕНИЕ: Заменена кнопка 'Очередь' на 'Нет аренды' ---
    keyboard = [
        [InlineKeyboardButton(f"{'✅' if f in filters else '☑️'} {label}", callback_data=f"user_filter_{f}") for f, label in [('rented', 'Аренда'), ('overdue', 'Просрочка'), ('no_rental', 'Нет аренды')]],
        [
            InlineKeyboardButton("🔍 Ввести запрос", callback_data="user_search_prompt"),
            InlineKeyboardButton("🚀 Показать", callback_data="user_show_results")
        ],
        [InlineKeyboardButton("🔄 Сбросить все", callback_data="user_reset_all")]
    ]
    return text, InlineKeyboardMarkup(keyboard)


async def search_users(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Начинает или обновляет диалог поиска пользователей."""
    query = update.callback_query
    if query:
        await query.answer()

    # Сбрасываем только если это новый вход
    if update.message:
        context.user_data.clear()

    text, reply_markup = build_user_search_menu(context)

    if query and query.message:
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="Markdown")
    else:
        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode="Markdown")

    return USER_SEARCH_MENU

### НОВАЯ ВЕРСИЯ - обрабатывает меню поиска ###
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ
async def handle_user_search_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает нажатия кнопок в меню поиска."""
    query = update.callback_query
    await query.answer()

    action, _, value = query.data.partition('_')

    if action == 'user':
        sub_action, _, val = value.partition('_')

        if sub_action == 'filter':
            # При выборе фильтра сбрасываем поиск по фамилии
            context.user_data.pop('user_search_term', None)
            filters = context.user_data.setdefault('user_filters', set())
            if val in filters:
                filters.remove(val)
            else:
                filters.add(val)

        elif sub_action == 'search': # prompt
            # При запросе на поиск по фамилии сбрасываем другие фильтры
            context.user_data.pop('user_filters', None)
            context.user_data['user_sort_by'] = 'last_name'
            await query.message.reply_text("Введите фамилию для поиска:")
            return AWAITING_SEARCH_INPUT

        elif sub_action == 'show':
            await show_user_search_results(update, context)
            # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
            # Мы уже показали результаты в новых сообщениях.
            # Не нужно пытаться заново редактировать исходное меню, так как оно не изменилось.
            # Просто остаемся в том же состоянии, чтобы меню продолжало работать.
            return USER_SEARCH_MENU

        elif sub_action == 'reset':
            context.user_data.clear()

    # Перерисовываем меню с новыми настройками
    text, reply_markup = build_user_search_menu(context)
    try:
        # Удаляем старое сообщение и отправляем новое, чтобы избежать ошибок "Message not modified"
        # при повторном нажатии на тот же фильтр
        await query.message.delete()
        await context.bot.send_message(
            chat_id=query.from_user.id,
            text=text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
    except Exception as e:
        # Если удалить не удалось (например, сообщение слишком старое), просто пытаемся отправить новое.
        if "message to delete not found" in str(e).lower():
             await context.bot.send_message(
                chat_id=query.from_user.id,
                text=text,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        else:
            logger.warning(f"Не удалось обновить/отправить сообщение: {e}")

    return USER_SEARCH_MENU

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ

async def handle_user_search_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Принимает фамилию, НЕМЕДЛЕННО выполняет поиск и показывает результаты,
    а затем возвращает в меню поиска.
    """
    search_term = update.message.text.strip()

    # 1. Сохраняем поисковый запрос в контекст
    # Когда пользователь ищет по фамилии, мы сбрасываем другие фильтры
    context.user_data.pop('user_filters', None)
    context.user_data['user_search_term'] = search_term
    context.user_data['user_sort_by'] = 'last_name' # Жестко задаем поиск по фамилии

    # <<< ГЛАВНОЕ ИЗМЕНЕНИЕ >>>
    # 2. Сразу же вызываем функцию, которая выполняет поиск и показывает результаты
    await show_user_search_results(update, context)

    # 3. После показа результатов, снова отображаем меню поиска для дальнейших действий
    await search_users(update, context)

    # 4. Возвращаемся в основное состояние меню поиска
    return USER_SEARCH_MENU


# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ПОЛНОСТЬЮ
async def show_user_search_results(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Выполняет запрос к БД, находит пользователей и для каждого формирует единую карточку."""
    message = update.effective_message

    filters = context.user_data.get('user_filters', set())
    search_term = context.user_data.get('user_search_term')

    # --- ЭТАП 1: Найти УНИКАЛЬНЫХ пользователей, подходящих под критерии ---
    # ИЗМЕНЕНИЕ: Запрашиваем столбец 'username' вместо 'tg_username'
    user_query_parts = ["SELECT DISTINCT u.id, u.first_name, u.last_name, u.username, u.phone_number FROM users u"]
    user_conditions = []
    user_params = []

    if 'rented' in filters or 'overdue' in filters:
        user_query_parts.append("JOIN bookings b ON u.id = b.user_id")

    if 'rented' in filters:
        user_conditions.append("b.status = 'rented'")
    if 'overdue' in filters:
        user_conditions.append("(b.status = 'rented' AND DATE(SUBSTR(b.end_date, 7, 4) || '-' || SUBSTR(b.end_date, 4, 2) || '-' || SUBSTR(b.end_date, 1, 2)) < DATE('now'))")
    
    if 'no_rental' in filters:
        user_conditions.append("NOT EXISTS (SELECT 1 FROM bookings b WHERE b.user_id = u.id AND b.status = 'rented')")

    if search_term:
        user_conditions.append("u.last_name LIKE ?")
        user_params.append(f"%{search_term}%")

    if user_conditions:
        user_query_parts.append("WHERE " + " AND ".join(user_conditions))

    user_query_parts.append("ORDER BY u.last_name, u.first_name")
    final_user_query = " ".join(user_query_parts)

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            user_cursor = await conn.execute(final_user_query, user_params)
            users = await user_cursor.fetchall()

            if not users:
                await context.bot.send_message(message.chat.id, "🚫 По вашему запросу ничего не найдено.")
                return

            await context.bot.send_message(message.chat.id, f"✅ Найдено пользователей: {len(users)}. Формирую карточки...")

            for user in users:
                user_id = user['id']

                booking_cursor = await conn.execute("""
                    SELECT b.booking_type, b.end_date, bk.name as bike_name, b.payments_made, b.payment_plan_key
                    FROM bookings b
                    JOIN bikes bk ON b.bike_id = bk.id
                    WHERE b.user_id = ? AND b.status = 'rented'
                """, (user_id,))
                bookings = await booking_cursor.fetchall()

                # ИЗМЕНЕНИЕ: Используем 'username' для отображения ника
                caption_parts = [
                    f"👤 *{user['first_name']} {user['last_name']}*",
                    f"   - ID: `{user_id}`",
                    f"   - Ник TG: `@{user['username'] or 'N/A'}`", # <-- ИСПРАВЛЕНО ЗДЕСЬ
                    f"   - Телефон: `{user['phone_number'] or 'Не указан'}`",
                    "---"
                ]

                if not bookings:
                    caption_parts.append("_Нет активных аренд или выкупов._")
                else:
                    for booking in bookings:
                        if booking['booking_type'] == 'rent':
                            is_overdue = False
                            if booking['end_date']:
                                try:
                                    end_date_obj = datetime.strptime(booking['end_date'], "%d.%m.%Y").date()
                                    if end_date_obj < datetime.now().date():
                                        is_overdue = True
                                except ValueError: pass
                            status_emoji = "🔴" if is_overdue else "🟢"
                            caption_parts.append(f"{status_emoji} Аренда: `{booking['bike_name']}` до `{booking['end_date'] or '??'}`")
                        elif booking['booking_type'] == 'buyout':
                            plan = BUYOUT_PLANS.get(booking['payment_plan_key'])
                            if plan:
                                total_payments = plan.get('total_payments', '?')
                                caption_parts.append(f"💰 Выкуп: `{booking['bike_name']}` ({booking['payments_made']}/{total_payments} пл.)")

                await context.bot.send_message(message.chat.id, "\n".join(caption_parts), parse_mode="Markdown")

    except Exception as e:
        logger.error(f"Ошибка в show_user_search_results: {e}", exc_info=True)
        await message.reply_text(f"❌ Ошибка выполнения запроса к БД: {e}")
async def universal_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Universally cancels and ends the conversation, returning to the main menu."""
    user_id = update.effective_user.id
    await update.message.reply_text(
        "Действие отменено. Возвращаю в главное меню.",
        reply_markup=get_main_menu(user_id)
    )
    context.user_data.clear()
    return ConversationHandler.END
# Верификация пользователей ✅
from telegram import InputMediaPhoto # Не забудьте этот импорт

import os # Убедитесь, что этот импорт есть в начале файла
from telegram import InputMediaPhoto, InlineKeyboardButton, InlineKeyboardMarkup


import os # Убедитесь, что этот импорт есть в начале файла
from telegram import InputMediaPhoto, InlineKeyboardButton, InlineKeyboardMarkup

async def verify_user(update: Update, context) -> None:
    admin_id = update.message.from_user.id
    if not is_admin(admin_id):
        await update.message.reply_text("🚫 У вас нет прав для верификации пользователей.")
        return

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    # <<< ИЗМЕНЕНИЕ 1: Добавляем поле "country" в запрос >>>
    cursor.execute("SELECT id, first_name, last_name, passport_photo, username, country FROM users WHERE verified=0")
    users_to_verify = cursor.fetchall()
    conn.close()

    if not users_to_verify:
        await update.message.reply_text("🚫 Нет пользователей для верификации.")
        return

    await update.message.reply_text("⏳ Заявки на верификацию:")

    for user_data in users_to_verify:
        # <<< ИЗМЕНЕНИЕ 2: Получаем "country" из результата запроса >>>
        (user_id_to_verify, first_name, last_name, passport_folder_path, username, country) = user_data

        info_caption = (
            f"Имя: {first_name} {last_name or ''}\n"
            f"ID: {user_id_to_verify}\n"
            f"@{username if username else 'Нет username'}"
        )

        if not (passport_folder_path and os.path.isdir(passport_folder_path)):
            caption_no_photo = f"{info_caption}\n\n⚠️ Фото паспорта не были загружены пользователем."
            # <<< ИЗМЕНЕНИЕ 3: Всегда добавляем кнопку, даже если нет фото >>>
            keyboard = [[InlineKeyboardButton("✅ Подтвердить (без фото)", callback_data=f"verify_{user_id_to_verify}")]]
            await update.message.reply_text(text=caption_no_photo, reply_markup=InlineKeyboardMarkup(keyboard))
            continue # Переходим к следующему пользователю

        try:
            media_group = []

            # <<< ИЗМЕНЕНИЕ 4: Проверяем гражданство и ищем правильные файлы >>>
            if country == 'РФ':
                # Файлы для граждан РФ
                paths_to_check = {
                    "Основной разворот": os.path.join(passport_folder_path, "1_main_passport.jpg"),
                    "Прописка": os.path.join(passport_folder_path, "2_registration_passport.jpg"),
                    "Селфи с паспортом": os.path.join(passport_folder_path, "3_selfie_with_passport.jpg"),
                }
            else: # Для иностранных граждан
                paths_to_check = {
                    "Паспорт": os.path.join(passport_folder_path, "1_foreign_passport.jpg"),
                    "Регистрация": os.path.join(passport_folder_path, "2_registration.jpg"),
                    "Патент": os.path.join(passport_folder_path, "3_patent.jpg"),
                }

            # Собираем медиа группу из существующих файлов
            for caption, path in paths_to_check.items():
                if os.path.exists(path):
                    # Открываем файл в бинарном режиме для отправки
                    media_group.append(InputMediaPhoto(media=open(path, 'rb'), caption=caption))

            # Отправляем сообщение
            if media_group:
                await context.bot.send_media_group(chat_id=admin_id, media=media_group)

                # Отправляем отдельным сообщением информацию и кнопку
                keyboard = [[InlineKeyboardButton("✅ Подтвердить верификацию", callback_data=f"verify_{user_id_to_verify}")]]
                await context.bot.send_message(
                    chat_id=admin_id,
                    text=f"Заявка на верификацию:\n{info_caption}",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            else:
                # Если папка есть, но фото в ней нет
                caption_no_photo = f"{info_caption}\n\n⚠️ Папка с документами пуста."
                keyboard = [[InlineKeyboardButton("✅ Подтвердить (без фото)", callback_data=f"verify_{user_id_to_verify}")]]
                await update.message.reply_text(text=caption_no_photo, reply_markup=InlineKeyboardMarkup(keyboard))

        except Exception as e:
            logger.error(f"Ошибка при отправке фото для верификации user {user_id_to_verify}: {e}")
            # Отправка сообщения об ошибке с кнопкой
            keyboard = [[InlineKeyboardButton("✅ Подтвердить (несмотря на ошибку)", callback_data=f"verify_{user_id_to_verify}")]]
            await context.bot.send_message(
                chat_id=admin_id,
                text=f"Не удалось отправить фото для заявки:\n{info_caption}\nОшибка: {e}",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )


# Подтверждение верификации пользователя 🟢
async def confirm_user_verification(update: Update, context) -> None:
    query = update.callback_query
    await query.answer()

    # Удаляем исходное сообщение с заявкой
    try:
        await context.bot.delete_message(
            chat_id=query.message.chat_id,
            message_id=query.message.message_id
        )
    except Exception as e:
        print(f"Ошибка при удалении сообщения: {e}")

    user_id = int(query.data.split('_')[1])

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("UPDATE users SET verified=1 WHERE id=?", (user_id,))
    conn.commit()
    conn.close()

    # Отправляем подтверждение админу
    await query.message.reply_text("✅ Пользователь успешно верифицирован!")

    # Уведомляем пользователя
    await context.bot.send_message(
        chat_id=user_id,
        text="Ваша учетная запись была успешно верифицирована администратором!"
    )
from telegram.helpers import escape_markdown


from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext
import sqlite3
from telegram.helpers import escape_markdown




# Обработчик для пагинации
# УДАЛИТЕ СТАРЫЕ ФУНКЦИИ: show_booking_status, send_paginated_section, pagibron
# И ВСТАВЬТЕ ВМЕСТО НИХ ЭТУ ОДНУ ФУНКЦИЮ

# НАЙДИТЕ ЭТУ ФУНКЦИЮ И ВНЕСИТЕ ИЗМЕНЕНИЯ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

async def manage_bookings_panel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Создает единую интерактивную панель для управления всеми бронированиями.
    """
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("🚫 У вас нет прав для этой команды.")
        return

    if update.callback_query:
        await update.callback_query.answer()

    message = update.message or update.callback_query.message

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            # <<< ИЗМЕНЕНИЕ №1: Добавляем b.booking_date в SELECT >>>
            cursor = await conn.execute("""
                SELECT b.id, b.status, u.first_name, u.last_name, u.username,
                       bk.name as bike_name, b.booking_date
                FROM bookings b
                JOIN users u ON b.user_id = u.id
                JOIN bikes bk ON b.bike_id = bk.id
                WHERE b.status IN ('pending', 'confirmed')
                ORDER BY CASE b.status
                    WHEN 'pending' THEN 1
                    WHEN 'confirmed' THEN 2
                    ELSE 3
                END, b.booking_date DESC
            """)
            all_requests = await cursor.fetchall()

        if not all_requests:
            await message.reply_text("✅ Все заявки обработаны, новых нет.")
            return

        requests_by_status = {
            'pending': [],
            'confirmed': []
        }
        for req in all_requests:
            if req['status'] in requests_by_status:
                requests_by_status[req['status']].append(req)

        message_parts = ["*🛠️ Панель управления бронированиями*\n"]
        keyboard = []

        if requests_by_status['pending']:
            message_parts.append("\n*Новые заявки (ожидают подтверждения):*")
            for req in requests_by_status['pending']:
                # <<< ИЗМЕНЕНИЕ №2: Извлекаем и форматируем время >>>
                booking_time_str = req['booking_date'].split(' ')[1] # Получаем "19:00" из "02.07.2025 19:00"
                user_display = f"{req['first_name']} {req['last_name'] or ''}"
                message_parts.append(f"• ID {req['id']}: `{req['bike_name']}` от *{user_display}* на *{booking_time_str}*")
                keyboard.append([
                    InlineKeyboardButton(f"✅ Подтвердить #{req['id']}", callback_data=f"confirm_{req['id']}"),
                    InlineKeyboardButton(f"❌ Отменить #{req['id']}", callback_data=f"cancel_{req['id']}")
                ])

        if requests_by_status['confirmed']:
            message_parts.append("\n*Подтвержденные (ожидают выдачи):*")
            for req in requests_by_status['confirmed']:
                # <<< ИЗМЕНЕНИЕ №3: То же самое для подтвержденных броней >>>
                booking_time_str = req['booking_date'].split(' ')[1]
                user_display = f"{req['first_name']} {req['last_name'] or ''}"
                message_parts.append(f"• ID {req['id']}: `{req['bike_name']}` от *{user_display}* на *{booking_time_str}*")

                # <<< ИЗМЕНЕНИЕ №4: Делаем кнопку короткой и информативной >>>
                button_text = f"🚫 Отменить ({req['last_name']} {booking_time_str})"
                keyboard.append([InlineKeyboardButton(button_text, callback_data=f"cancel_{req['id']}")])

        keyboard.append([InlineKeyboardButton("🔄 Обновить", callback_data="refresh_bookings_panel")])

        final_message = "\n".join(message_parts)
        reply_markup = InlineKeyboardMarkup(keyboard)

        if update.callback_query:
            await message.edit_text(final_message, reply_markup=reply_markup, parse_mode="Markdown")
        else:
            await message.reply_text(final_message, reply_markup=reply_markup, parse_mode="Markdown")

    except Exception as e:
        logger.error(f"Ошибка в manage_bookings_panel: {e}", exc_info=True)
        await message.reply_text("🚫 Произошла ошибка при загрузке панели бронирований.")
# Регистрация обработчика

# Удаление бронирования администратором 🗑️
async def delete_booking(update: Update, context) -> None:
    query = update.callback_query
    await query.answer()
    booking_id = query.data.split("_")[1]

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем bike_id и user_id для обновления статуса
    cursor.execute("SELECT bike_id, user_id FROM bookings WHERE id=?", (booking_id,))
    booking_info = cursor.fetchone()

    if booking_info:
        bike_id, user_id = booking_info

        # Удаляем запись о бронировании
        cursor.execute("DELETE FROM bookings WHERE id=?", (booking_id,))

        # Обновляем статус велосипеда на "в наличии" и удаляем reserved_by
        cursor.execute("UPDATE bikes SET available=1, reserved_date=NULL, reserved_by=NULL WHERE id=?", (bike_id,))

        conn.commit()

        # Логируем действие
        log_bike_action(bike_id, user_id, "Бронь отменена.")

        await query.message.reply_text("✅ Бронирование успешно отменено и велосипед стал доступен!")

        # Уведомляем пользователя об отмене бронирования
        await context.bot.send_message(chat_id=user_id, text="🔔 Ваша бронь была отменена администратором.")
    else:
        await query.message.reply_text("🚫 Ошибка: бронь не найдена.")

    conn.close()

# Подтверждение бронирования администратором ✔️
### НОВАЯ, ПОЛНОСТЬЮ АСИНХРОННАЯ И ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
async def confirm_booking_admin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Подтверждает бронирование, используя асинхронный доступ к БД,
    чтобы избежать блокировок.
    """
    query = update.callback_query
    await query.answer()
    booking_id = int(query.data.split("_")[1])

    try:
        # Используем асинхронный менеджер для гарантии закрытия соединения
        async with aiosqlite.connect(DB_FILE, timeout=10) as conn:
            # Начинаем транзакцию, чтобы все операции были единым целым
            await conn.execute('BEGIN')

            # Получаем все необходимые данные одним запросом
            cursor = await conn.execute("""
                SELECT b.bike_id, b.booking_date, b.user_id, u.first_name, u.last_name, u.username
                FROM bookings b
                JOIN users u ON b.user_id = u.id
                WHERE b.id=?
            """, (booking_id,))
            booking_info = await cursor.fetchone()

            if not booking_info:
                await query.message.reply_text("🚫 Ошибка: бронь не найдена.")
                await conn.rollback() # Откатываем транзакцию
                return

            bike_id, booking_date, user_id, first_name, last_name, username = booking_info

            # Устанавливаем статус 'confirmed' для текущей брони
            await conn.execute("UPDATE bookings SET status='confirmed' WHERE id=?", (booking_id,))

            # Делаем велосипед недоступным
            await conn.execute("UPDATE bikes SET available=0, reserved_date=? WHERE id=?", (booking_date, bike_id))

            # Логируем действие, передавая объект соединения
            await log_bike_action(conn, bike_id, user_id, "Бронь подтверждена администратором.")

            # Если все успешно, фиксируем изменения в БД
            await conn.commit()

        # Формируем красивое уведомление для пользователя
        user_name = f"{first_name} {last_name or ''}".strip()
        user_mention = f"(@{username})" if username else ""
        notification_text = (
            f"✅ Ваша бронь на велосипед подтверждена администратором!\n\n"
            f"📅 **Дата бронирования:** {booking_date}\n\n"
            f"Пожалуйста, подойдите в указанное время для оформления аренды."
        )

        # Отправляем уведомление пользователю
        await context.bot.send_message(
            chat_id=user_id,
            text=notification_text,
            parse_mode="Markdown"
        )

        # Редактируем сообщение админа, чтобы убрать кнопки и показать результат
        await query.edit_message_text(f"✅ Бронь для {user_name} {user_mention} подтверждена. Пользователь уведомлен.")

    except Exception as e:
        logger.error(f"Ошибка при подтверждении бронирования #{booking_id}: {e}", exc_info=True)
        # Если произошла ошибка, откатываем транзакцию (в async with это не обязательно, но для ясности)
        await query.message.reply_text("🚫 Произошла ошибка при подтверждении брони. См. логи.")


# Отмена бронирования администратором ❌
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ АСИНХРОННУЮ ВЕРСИЮ

async def cancel_booking_admin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    booking_id = int(query.data.split("_")[1])

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute('BEGIN')

            # Получаем bike_id и user_id для обновления статуса
            cursor = await conn.execute("SELECT bike_id, user_id FROM bookings WHERE id=?", (booking_id,))
            booking_info = await cursor.fetchone()

            if not booking_info:
                await query.message.reply_text("🚫 Ошибка: бронь не найдена.")
                await conn.rollback()
                return

            bike_id, user_id = booking_info

            # Удаляем запись о бронировании
            await conn.execute("DELETE FROM bookings WHERE id=?", (booking_id,))

            # Обновляем статус велосипеда на "доступен"
            await conn.execute("UPDATE bikes SET available=1, reserved_date=NULL, reserved_by=NULL WHERE id=?", (bike_id,))

            # <<< ИСПРАВЛЕННЫЙ ВЫЗОВ ЛОГИРОВАНИЯ >>>
            await log_bike_action(conn, bike_id, user_id, action="Отмена брони (админ)")

            # Обработка очереди (остается без изменений, но становится асинхронной)
            # ... (здесь можно добавить логику очереди, если она нужна при отмене)

            await conn.commit()

        await query.message.edit_text("❌ Бронирование удалено!")
        await context.bot.send_message(chat_id=user_id, text="🔔 Ваше бронирование было отменено администратором.")

    except Exception as e:
        logger.error(f"Ошибка при отмене бронирования админом #{booking_id}: {e}", exc_info=True)
        await query.message.reply_text("🚫 Произошла ошибка при отмене брони.")

async def cancel_booking_command(update: Update, context) -> None:
    user_id = update.message.from_user.id

    # Подключаемся к БД и ищем активные бронирования
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id, bike_id FROM bookings WHERE user_id=? AND status='pending'", (user_id,))
    active_bookings = cursor.fetchall()
    conn.close()

    # Если у пользователя есть активные бронирования
    if active_bookings:
        # Спрашиваем, какую бронь отменить
        keyboard = [[InlineKeyboardButton(f"Отменить бронирование ID: {booking[0]}", callback_data=f"cancel_booking_{booking[0]}")] for booking in active_bookings]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("Выберите бронь для отмены:", reply_markup=reply_markup)
    else:
        await update.message.reply_text("🚫 У вас нет активных броней для отмены.")


async def cancel_booking(update: Update, context) -> None:
    query = update.callback_query
    await query.answer()
    booking_id = query.data.split("_")[2]

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем bike_id и user_id для обновления статуса
    cursor.execute("SELECT bike_id, user_id FROM bookings WHERE id=?", (booking_id,))
    booking_info = cursor.fetchone()

    if booking_info:
        bike_id, user_id = booking_info

        # Удаляем запись о бронировании
        cursor.execute("DELETE FROM bookings WHERE id=?", (booking_id,))

        # Обновляем статус велосипеда на "доступен" и удаляем reserved_by
        cursor.execute("UPDATE bikes SET available=1, reserved_date=NULL, reserved_by=NULL WHERE id=?", (bike_id,))

        # Логируем отмену бронирования
        log_bike_action(bike_id, user_id, "Бронь удалена пользователем.")

        # Обработка очереди
        cursor.execute("SELECT id, user_id, status FROM queue ORDER BY created_at ASC")
        queue = cursor.fetchall()

        if queue:
            first_user_id = queue[0][1]  # Получаем user_id первого в очереди
            first_user_status = queue[0][2]  # Получаем статус первого в очереди

            if first_user_status == 'pending':
                # Если статус первого пользователя 'pending', обновляем его статус на 'first_user'
                cursor.execute("UPDATE queue SET status='first_user' WHERE user_id = ?", (first_user_id,))
                await context.bot.send_message(chat_id=first_user_id, text="🎉 Вам доступен велосипед! Пожалуйста, подтвердите аренду.")

            elif first_user_status == 'first_user':
                # Если статус первого пользователя 'first_user', удаляем его из очереди
                cursor.execute("DELETE FROM queue WHERE user_id = ?", (first_user_id,))

                if len(queue) > 1:
                    # Если в очереди есть другие пользователи, сдвигаем их
                    for idx, (queue_id, queued_user_id, _) in enumerate(queue[1:], start=1):
                        cursor.execute("UPDATE queue SET created_at = ? WHERE id = ?", (idx, queue_id))

                    # Обновляем статус нового первого пользователя на 'first_user'
                    new_first_user_id = queue[1][1]
                    cursor.execute("UPDATE queue SET status='first_user' WHERE user_id = ?", (new_first_user_id,))
                    await context.bot.send_message(chat_id=new_first_user_id, text="🎉 Вам доступен велосипед! Пожалуйста, подтвердите аренду.")

        conn.commit()
        await query.message.reply_text("❌ Бронирование удалено!")

        # Уведомляем пользователя об отмене
        await context.bot.send_message(chat_id=user_id, text="🔔 Ваше бронирование было отменено.")
    else:
        await query.message.reply_text("🚫 Ошибка: бронь не найдена.")

    conn.close()

SELECT_USER, ENTER_AMOUNT, ENTER_REASON, ENTER_DUE_DATE = range(4)

(VIEW_FINES_MENU, VIEW_FINES_CATEGORY, REJECT_REASON) = range(3)

async def view_fines_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Показывает меню просмотра штрафов"""
    if not is_admin(update.message.from_user.id):
        await update.message.reply_text("❌ Нет прав!")
        return ConversationHandler.END

    keyboard = [
        [
            InlineKeyboardButton("🚫 Неоплаченные", callback_data="view_unpaid"),
            InlineKeyboardButton("✅ Оплаченные", callback_data="view_paid")
        ],
        [
            InlineKeyboardButton("📝 Заявки", callback_data="view_disputed"),
            InlineKeyboardButton("❌ Отмена", callback_data="view_cancel")
        ]
    ]

    await update.message.reply_text(
        "📋 Выберите категорию штрафов:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return VIEW_FINES_CATEGORY

async def show_fines_category(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает выбор категории."""
    query = update.callback_query
    await query.answer()

    status_map = {
        "view_unpaid": "unpaid",
        "view_paid": "paid",
        "view_disputed": "disputed"
    }

    if query.data == "view_cancel":
        await query.edit_message_text("🚫 Просмотр штрафов отменен")
        return ConversationHandler.END

    status = status_map.get(query.data)
    if not status:
        await query.edit_message_text("❌ Ошибка выбора категории!")
        return ConversationHandler.END

    # Вызываем функцию показа штрафов с пагинацией (начинаем с первой страницы)
    await show_fines_by_status(update, context, status, page=0)
    return ConversationHandler.END
from telegram import InputMediaPhoto, InputMediaVideo
from telegram.helpers import escape_markdown
async def show_fines_by_status(update: Update, context: ContextTypes.DEFAULT_TYPE, status: str, page: int = 0) -> None:
    """Показывает штрафы с пагинацией и разным форматом по статусам"""
    ITEMS_PER_PAGE = 1 if status == 'disputed' else 5

    status_names = {
        'unpaid': ('🚫 Неоплаченные штрафы', 'Неоплачен'),
        'paid': ('✅ Оплаченные штрафы', 'Оплачен'),
        'disputed': ('📝 Заявки на оспаривание', 'На рассмотрении')
    }

    title, rus_status = status_names[status]
    chat_id = update.effective_chat.id

    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()

        # Получаем общее количество записей
        if status == 'unpaid':
            cursor.execute('SELECT COUNT(*) FROM fines WHERE status IN ("unpaid", "disputed")')
        else:
            cursor.execute('SELECT COUNT(*) FROM fines WHERE status = ?', (status,))
        total_items = cursor.fetchone()[0]

        if total_items == 0:
            await context.bot.send_message(chat_id, "📭 Штрафы отсутствуют")
            return

        total_pages = (total_items + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE

        # Получаем данные
        offset = page * ITEMS_PER_PAGE
        query = '''
            SELECT
                f.id, u.first_name, u.last_name, u.username,
                f.amount, f.reason, f.created_at,
                f.dispute_comment, f.dispute_photo, f.dispute_video
            FROM fines f
            JOIN users u ON f.user_id = u.id
        '''
        query += ' WHERE f.status IN ("unpaid", "disputed")' if status == 'unpaid' else ' WHERE f.status = ?'
        query += ' ORDER BY f.created_at DESC LIMIT ? OFFSET ?'

        params = (status,) if status != 'unpaid' else ()
        params += (ITEMS_PER_PAGE, offset)

        cursor.execute(query, params)
        fines = cursor.fetchall()

    if not fines:
        await context.bot.send_message(chat_id, "📭 Штрафы отсутствуют")
        return

    # Универсальное экранирование (без ручного экранирования точек)
    def escape(text: str) -> str:
        return escape_markdown(str(text), version=2)

    # Формирование сообщения
    message_parts = []
    if status == 'disputed':
        fine = fines[0]
        name = escape(f"{fine[1]} {fine[2]}" if fine[1] and fine[2] else "Не указано")
        username = escape(f"@{fine[3]}" if fine[3] else "нет username")
        reason = escape(fine[5])
        amount = escape(f"{fine[4]:.2f}")
        date = escape(datetime.strptime(fine[6], "%Y-%m-%d %H:%M:%S").strftime("%d.%m.%Y") if '-' in fine[6] else fine[6])
        comment = escape(fine[7]) if fine[7] else ""

        message_parts.extend([
            f"{title}\n",
            f"▫️ *{name}* \\({username}\\)",
            f"🔸 Причина: {reason}",
            f"🔸 Сумма: {amount}₽",
            f"🔸 Дата: {date}",
            f"🔸 Комментарий: {comment}" if comment else "",
            f"🆔 ID: `{fine[0]}`",
            f"📄 Страница {page + 1}/{total_pages}"
        ])

        media = None
        if fine[8]:
            media = InputMediaPhoto(media=fine[8], caption='\n'.join(message_parts).strip(), parse_mode='MarkdownV2')
        elif fine[9]:
            media = InputMediaVideo(media=fine[9], caption='\n'.join(message_parts).strip(), parse_mode='MarkdownV2')
    else:
        message_parts.append(f"{title}\n")
        for idx, fine in enumerate(fines, 1):
            name = escape(f"{fine[1]} {fine[2]}" if fine[1] and fine[2] else "Не указано")
            username = escape(f"@{fine[3]}" if fine[3] else "нет username")
            reason = escape(fine[5])
            amount = escape(f"{fine[4]:.2f}")
            date = escape(datetime.strptime(fine[6], "%Y-%m-%d %H:%M:%S").strftime("%d.%m.%Y") if '-' in fine[6] else fine[6])

            # Ручное экранирование точки только в нумерации списка
            message_parts.extend([
                f"{escape(str(idx))}\\. *{name}* \\({username}\\)",  # Точка после номера
                f"   Причина: {reason}",
                f"   Сумма: {amount}₽",
                f"   Дата: {date}",
                f"   🆔 ID: `{fine[0]}`\n"
            ])
        message_parts.append(f"📄 Страница {page + 1}/{total_pages}")

    # Сборка финального сообщения
    final_message = '\n'.join([p for p in message_parts if p])

    # Клавиатура и отправка (остается без изменений)
    keyboard = []
    if status == 'disputed':
        keyboard.append([
            InlineKeyboardButton("✅ Принять", callback_data=f"accept_{fine[0]}"),
            InlineKeyboardButton("❌ Отклонить", callback_data=f"reject_{fine[0]}")
        ])

    pagination = []
    if page > 0:
        pagination.append(InlineKeyboardButton("<", callback_data=f"page:{status}:{page-1}"))
    if page < total_pages - 1:
        pagination.append(InlineKeyboardButton(">", callback_data=f"page:{status}:{page+1}"))

    if pagination:
        keyboard.append(pagination)

    keyboard.append([InlineKeyboardButton("🔙 Закрыть", callback_data="close_pagination")])

    try:
        if update.callback_query:
            if status == 'disputed' and media:
                await update.callback_query.edit_message_media(
                    media=media,
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            else:
                await update.callback_query.edit_message_text(
                    text=final_message,
                    parse_mode='MarkdownV2',
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
        else:
            if status == 'disputed' and media:
                await context.bot.send_photo(
                    chat_id=chat_id,
                    photo=media.media,
                    caption=media.caption,
                    parse_mode='MarkdownV2',
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            else:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=final_message,
                    parse_mode='MarkdownV2',
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
    except BadRequest as e:
        print(f"Ошибка форматирования: {e}\nСообщение: {final_message}")

async def shtrafpagi(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обрабатывает кнопки пагинации"""
    query = update.callback_query
    await query.answer()

    if query.data.startswith("page:"):
        _, status, page = query.data.split(':')
        await show_fines_by_status(update, context, status, int(page))
    elif query.data == "close_pagination":
        await query.delete_message()
# Обработчик кнопки "Принять"
async def handle_accept(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    fine_id = int(query.data.split("_")[1])  # Исправлен разделитель

    # Удаляем кнопки из сообщения
    await query.edit_message_reply_markup(reply_markup=None)

    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        try:
            # Получаем данные о штрафе и username пользователя
            cursor.execute('''
                SELECT u.first_name, u.last_name, u.username, f.amount, f.reason, f.user_id
                FROM fines f
                JOIN users u ON f.user_id = u.id
                WHERE f.id = ?
            ''', (fine_id,))

            fine_data = cursor.fetchone()

            if fine_data:
                first_name, last_name, username, amount, reason, user_id = fine_data

                # Формируем имя пользователя
                name = f"{first_name} {last_name}" if first_name and last_name else "Не указано"
                username = f"@{username}" if username else "нет username"

                # Логируем действие с именем и username из БД
                log_details = (
                    f"👤 Пользователь: {name} ({username})\n"
                    f"💰 Сумма: {amount}₽\n"
                    f"📝 Причина: {reason}"
                )

                # Логируем действие администратора
                log_bike_action(
                    user_id=user_id,
                    action="Принятие штрафа",
                    details=f"Администратор подтвердил:\n{log_details}",
                    bike_id=None  # Добавьте bike_id при необходимости
                )

                # Удаляем штраф из БД
                cursor.execute("DELETE FROM fines WHERE id = ?", (fine_id,))
                conn.commit()

                await context.bot.send_message(
                    chat_id=query.message.chat_id,
                    text=f"✅ Штраф #{fine_id} от {name} ({username}) принят и удалён."
                )

        except sqlite3.Error as e:
            print(f"Ошибка БД: {e}")
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text="❌ Произошла ошибка при обработке запроса."
            )

# Начало диалога отклонения штрафа
async def start_reject(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    fine_id = int(query.data.split("_")[1])

    # Сохраняем данные в context
    context.user_data['reject_fine_id'] = fine_id

    # Удаляем кнопки из исходного сообщения
    await query.edit_message_reply_markup(reply_markup=None)

    # Запрашиваем причину
    await query.message.reply_text("📝 Введите причину отклонения:")

    return REJECT_REASON

# Обработка ввода причины отклонения
async def handle_reject_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reason = update.message.text
    fine_id = context.user_data.get('reject_fine_id')

    if not fine_id:
        await update.message.reply_text("⚠️ Ошибка: сессия истекла")
        return ConversationHandler.END

    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()

            # Обновляем статус и добавляем комментарий
            cursor.execute('''
                UPDATE fines
                SET status = 'unpaid', dispute_comment = ?
                WHERE id = ?
            ''', (reason, fine_id))

            # Получаем user_id для уведомления
            cursor.execute("SELECT user_id FROM fines WHERE id = ?", (fine_id,))
            user_id = cursor.fetchone()[0]

            conn.commit()

        # Уведомляем администратора
        await update.message.reply_text(f"❌ Штраф #{fine_id} отклонен")

        # Уведомляем пользователя
        try:
            await context.bot.send_message(
                chat_id=user_id,
                text=f"🚫 Ваш штраф #{fine_id} отклонен. Причина: {reason}"
            )
        except Exception as e:
            logger.error(f"Ошибка уведомления пользователя: {e}")

    except Exception as e:
        logger.error(f"Ошибка при отклонении штрафа: {e}")
        await update.message.reply_text("⚠️ Произошла ошибка при обработке")

    finally:
        # Очищаем контекст
        context.user_data.clear()

    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("❌ Отмена действия")
    context.user_data.clear()
    return ConversationHandler.END

async def assign_fine_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Начало процесса назначения штрафа"""
    if not is_admin(update.message.from_user.id):
        await update.message.reply_text("❌ Нет прав!")
        return ConversationHandler.END
    context.user_data.clear()
    context.user_data["admin_id"] = update.message.from_user.id
    context.user_data["page"] = 0  # Добавляем номер текущей страницы

    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT id, last_name, first_name FROM users")  # Используем last_name и first_name
        users = cursor.fetchall()

    context.user_data["users"] = users  # Сохраняем данные о пользователях
    return await display_users_page(update, context)

async def display_users_page(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Отображение пользователей на странице"""
    page_size = 5
    current_page = context.user_data.get("page", 0)
    users = context.user_data.get("users", [])
    start_index = current_page * page_size
    end_index = start_index + page_size
    paginated_users = users[start_index:end_index]

    # Создаем кнопки вертикально (каждая кнопка в отдельном массиве)
    buttons = [
        [InlineKeyboardButton(
            f"{last_name or '—'} {first_name or '—'} (ID: {user_id})",
            callback_data=f"fine_user_{user_id}"
        )] for user_id, last_name, first_name in paginated_users
    ]

    # Кнопки пагинации
    pagination_buttons = []
    if current_page > 0:
        pagination_buttons.append(
            InlineKeyboardButton("⬅️ Назад", callback_data="fine_pagination_prev")
        )
    if end_index < len(users):
        pagination_buttons.append(
            InlineKeyboardButton("➡️ Вперед", callback_data="fine_pagination_next")
        )

    # Добавляем пагинацию в отдельную строку
    if pagination_buttons:
        buttons.append(pagination_buttons)

    # Создаем клавиатуру
    reply_markup = InlineKeyboardMarkup(buttons)

    # Отправляем сообщение или редактируем существующее
    if update.message:
        await update.message.reply_text(
            f"🔍 Выберите пользователя для штрафа (Страница {current_page + 1}):",
            reply_markup=reply_markup
        )
    else:
        await update.callback_query.message.edit_text(
            f"🔍 Выберите пользователя для штрафа (Страница {current_page + 1}):",
            reply_markup=reply_markup
        )

    return SELECT_USER

async def select_user_for_fine(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка выбора пользователя или пагинации"""
    query = update.callback_query
    await query.answer()
    data = query.data

    if data == "fine_pagination_prev":
        context.user_data["page"] -= 1
    elif data == "fine_pagination_next":
        context.user_data["page"] += 1
    else:
        user_id = int(data.split("_")[-1])
        context.user_data["fine_user_id"] = user_id
        await query.message.edit_text(f"➡️ Выбран пользователь ID: {user_id}")
        await query.message.reply_text("💸 Введите сумму штрафа в рублях:")
        return ENTER_AMOUNT

    return await display_users_page(update, context)

async def process_fine_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка суммы штрафа"""
    try:
        amount = float(update.message.text.replace(',', '.'))
        if amount <= 0:
            raise ValueError
        context.user_data['amount'] = amount
    except ValueError:
        await update.message.reply_text("❌ Некорректная сумма! Введите положительное число:")
        return ENTER_AMOUNT

    await update.message.reply_text("📝 Укажите причину штрафа:")
    return ENTER_REASON

async def process_fine_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка причины штрафа"""
    reason = update.message.text.strip()
    if len(reason) < 5:
        await update.message.reply_text("❌ Слишком короткое описание! Минимум 5 символов:")
        return ENTER_REASON

    context.user_data['reason'] = reason
    await update.message.reply_text("📅 Введите срок оплаты в формате ДД.ММ.ГГГГ:")
    return ENTER_DUE_DATE

async def process_due_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка срока оплаты"""
    try:
        # Парсим дату в формате ДД.ММ.ГГ
        due_date = datetime.strptime(update.message.text, "%d.%m.%y").date()
        if due_date < datetime.now().date():
            raise ValueError
        # Сохраняем в формате ДД.ММ.ГГ
        context.user_data['due_date'] = due_date.strftime("%d.%m.%y")
    except ValueError:
        await update.message.reply_text("❌ Некорректная дата! Введите в формате ДД.ММ.ГГ:")
        return ENTER_DUE_DATE

    # Сохранение в базу данных (остальное без изменений)
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()

        cursor.execute('''
            INSERT INTO fines (
                user_id,
                admin_id,
                amount,
                reason,
                due_date,
                status
            ) VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            context.user_data['fine_user_id'],
            context.user_data['admin_id'],
            context.user_data['amount'],
            context.user_data['reason'],
            context.user_data['due_date'],  # уже в формате ДД.ММ.ГГ
            'unpaid'
        ))

        # Получаем данные для лога
        cursor.execute(
            "SELECT first_name, last_name, username FROM users WHERE id = ?",
            (context.user_data['fine_user_id'],)
        )
        user_data = cursor.fetchone()
        user_name = f"{user_data[0]} {user_data[1]}" if user_data[1] else user_data[0]
        if user_data[2]:
            user_name += f" (@{user_data[2]})"
        conn.commit()

    # Логирование действия (формат сохраняется)
    log_bike_action(
        user_id=context.user_data['fine_user_id'],
        action="Назначение штрафа",
        details=(
            f"👤 Пользователь: {user_name}\n"
            f"💰 Сумма: {context.user_data['amount']}₽\n"
            f"📝 Причина: {context.user_data['reason']}"
        ),
        bike_id=context.user_data.get('bike_id')
    )

    # Отправка подтверждения (формат сохраняется)
    await update.message.reply_text(
        f"✅ Штраф успешно назначен!\n"
        f"▪️ Пользователь: {user_name}\n"
        f"▪️ Сумма: {context.user_data['amount']}₽\n"
        f"▪️ Причина: {context.user_data['reason']}\n"
        f"▪️ Срок оплаты: {context.user_data['due_date']}"  # ДД.ММ.ГГ
    )

    context.user_data.clear()
    return ConversationHandler.END

async def cancel_fine(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отмена назначения штрафа"""
    context.user_data.clear()
    await update.message.reply_text("🚫 Процесс назначения штрафа отменен")
    return ConversationHandler.END


# Обработка выбора из меню 🍽️
# Обработка выбора из меню 🍽️
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ menu_handler НА ЭТУ БЕЗОПАСНУЮ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ menu_handler НА ЭТУ ПОЛНУЮ И СТАБИЛЬНУЮ ВЕРСИЮ

async def menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Универсальный обработчик текстовых команд из Reply-меню.
    Сначала обрабатывает главные команды, а затем - ввод данных в активных диалогах.
    """
    user_id = update.message.from_user.id
    text = update.message.text.strip()
    is_user_admin = user_id in ADMIN_IDS

    # --- "БЕЛЫЙ СПИСОК" ГЛАВНЫХ КОМАНД МЕНЮ ---
    MAIN_REPLY_COMMANDS = {
        # Админ-меню (верхний уровень)
        "📋 Велосипеды", "👥 Пользователи", "🔩 Управление запчастями",
        "📩 Вопросы от пользователей", "📢 Рассылка новостей", "🗓️ Управление арендами",
        "💼 Работа", "🚴‍ Сдать в аренду велосипед", "👥 Просмотр очереди",
        "🛠️ Просмотр заявок", "🔧 Ремонт", "💰 Назначить штраф",
        "📋 Список штрафов", "🎁 Выдать скидку", "🏠 Вернуться в главное меню", "🏠 Главное меню",
        "📈 Инвестиции", "📊 Статистика", # <-- Команды уже здесь

        # Пользовательское меню
        "👤 Личный кабинет", "💰Аренда/Выкуп", "📋 Тарифы", "🛠️ Ремонт",
        "📜 Правила пользования", "📞 Контакты", "📝 Зарегистрироваться", "📩 Поддержка",

        # Вложенные админские меню
        "➕ Добавить велосипед", "🛠️ Редактировать велосипеды", "📋 Список велосипедов",
        "✅ Верификация пользователей", "👥 Зарегистрированные пользователи",
        "📅 Управление бронированиями",
        "➕ Добавить запчасть", "🔧 Редактировать запчасти", "📩 Список запчастей",
        "📝 Отметиться на работе", "📜 История отметок", "🏁 Завершить рабочий день",
        "🔧 Велосипеды в ремонте", "🚲 Рабочие велосипеды", "⚠️ Управление статусом",
        "📊 Отчет за сегодня", "📊 Отчет за другую дату",
        # Команды с динамическими счетчиками, которые мы будем проверять отдельно
        "🆕 Новые заявки", "🛠️ В работе", "💳 Ожидают оплаты", "✅ Оплаченные",
        "🔔 Уведомления", "📊 Отчеты по расходам", "💰 Расходы"
    }

    # --- ПРИОРИТЕТНАЯ ОБРАБОТКА КОМАНД ИЗ МЕНЮ ---
    # ИСПРАВЛЕННАЯ ПРОВЕРКА:
    is_main_command = (text in MAIN_REPLY_COMMANDS or
                       text.startswith("🔔 Уведомления") or
                       text.startswith("🆕 Новые заявки") or
                       text.startswith("🛠️ В работе") or
                       text.startswith("💳 Ожидают оплаты") or
                       text.startswith("✅ Оплаченные"))

    if is_main_command:
        # Принудительно сбрасываем флаги от старых диалогов, чтобы "разблокировать" бота
        for key in list(context.user_data.keys()):
            if key.startswith('edit_') or key in ['choosing_user_to_edit', 'selecting_field', 'entering_value', 'after_edit', 'expecting_repair_status', 'search_mode', 'waiting_for_report_date']:
                context.user_data.pop(key, None)
        
        # --- ОБРАБОТЧИКИ КНОПОК ---

        # Общие/Пользовательские
        if text == "📝 Зарегистрироваться": await register(update, context)
        elif text == "💰Аренда/Выкуп": await list_bikes(update, context)
        elif text == "👤 Личный кабинет": await show_profile(update, context)
        elif text == "📋 Тарифы": await show_tariffs(update, context)
        elif text == "📜 Правила пользования": await show_rules(update, context)
        elif text == "🛠️ Ремонт": await request_repair(update, context)
        elif text == "📞 Контакты": await show_contacts(update, context)
        elif text == "📩 Поддержка": await ask_support(update, context)
        elif text in ["🏠 Вернуться в главное меню", "🏠 Главное меню"]: await start(update, context)
        
        # Только для админов
        elif is_user_admin:
            if text == "📋 Велосипеды":
                keyboard = [["➕ Добавить велосипед"], ["🛠️ Редактировать велосипеды"], ["📋 Список велосипедов"], ["🏠 Вернуться в главное меню"]]
                await update.message.reply_text("🔍 Выберите действие с велосипедами:", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True))
            elif text == "➕ Добавить велосипед": await start_add_product(update, context)
            elif text == "🛠️ Редактировать велосипеды": await edit_bikes(update, context)
            elif text == "📋 Список велосипедов": await list_bikes(update, context)
            
            elif text == "👥 Пользователи":
                keyboard = [["✅ Верификация пользователей"], ["👥 Зарегистрированные пользователи"],["🏠 Вернуться в главное меню"]]
                await update.message.reply_text("🔍 Выберите действие с пользователями:", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True))
            elif text == "✅ Верификация пользователей": await verify_user(update, context)
            elif text == "👥 Зарегистрированные пользователи": await search_users(update, context)
            
            elif text == "🔩 Управление запчастями":
                keyboard = [["➕ Добавить запчасть"], ["🔧 Редактировать запчасти"], ["📩 Список запчастей"], ["🏠 Вернуться в главное меню"]]
                await update.message.reply_text("🔍 Выберите действие с запчастями:", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True))
            elif text == "➕ Добавить запчасть": await add_part(update, context)
            elif text == "🔧 Редактировать запчасти": await edit_parts(update, context)
            elif text == "📩 Список запчастей": await list_parts(update, context)
            
            elif text == "🔧 Ремонт": await repair_menu(update, context)
            elif text == "🔧 Велосипеды в ремонте": await show_bikes_by_status(update, context, 'in_repair')
            elif text == "🚲 Рабочие велосипеды": await show_bikes_by_status(update, context, 'working')
            elif text == "⚠️ Управление статусом": await show_bike_list(update, context)
            elif text == "🛠️ Просмотр заявок": await repair_dashboard_menu(update, context)
            elif text.startswith("🆕 Новые заявки"): await view_repair_requests_by_status(update, context, 'ozhidaet')
            elif text.startswith("🛠️ В работе"): await view_repair_requests_by_status(update, context, 'accepted')
            elif text.startswith("💳 Ожидают оплаты"): await view_repair_requests_by_status(update, context, 'completed')
            elif text.startswith("✅ Оплаченные"): await view_repair_requests_by_status(update, context, 'oplacheno')
            elif text == "💰 Расходы":
                await start_expense_logging(update, context)
                return # Возвращаем, так как это точка входа в ConversationHandler
            elif text == "📊 Отчеты по расходам":
                await start_report_generation(update, context)
                return # И это тоже точка входа
            elif text == "💼 Работа": await show_work_menu(update, context)
            elif text == "📝 Отметиться на работе": await mark_attendance(update, context)
            elif text == "📜 История отметок": await view_attendance_history(update, context)
            elif text == "🏁 Завершить рабочий день": await finish_attendance(update, context)
            
            elif text == "🗓️ Управление арендами": await manage_rentals(update, context)
            elif text == "📅 Управление бронированиями": await manage_bookings_panel(update, context)
            elif text == "👥 Просмотр очереди": await handle_admin_view_queue(update, context)
            elif text == "🚴‍ Сдать в аренду велосипед": await electrobike_rent_start(update, context)

            elif text.startswith("🔔 Уведомления"): await show_notifications(update, context)
            elif text == "📩 Вопросы от пользователей": await view_questions(update, context)
            elif text == "📢 Рассылка новостей": await send_news(update, context)
            elif text == "💰 Назначить штраф": await assign_fine_start(update, context)
            elif text == "📋 Список штрафов": await view_fines_menu(update, context)
            elif text == "🎁 Выдать скидку": await start_discount_process(update, context)
            elif text == "📊 Статистика": await statistics_menu(update, context)
            elif text == "📈 Инвестиции": await investment_main_menu(update, context)
            
        return # Важно выйти после обработки команды меню

    # --- ОБРАБОТКА ВВОДА ДАННЫХ В АКТИВНЫХ ДИАЛОГАХ ---
    # Этот блок сработает, только если текст не является командой из меню.
    
    # Диалог редактирования пользователя (текстовый ввод нового значения)
    if is_user_admin and context.user_data.get('entering_value'):
        await handle_new_value_for_edit(update, context)
        return

    # Диалог изменения статуса ремонта (старая логика)
    if is_user_admin and context.user_data.get('expecting_repair_status'):
        try:
            parts = text.split(maxsplit=2)
            bike_id = int(parts[0])
            status = parts[1]
            reason = parts[2] if len(parts) > 2 else None
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            if status == 'in_repair':
                if not reason:
                    await update.message.reply_text("❌ Пожалуйста, укажите причину ремонта")
                    return
                cursor.execute('''UPDATE bikes SET repair_status = ?, repair_reason = ?, available = 0 WHERE id = ?''', (status, reason, bike_id))
            elif status == 'working':
                cursor.execute('''UPDATE bikes SET repair_status = ?, repair_reason = NULL, available = 1 WHERE id = ?''', (status, bike_id))
            conn.commit()
            conn.close()
            await update.message.reply_text(f"✅ Статус велосипеда {bike_id} обновлен на {status}")
            context.user_data.pop('expecting_repair_status', None)
        except (ValueError, IndexError):
            await update.message.reply_text("❌ Неверный формат. Используйте: <id> <статус> <причина>")
        except sqlite3.Error as e:
            await update.message.reply_text(f"❌ Ошибка базы данных: {str(e)}")
        return
        
    # --- ЕСЛИ НИЧЕГО НЕ ПОДОШЛО ---
    await update.message.reply_text("❓ Неизвестная команда или неверный ввод. Пожалуйста, используйте кнопки меню. Для перезагрузки введите /start")


# <<< НАЧАЛО НОВОГО БЛОКА КОДА >>>

async def view_repair_requests_by_status(update: Update, context: ContextTypes.DEFAULT_TYPE, status: str):
    """
    УНИВЕРСАЛЬНАЯ функция для отображения заявок на ремонт по статусу.
    Показывает каждую заявку отдельным сообщением с соответствующими кнопками.
    ИСПРАВЛЕНИЕ: Корректное преобразование цены из строки в число перед форматированием.
    """
    message = update.message or update.callback_query.message

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute("""
                SELECT rr.id, u.first_name, u.last_name, u.username, b.name as bike_name, rr.description, rr.estimated_price
                FROM repair_requests rr
                JOIN users u ON rr.user_id = u.id
                JOIN bikes b ON rr.bike_id = b.id
                WHERE rr.status = ?
                ORDER BY rr.created_at DESC
            """, (status,))
            requests = await cursor.fetchall()
    except Exception as e:
        logger.error(f"Ошибка получения заявок со статусом '{status}': {e}", exc_info=True)
        await message.reply_text("🚫 Ошибка при доступе к базе данных.")
        return

    status_titles = {
        'ozhidaet': '🆕 Новые заявки',
        'accepted': '🛠️ Заявки в работе',
        'completed': '💳 Заявки, ожидающие оплаты',
        'oplacheno': '✅ Оплаченные заявки'
    }

    if not requests:
        await message.reply_text(f"✅ В категории '{status_titles.get(status)}' пусто.")
        return

    await message.reply_text(f"👇 {status_titles.get(status)} ({len(requests)} шт.):")

    for req in requests:
        info_parts = [
            f"📌 *ID заявки: {req['id']}*",
            f"👤 *Клиент:* {req['first_name']} {req['last_name'] or ''} (@{req['username'] or 'N/A'})",
            f"🚲 *Велосипед:* {req['bike_name']}",
            f"📝 *Проблема:* _{req['description']}_"
        ]

        keyboard = []

        # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
        try:
            # Пытаемся преобразовать цену в число.
            # Если цена None или пустая строка, считаем ее равной 0.
            price = float(req['estimated_price']) if req['estimated_price'] else 0.0
        except (ValueError, TypeError):
            # Если преобразование не удалось, также считаем цену равной 0 и логируем предупреждение.
            price = 0.0
            logger.warning(f"Не удалось преобразовать цену '{req['estimated_price']}' в число для заявки #{req['id']}")

        if price > 0:
            if status == 'completed':
                info_parts.append(f"💰 *Сумма к оплате: {price:.2f} ₽*")
            elif status == 'oplacheno':
                info_parts.append(f"💰 *Оплачено: {price:.2f} ₽*")
        # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

        # Добавляем кнопки в зависимости от статуса
        if status == 'ozhidaet':
            keyboard.append([
                InlineKeyboardButton("✅ Принять в работу", callback_data=f"accept_repair_{req['id']}"),
                InlineKeyboardButton("🗑️ Отклонить", callback_data=f"otmena_repair_{req['id']}")
            ])
        elif status == 'accepted':
            keyboard.append([
                InlineKeyboardButton("✅ Завершить ремонт", callback_data=f"complete_repair_{req['id']}")
            ])
        elif status == 'completed':
            keyboard.append([
                InlineKeyboardButton("💰 Отметить оплаченной", callback_data=f"paid_{req['id']}")
            ])

        final_message = "\n".join(info_parts)
        reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None

        await context.bot.send_message(
            chat_id=message.chat.id,
            text=final_message,
            parse_mode="Markdown",
            reply_markup=reply_markup
        )

# ==============================================================================
#           НОВЫЙ МОДУЛЬ РЕДАКТИРОВАНИЯ ПОЛЬЗОВАТЕЛЕЙ ПО КОМАНДЕ /edit_user
# ==============================================================================
from typing import Tuple
import json
import aiosqlite
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ContextTypes, ConversationHandler

# --- Состояния для диалога ---
EDIT_SELECT_USER, EDIT_SELECT_FIELD, EDIT_AWAIT_VALUE, EDIT_CONFIRM_DELETE = range(710, 714)

# --- Вспомогательные функции ---

async def build_user_list_for_edit(context: ContextTypes.DEFAULT_TYPE) -> (str, InlineKeyboardMarkup):
    """Строит сообщение со списком пользователей и кнопками пагинации."""
    page = context.user_data.get('edit_page', 0)
    users_per_page = 5
    offset = page * users_per_page

    async with aiosqlite.connect(DB_FILE) as conn:
        cursor = await conn.execute("SELECT COUNT(*) FROM users")
        total_users = (await cursor.fetchone())[0]
        
        cursor = await conn.execute(
            "SELECT id, first_name, last_name, verified FROM users ORDER BY id LIMIT ? OFFSET ?",
            (users_per_page, offset)
        )
        users = await cursor.fetchall()

    if not users:
        return "❌ Пользователи не найдены.", None

    keyboard = []
    for user_id, first_name, last_name, verified in users:
        status_emoji = "✅" if verified else "❌"
        display_name = f"{first_name or ''} {last_name or ''}".strip() or f"User {user_id}"
        keyboard.append([InlineKeyboardButton(
            f"{status_emoji} | {display_name} (ID: {user_id})",
            callback_data=f"edit_select_user_{user_id}"
        )])

    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("⬅️ Назад", callback_data="edit_page_prev"))
    total_pages = (total_users + users_per_page - 1) // users_per_page
    if page < total_pages - 1:
        nav_buttons.append(InlineKeyboardButton("Вперед ➡️", callback_data="edit_page_next"))

    if nav_buttons:
        keyboard.append(nav_buttons)
    keyboard.append([InlineKeyboardButton("❌ Отменить", callback_data="edit_cancel")])
    
    text = f"📋 Список пользователей (страница {page + 1} из {total_pages}):\nВыберите пользователя для редактирования:"
    return text, InlineKeyboardMarkup(keyboard)

async def build_profile_for_edit(context: ContextTypes.DEFAULT_TYPE) -> (str, InlineKeyboardMarkup):
    """Строит красивое сообщение с профилем пользователя и кнопками полей."""
    user_id = context.user_data.get('edit_user_id')
    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        cursor = await conn.execute("SELECT * FROM users WHERE id = ?", (user_id,))
        user = await cursor.fetchone()

    if not user:
        return "❌ Пользователь не найден.", None

    passport_data = json.loads(user['passport_data']) if user['passport_data'] else {}
    
    profile_text = (
        f"👤 *Редактирование профиля*\n\n"
        f"▪️ *Имя:* `{user['first_name'] or 'не указано'}`\n"
        f"▪️ *Фамилия:* `{user['last_name'] or 'не указано'}`\n"
        f"▪️ *Телефон:* `{user['phone_number'] or 'не указано'}`\n\n"
        f"📄 *Паспортные данные:*\n"
        f"   - *Серия и номер:* `{passport_data.get('Серия и номер паспорта', 'не указано')}`\n"
        f"   - *Кем выдан:* `{passport_data.get('Кем выдан', 'не указано')}`\n"
        f"   - *Дата выдачи:* `{passport_data.get('Дата выдачи', 'не указано')}`\n"
        f"   - *Адрес:* `{passport_data.get('Адрес регистрации', 'не указано')}`\n\n"
        "Выберите поле для изменения:"
    )

    # <<< ИЗМЕНЕНИЕ: Добавлена кнопка "Удалить пользователя" >>>
    keyboard = [
        [
            InlineKeyboardButton("Имя", callback_data="edit_field_first_name"),
            InlineKeyboardButton("Фамилия", callback_data="edit_field_last_name"),
            InlineKeyboardButton("Телефон", callback_data="edit_field_phone_number"),
        ],
        [InlineKeyboardButton("Паспорт: Серия/Номер", callback_data="edit_field_passport_series_number")],
        [InlineKeyboardButton("Паспорт: Кем выдан", callback_data="edit_field_passport_issued_by")],
        [InlineKeyboardButton("Паспорт: Дата выдачи", callback_data="edit_field_passport_issue_date")],
        [InlineKeyboardButton("Паспорт: Адрес", callback_data="edit_field_passport_address")],
        # Новая кнопка удаления
        [InlineKeyboardButton("🗑️ Удалить пользователя", callback_data="edit_action_delete")],
        [
            InlineKeyboardButton("⬅️ К списку", callback_data="edit_back_to_list"),
            InlineKeyboardButton("✅ Завершить", callback_data="edit_cancel"),
        ]
    ]
    return profile_text, InlineKeyboardMarkup(keyboard)

# --- Функции-обработчики состояний ---

async def edit_user(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Точка входа в диалог по команде /edit_user. Показывает список пользователей."""
    if not is_admin(update.message.from_user.id):
        await update.message.reply_text("🚫 Эта команда доступна только администратору.")
        return ConversationHandler.END

    context.user_data.clear()
    context.user_data['edit_page'] = 0
    await update.message.reply_text("Загружаю список пользователей...", reply_markup=ReplyKeyboardRemove())
    text, reply_markup = await build_user_list_for_edit(context)
    await update.message.reply_text(text, reply_markup=reply_markup)
    return EDIT_SELECT_USER

async def edit_user_handle_user_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает выбор пользователя или пагинацию."""
    query = update.callback_query
    await query.answer()
    
    if query.data == "edit_page_prev":
        context.user_data['edit_page'] = max(0, context.user_data.get('edit_page', 0) - 1)
        text, markup = await build_user_list_for_edit(context)
        await query.edit_message_text(text, reply_markup=markup)
        return EDIT_SELECT_USER
        
    elif query.data == "edit_page_next":
        context.user_data['edit_page'] += 1
        text, markup = await build_user_list_for_edit(context)
        await query.edit_message_text(text, reply_markup=markup)
        return EDIT_SELECT_USER
        
    elif query.data.startswith("edit_select_user_"):
        user_id = int(query.data.split('_')[-1])
        context.user_data['edit_user_id'] = user_id
        text, markup = await build_profile_for_edit(context)
        await query.edit_message_text(text, reply_markup=markup, parse_mode='Markdown')
        return EDIT_SELECT_FIELD

    return EDIT_SELECT_USER

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ edit_user_handle_field_selection НА ЭТУ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ edit_user_handle_field_selection НА ЭТУ

async def edit_user_handle_field_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обрабатывает выбор поля для редактирования ИЛИ действия (удаление)."""
    query = update.callback_query
    await query.answer()

    # --- Обработка кнопок навигации ---
    if query.data == "edit_back_to_list":
        context.user_data.pop('edit_user_id', None)
        text, markup = await build_user_list_for_edit(context)
        await query.edit_message_text(text, reply_markup=markup)
        return EDIT_SELECT_USER

    if query.data == "edit_cancel":
        return await edit_user_cancel(update, context)

    # <<< НАЧАЛО НОВОГО БЛОКА: Обработка кнопки удаления >>>
    if query.data == "edit_action_delete":
        user_id = context.user_data.get('edit_user_id')
        
        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("SELECT first_name, last_name FROM users WHERE id = ?", (user_id,))
            user = await cursor.fetchone()
        user_name = f"{user[0] or ''} {user[1] or ''}".strip() or f"ID {user_id}"

        text = (
            f"Вы уверены, что хотите удалить пользователя *{user_name}* (ID: `{user_id}`)?"
            f"\n\n**Это действие необратимо!**"
        )
        keyboard = [
            [InlineKeyboardButton("❌ ДА, УДАЛИТЬ", callback_data="edit_confirm_delete_yes")],
            # ИСПОЛЬЗУЕМ НОВЫЙ, УНИКАЛЬНЫЙ callback_data
            [InlineKeyboardButton("✅ Нет, вернуться", callback_data="edit_back_to_profile")]
        ]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
        return EDIT_CONFIRM_DELETE
    # <<< КОНЕЦ НОВОГО БЛОКА >>>

    # --- Старая логика для редактирования полей ---
    field_key = query.data.split('edit_field_')[-1]
    context.user_data['edit_field_key'] = field_key
    field_map = {
        "first_name": "Имя", "last_name": "Фамилия", "phone_number": "Телефон",
        "passport_series_number": "Паспорт: Серия/Номер", "passport_issued_by": "Паспорт: Кем выдан",
        "passport_issue_date": "Паспорт: Дата выдачи", "passport_address": "Паспорт: Адрес"
    }
    await query.edit_message_text(f"✍️ Введите новое значение для поля *'{field_map.get(field_key)}'*:", parse_mode='Markdown')
    return EDIT_AWAIT_VALUE

# <<< НАЧАЛО НОВОЙ ФУНКЦИИ >>>
async def edit_user_delete_confirmed(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Выполняет удаление пользователя после подтверждения.
    Проверяет наличие активных аренд перед удалением.
    """
    query = update.callback_query
    await query.answer()
    
    user_id = context.user_data.get('edit_user_id')

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            # 1. Проверка безопасности: есть ли у пользователя активная аренда?
            cursor = await conn.execute(
                "SELECT COUNT(*) FROM bookings WHERE user_id = ? AND status = 'rented'",
                (user_id,)
            )
            active_rentals = (await cursor.fetchone())[0]

            if active_rentals > 0:
                await query.edit_message_text(
                    f"🚫 **Невозможно удалить!**\nУ пользователя есть {active_rentals} активных аренд/рассрочек. "
                    "Сначала необходимо завершить все сделки.",
                    parse_mode="Markdown"
                )
                # Возвращаемся к списку пользователей, чтобы админ мог выбрать другого
                text, markup = await build_user_list_for_edit(context)
                await context.bot.send_message(query.message.chat.id, text, reply_markup=markup)
                return EDIT_SELECT_USER

            # 2. Получаем имя для финального сообщения ПЕРЕД удалением
            cursor = await conn.execute("SELECT first_name, last_name FROM users WHERE id = ?", (user_id,))
            user = await cursor.fetchone()
            user_name = f"{user[0] or ''} {user[1] or ''}".strip() or f"ID {user_id}"

            # 3. Удаление пользователя
            await conn.execute("DELETE FROM users WHERE id = ?", (user_id,))
            await conn.commit()
            
            await query.edit_message_text(f"✅ Пользователь *{user_name}* успешно удален.", parse_mode="Markdown")

    except Exception as e:
        logger.error(f"Ошибка при удалении пользователя {user_id}: {e}", exc_info=True)
        await query.edit_message_text(f"❌ Произошла ошибка при удалении: {e}")

    # После удаления возвращаемся к обновленному списку пользователей
    context.user_data.pop('edit_user_id', None)
    text, markup = await build_user_list_for_edit(context)
    await context.bot.send_message(query.message.chat.id, text, reply_markup=markup)
    return EDIT_SELECT_USER
# <<< КОНЕЦ НОВОЙ ФУНКЦИИ >>>

async def edit_user_handle_new_value(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Принимает новое значение, обновляет БД и возвращает к профилю."""
    new_value = update.message.text
    field_key = context.user_data.get('edit_field_key')
    user_id = context.user_data.get('edit_user_id')

    async with aiosqlite.connect(DB_FILE) as conn:
        if not field_key.startswith('passport_'):
            await conn.execute(f"UPDATE users SET {field_key} = ? WHERE id = ?", (new_value, user_id))
        else:
            cursor = await conn.execute("SELECT passport_data FROM users WHERE id = ?", (user_id,))
            result = await cursor.fetchone()
            passport_data = json.loads(result[0]) if result and result[0] else {}
            
            passport_field_map = {
                "passport_series_number": "Серия и номер паспорта", "passport_issued_by": "Кем выдан",
                "passport_issue_date": "Дата выдачи", "passport_address": "Адрес регистрации"
            }
            passport_key = passport_field_map.get(field_key)
            if passport_key:
                passport_data[passport_key] = new_value
                await conn.execute("UPDATE users SET passport_data = ? WHERE id = ?", (json.dumps(passport_data, ensure_ascii=False), user_id))
        
        await conn.commit()
    
    await update.message.reply_text("✅ Данные обновлены!")

    # Возвращаемся к отображению профиля
    text, markup = await build_profile_for_edit(context)
    await update.message.reply_text(text, reply_markup=markup, parse_mode='Markdown')
    return EDIT_SELECT_FIELD

async def edit_user_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Завершает диалог и возвращает в главное меню."""
    context.user_data.clear()
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text("Редактирование отменено.")
    else:
        await update.message.reply_text("Редактирование отменено.")
        
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="Вы вернулись в главное меню.",
        reply_markup=get_main_menu(update.effective_user.id)
    )
    return ConversationHandler.END

# ==============================================================================
#           КОНЕЦ НОВОГО МОДУЛЯ
# ==============================================================================

ELECTROBIKE_SELECT_USER, ELECTROBIKE_SELECT_BIKE, ELECTROBIKE_SELECT_DAYS, ELECTROBIKE_YANDEX_PRO = range(4)

# Логирование
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Цены за аренду
PRICE_FOR_PERIOD = {
    7: 3750,
    8: 3750,
    14: 7500,
    28: 14000,
    30: 15000
}
ELECTROBIKE_SELECT_USER, ELECTROBIKE_SELECT_BIKE, ELECTROBIKE_SELECT_DAYS, ELECTROBIKE_YANDEX_PRO = range(4)

# Логирование
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Цены за аренду
PRICE_FOR_PERIOD = {
    7: 3750,
    8: 3750,
    14: 7500,
    28: 14000,
    30: 15000
}
BASE_PRICE_PER_DAY = 500  # Базовая ставка за день

# ---------- Обработчик команды /rent_bike ----------
async def electrobike_rent_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Обработчик начала процесса аренды.
    """
    try:
        context.user_data.clear()
        # --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
        # Добавляем эмодзи для соответствия главному обработчику меню
        return_keyboard = ReplyKeyboardMarkup([["🏠 Вернуться в главное меню"]], resize_keyboard=True)
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---

        if update.message:
            await update.message.reply_text(
                "🚴 Инициализация процесса аренды...",
                reply_markup=return_keyboard
            )
            await electrobike_show_users_page(update, context, page=1)
        elif update.callback_query:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="🚴 Инициализация процесса аренды...",
                reply_markup=return_keyboard
            )
            await electrobike_show_users_page(update, context, page=1)
        else:
            logger.error("Неподдерживаемый тип события для начала аренды")
            return ConversationHandler.END

        logger.info(f"Начало процесса аренды для пользователя: {update.effective_user.id}")
        return ELECTROBIKE_SELECT_USER

    except Exception as e:
        logger.error(f"Ошибка при инициализации аренды: {str(e)}")
        error_message = "⚠️ Произошла ошибка при запуске процесса аренды. Попробуйте позже."
        if update.message:
            await update.message.reply_text(error_message)
        elif update.callback_query:
            await update.callback_query.edit_message_text(error_message)
        return ConversationHandler.END

# ---------- Отмена аренды ----------
async def electrobike_cancel_rental(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Отмена аренды и возврат в главное меню.
    """
    await update.message.reply_text(
        "Возврат в главное меню.",
        reply_markup=get_main_menu(update.effective_user.id)
    )
    context.user_data.clear()
    return ConversationHandler.END


async def show_users_page(update: Update, context: CallbackContext, page: int = 0):
    """
    Отображает страницу с найденными пользователями и кнопками пагинации.
    Использует список пользователей, сохраненный в context.user_data['all_users'].
    """
    # Получаем полный список найденных пользователей из контекста
    all_users = context.user_data.get('all_users', [])
    if not all_users:
        await update.message.reply_text("🚫 Список пользователей пуст или не найден.")
        return

    PAGE_SIZE = 5
    total_items = len(all_users)
    total_pages = (total_items + PAGE_SIZE - 1) // PAGE_SIZE

    # Рассчитываем срез для текущей страницы
    offset = page * PAGE_SIZE
    paginated_users = all_users[offset : offset + PAGE_SIZE]

    keyboard = []
    for user_id, first_name, last_name, username in paginated_users:
        button_text = f"{first_name} {last_name or ''} (@{username or 'N/A'})"
        # Эта callback_data должна обрабатываться вашим хендлером view_user_rentals
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"view_rentals_{user_id}")])

    # Кнопки пагинации
    pagination_row = []
    if page > 0:
        # Важно: callback_data для пагинации после поиска должна быть уникальной
        pagination_row.append(InlineKeyboardButton("⬅️", callback_data=f"search_page_{page - 1}"))
    if page < total_pages - 1:
        pagination_row.append(InlineKeyboardButton("➡️", callback_data=f"search_page_{page + 1}"))

    if pagination_row:
        keyboard.append(pagination_row)
        
    # Кнопка для начала нового поиска
    keyboard.append([InlineKeyboardButton("🔍 Новый поиск", callback_data="poisk_start")])

    message_text = f"📋 Результаты поиска (Стр. {page + 1}/{total_pages}):"
    
    # Определяем, редактировать сообщение или отправлять новое
    if update.callback_query:
        await update.callback_query.edit_message_text(message_text, reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await update.message.reply_text(message_text, reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_search_pagination(update: Update, context: CallbackContext) -> int:
    """Обрабатывает нажатия кнопок пагинации в результатах поиска."""
    query = update.callback_query
    await query.answer()

    page = int(query.data.split('_')[-1])
    # Просто вызываем функцию отображения с новым номером страницы
    await show_users_page(update, context, page=page)

    # Остаемся в том же состоянии, чтобы другие кнопки продолжали работать
    return MANAGE_RENTALS_MENU
# ---------- Показ страницы пользователей ----------
async def electrobike_show_users_page(update: Update, context: ContextTypes.DEFAULT_TYPE, page: int):
    """
    Показывает страницу с пользователями.
    """
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id, first_name, last_name FROM users LIMIT 5 OFFSET ?", ((page - 1) * 5,))
    users = cursor.fetchall()
    cursor.execute("SELECT COUNT(*) FROM users")
    total_users = cursor.fetchone()[0]
    conn.close()

    keyboard = [
        [InlineKeyboardButton(f"{user[1]} {user[2]}", callback_data=f"electrobike_select_user_{user[0]}")]
        for user in users
    ]

    pagination = []
    if page > 1:
        pagination.append(InlineKeyboardButton("⬅️", callback_data=f"electrobike_user_page_prev_{page}"))
    pagination.append(InlineKeyboardButton("🔍 Поиск", callback_data="electrobike_search_user"))
    if total_users > page * 5:
        pagination.append(InlineKeyboardButton("➡️", callback_data=f"electrobike_user_page_next_{page}"))
    if pagination:
        keyboard.append(pagination)

    if update.callback_query:
        await update.callback_query.edit_message_text(
            "📋 Выберите пользователя:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    else:
        await update.message.reply_text(
            "📋 Выберите пользователя:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

# ---------- Обработчик состояния SELECT_USER ----------
async def electrobike_user_state_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Обрабатывает все действия в состоянии выбора пользователя.
    """
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        data = query.data

        if data.startswith("electrobike_user_page_"):
            action, current_page = data.split("_")[3:]
            new_page = int(current_page) + 1 if action == "next" else int(current_page) - 1
            new_page = max(1, new_page)
            await electrobike_show_users_page(update, context, new_page)
            return ELECTROBIKE_SELECT_USER

        elif data.startswith("electrobike_select_user_"):
            user_id = int(data.split("_")[3])
            context.user_data['selected_user_id'] = user_id
            await electrobike_show_bikes_page(update, context, page=1)
            return ELECTROBIKE_SELECT_BIKE

        elif data == "electrobike_search_user":
            await query.edit_message_text("🔍 Введите имя или фамилию пользователя:")
            context.user_data['search_mode'] = 'user'
            return ELECTROBIKE_SELECT_USER

    elif update.message and context.user_data.get('search_mode') == 'user':
        search_term = update.message.text.strip()
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT id, first_name, last_name FROM users WHERE first_name LIKE ? OR last_name LIKE ? LIMIT 10",
            (f'%{search_term}%', f'%{search_term}%')
        )
        users = cursor.fetchall()
        conn.close()

        if not users:
            await update.message.reply_text("❌ Пользователи не найдены")
            return ELECTROBIKE_SELECT_USER

        keyboard = [
            [InlineKeyboardButton(f"{user[1]} {user[2]}", callback_data=f"electrobike_select_user_{user[0]}")]
            for user in users
        ]
        await update.message.reply_text(
            "🔍 Результаты поиска:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        del context.user_data['search_mode']
        return ELECTROBIKE_SELECT_USER

    return ELECTROBIKE_SELECT_USER

# ---------- Показ страницы велосипедов ----------
async def electrobike_show_bikes_page(update: Update, context: ContextTypes.DEFAULT_TYPE, page: int):
    """
    Показывает страницу с велосипедами:
    - Если у пользователя есть confirmed бронь, отображается только забронированный велосипед.
    - Если у пользователя rented аренда, отображается сообщение о текущей аренде.
    - Если активной брони нет, отображаются доступные велосипеды с пагинацией.
    """
    try:
        user_id = context.user_data['selected_user_id']
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Логируем общее состояние базы для диагностики
        cursor.execute("SELECT COUNT(*) FROM bikes WHERE available = 1")
        available_bikes_count = cursor.fetchone()[0]
        logger.info(f"Всего велосипедов с available=1: {available_bikes_count}")

        cursor.execute("SELECT COUNT(*) FROM bookings WHERE status IN ('confirmed', 'rented')")
        active_bookings_count = cursor.fetchone()[0]
        logger.info(f"Активных бронирований/аренд: {active_bookings_count}")

        # Проверяем активные брони или аренду для пользователя
        cursor.execute("""
            SELECT bike_id, status
            FROM bookings
            WHERE user_id = ?
            AND status IN ('confirmed', 'rented')
        """, (user_id,))
        active_booking = cursor.fetchone()

        if active_booking:
            bike_id, status = active_booking

            if status == 'rented':
                # Сообщение о текущей аренде
                cursor.execute("SELECT id, name FROM bikes WHERE id = ?", (bike_id,))
                bike = cursor.fetchone()
                message_text = (
                    f"🚲 У вас уже арендован велосипед:\n\n"
                    f"ID: {bike[0]}\n"
                    f"Модель: {bike[1]}\n"
                    f"Для изменения срока аренды обратитесь в поддержку."
                )
                keyboard = [[InlineKeyboardButton("🔄 Обновить статус", callback_data="refresh_status")]]
                conn.close()

                if update.callback_query:
                    await update.callback_query.edit_message_text(
                        message_text, reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await update.message.reply_text(
                        message_text, reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                return

            elif status == 'confirmed':
                # Показать только забронированный велосипед
                cursor.execute("SELECT id, name FROM bikes WHERE id = ?", (bike_id,))
                bike = cursor.fetchone()
                message_text = (
                    f"🚲 У пользователя есть подтвержденная бронь:\n\n"
                    f"ID: {bike[0]}\n"
                    f"Модель: {bike[1]}"
                )
                keyboard = [[
                    InlineKeyboardButton(
                        "📅 Выбрать срок аренды",
                        callback_data=f"electrobike_select_bike_{bike_id}"
                    )
                ]]
                conn.close()

                if update.callback_query:
                    await update.callback_query.edit_message_text(
                        message_text, reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await update.message.reply_text(
                        message_text, reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                return

        # Показываем доступные велосипеды
        cursor.execute("""
            SELECT id, name
            FROM bikes
            WHERE available = 1
            AND id NOT IN (
                SELECT bike_id
                FROM bookings
                WHERE status IN ('confirmed', 'rented')
                AND bike_id IS NOT NULL
            )
            LIMIT 5 OFFSET ?
        """, ((page - 1) * 5,))
        bikes = cursor.fetchall()
        logger.info(f"Найдено доступных велосипедов на странице {page}: {len(bikes)}")

        cursor.execute("""
            SELECT COUNT(*)
            FROM bikes
            WHERE available = 1
            AND id NOT IN (
                SELECT bike_id
                FROM bookings
                WHERE status IN ('confirmed', 'rented')
                AND bike_id IS NOT NULL
            )
        """)
        total_bikes = cursor.fetchone()[0]
        logger.info(f"Общее количество доступных велосипедов: {total_bikes}")

        conn.close()

        if not bikes:
            message_text = "❌ Нет доступных велосипедов для аренды. Проверьте базу данных или обратитесь к администратору."
            keyboard = []
        else:
            message_text = "🚴‍♂️ Доступные велосипеды:\n\n" + "\n".join(
                [f"{bike[1]} (ID: {bike[0]})" for bike in bikes]
            )
            keyboard = [
                [InlineKeyboardButton(bike[1], callback_data=f"electrobike_select_bike_{bike[0]}")]
                for bike in bikes
            ]

            # Добавляем кнопки пагинации
            pagination = []
            pagination.append(InlineKeyboardButton("🔍 Поиск", callback_data="electrobike_search_bike"))
            if page > 1:
                pagination.append(InlineKeyboardButton("<", callback_data=f"electrobike_bike_page_prev_{page}"))
            if total_bikes > page * 5:
                pagination.append(InlineKeyboardButton(">", callback_data=f"electrobike_bike_page_next_{page}"))
            if pagination:
                keyboard.append(pagination)

        # Отправляем сообщение
        if update.callback_query:
            await update.callback_query.edit_message_text(
                message_text, reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await update.message.reply_text(
                message_text, reply_markup=InlineKeyboardMarkup(keyboard)
            )

    except sqlite3.Error as db_error:
        logger.error(f"Ошибка базы данных: {str(db_error)}")
        await update.message.reply_text("⚠️ Ошибка базы данных. Попробуйте позже или обратитесь к администратору.")
    except Exception as e:
        logger.error(f"Ошибка: {str(e)}")
        await update.message.reply_text("⚠️ Произошла непредвиденная ошибка. Попробуйте позже.")

# ---------- Обработчик состояния SELECT_BIKE ----------
async def electrobike_bike_state_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Обрабатывает все действия в состоянии выбора велосипеда.
    """
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        data = query.data

        if data.startswith("electrobike_bike_page_"):
            action, current_page = data.split("_")[3:]
            new_page = int(current_page) + 1 if action == "next" else int(current_page) - 1
            new_page = max(1, new_page)
            await electrobike_show_bikes_page(update, context, new_page)
            return ELECTROBIKE_SELECT_BIKE

        elif data.startswith("electrobike_select_bike_"):
            bike_id = int(data.split("_")[3])
            context.user_data['selected_bike_id'] = bike_id
            await query.edit_message_text(
                "📅 Выберите срок аренды:",
                reply_markup=electrobike_create_rental_days_keyboard()
            )
            return ELECTROBIKE_SELECT_DAYS

        elif data == "electrobike_search_bike":
            await query.edit_message_text("🔍 Введите название велосипеда:")
            context.user_data['search_mode'] = 'bike'
            return ELECTROBIKE_SELECT_BIKE

    elif update.message and context.user_data.get('search_mode') == 'bike':
        search_term = update.message.text.strip()
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT id, name FROM bikes WHERE name LIKE ? AND available=1 LIMIT 10",
            (f'%{search_term}%',)
        )
        bikes = cursor.fetchall()
        conn.close()

        if not bikes:
            await update.message.reply_text("❌ Велосипеды не найдены")
            return ELECTROBIKE_SELECT_BIKE

        keyboard = [
            [InlineKeyboardButton(bike[1], callback_data=f"electrobike_select_bike_{bike[0]}")]
            for bike in bikes
        ]
        await update.message.reply_text(
            "🔍 Результаты поиска:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        del context.user_data['search_mode']
        return ELECTROBIKE_SELECT_BIKE

    return ELECTROBIKE_SELECT_BIKE

# ---------- Создание клавиатуры для выбора срока аренды ----------
def electrobike_create_rental_days_keyboard():
    """
    Создает клавиатуру для выбора срока аренды.
    """
    keyboard = []
    row = []
    for i in range(1, 32):
        row.append(InlineKeyboardButton(str(i), callback_data=f"electrobike_rental_days_{i}"))
        if i % 5 == 0:
            keyboard.append(row)
            row = []
    if row:
        keyboard.append(row)
    return InlineKeyboardMarkup(keyboard)

# ---------- Обработчик выбора срока аренды ----------
async def electrobike_select_rental_days(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Обрабатывает выбор срока аренды и запрашивает статус курьера Яндекс Про.
    """
    query = update.callback_query
    await query.answer()

    rental_days = int(query.data.split("_")[3])
    context.user_data['rental_days'] = rental_days

    keyboard = [
        [InlineKeyboardButton("Да, курьер Яндекс Про", callback_data="yandex_pro_yes")],
        [InlineKeyboardButton("Нет", callback_data="yandex_pro_no")]
    ]

    await query.edit_message_text(
        "Курьер является сотрудником Яндекс ПРО?",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

    return ELECTROBIKE_YANDEX_PRO

# ---------- Обработчик статуса Яндекс Про ----------
# corrected_code.py

import aiosqlite # Убедитесь, что этот импорт есть в начале файла

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
async def electrobike_yandex_pro_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ПОЛНОСТЬЮ АСИНХРОННАЯ ВЕРСИЯ:
    Обрабатывает выбор статуса курьера Яндекс Про и завершает оформление аренды.
    Использует aiosqlite для безопасной работы с БД.
    """
    query = update.callback_query
    await query.answer()

    try:
        is_yandex_pro = 1 if query.data == "yandex_pro_yes" else 0
        bike_id = context.user_data['selected_bike_id']
        user_id = context.user_data['selected_user_id']
        rental_days = context.user_data['rental_days']
        rental_price = calculate_rental_price(rental_days)

        # Используем асинхронный менеджер для работы с БД
        async with aiosqlite.connect('bikes.db') as conn:
            conn.row_factory = aiosqlite.Row
            # Начинаем транзакцию
            await conn.execute("BEGIN")

            # Обновляем статус Яндекс Про
            await conn.execute("UPDATE users SET yandexpro = ? WHERE id = ?", (is_yandex_pro, user_id))

            # Получаем данные текущей аренды (если есть)
            cursor = await conn.execute("""
                SELECT booking_date, end_date
                FROM bookings WHERE user_id = ? AND bike_id = ? AND status = 'rented'
            """, (user_id, bike_id))
            existing_booking = await cursor.fetchone()

            # Рассчитываем даты аренды
            if existing_booking and existing_booking['booking_date']:
                start_date = datetime.strptime(existing_booking['booking_date'], '%d.%m.%Y')
                new_end_date = datetime.strptime(existing_booking['end_date'], '%d.%m.%Y') + timedelta(days=rental_days)
            else:
                start_date = datetime.now()
                new_end_date = start_date + timedelta(days=rental_days)

            # Удаляем все предыдущие брони
            await conn.execute("DELETE FROM bookings WHERE user_id = ? AND bike_id = ?", (user_id, bike_id))

            # Создаем новую запись аренды
            await conn.execute("""
                INSERT INTO bookings (user_id, bike_id, booking_date, end_date, status)
                VALUES (?, ?, ?, ?, 'rented')
            """, (user_id, bike_id, start_date.strftime('%d.%m.%Y'), new_end_date.strftime('%d.%m.%Y')))

            # Обновляем статус велосипеда
            await conn.execute("UPDATE bikes SET available = 0 WHERE id = ?", (bike_id,))

            # Логирование (используя асинхронную функцию)
            log_details = (
                f"Аренда на {rental_days} дней. "
                f"Период: {start_date.strftime('%d.%m.%Y')}-{new_end_date.strftime('%d.%m.%Y')}"
                f"{' (Курьер Яндекс Про)' if is_yandex_pro else ''}"
            )
            await log_bike_action(conn, bike_id, user_id, "Аренда", log_details, rental_price)

            # Формирование сообщения для администратора
            user_cursor = await conn.execute("SELECT first_name, last_name FROM users WHERE id = ?", (user_id,))
            user_record = await user_cursor.fetchone()
            user_name = f"{user_record['first_name']} {user_record['last_name']}" if user_record else "Неизвестный пользователь"

            bike_cursor = await conn.execute("SELECT name FROM bikes WHERE id = ?", (bike_id,))
            bike_name = (await bike_cursor.fetchone())['name']

            # Завершаем транзакцию
            await conn.commit()

        # Формирование текста сообщения после успешной транзакции
        period_message = (
            f"📅 Срок аренды: {rental_days} дней\n"
            f"📆 Период: с {start_date.strftime('%d.%m.%Y')} "
            f"по {new_end_date.strftime('%d.%m.%Y')}"
        )
        yandex_pro_status = "✅ Курьер Яндекс Про" if is_yandex_pro else "❌ Не курьер Яндекс Про"

        # Отправка сообщений
        await query.edit_message_text(
            f"✅ Аренда успешно оформлена!\n"
            f"👤 Пользователь: {user_name}\n"
            f"🚲 Велосипед: {bike_name}\n"
            f"💳 Стоимость: {rental_price} руб.\n"
            f"{period_message}\n"
            f"{yandex_pro_status}"
        )

        user_msg = (
            f"✅ Вам был сдан электровелосипед!\n"
            f"🚲 Велосипед: {bike_name}\n"
            f"{period_message}\n"
        )
        await context.bot.send_message(chat_id=user_id, text=user_msg)

    except Exception as e:
        logger.error(f"Ошибка при аренде: {str(e)}", exc_info=True)
        # Откатываем транзакцию в случае любой ошибки
        if 'conn' in locals() and conn.is_connected():
            await conn.rollback()
        await query.edit_message_text("❌ Произошла ошибка при обработке аренды")

    finally:
        context.user_data.clear()
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Главное меню:",
            reply_markup=get_main_menu(update.effective_user.id)
        )

    return ConversationHandler.END

# ---------- Функция возврата велосипеда ----------
async def electrobike_return_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Завершает аренду и возвращает велосипед в доступные.
    """
    try:
        user_id = context.user_data.get('selected_user_id')
        if not user_id:
            await update.message.reply_text("⚠️ Пользователь не выбран. Начните процесс аренды заново.")
            return ConversationHandler.END

        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Проверяем активную аренду
        cursor.execute("""
            SELECT bike_id
            FROM bookings
            WHERE user_id = ? AND status = 'rented'
        """, (user_id,))
        booking = cursor.fetchone()

        if not booking:
            await update.message.reply_text("❌ У пользователя нет активной аренды.")
            conn.close()
            return ConversationHandler.END

        bike_id = booking[0]

        # Обновляем статус велосипеда
        cursor.execute("UPDATE bikes SET available = 1 WHERE id = ?", (bike_id,))

        # Удаляем запись об аренде
        cursor.execute("DELETE FROM bookings WHERE user_id = ? AND bike_id = ? AND status = 'rented'",
                      (user_id, bike_id))

        # Логируем действие
        cursor.execute("SELECT name FROM bikes WHERE id = ?", (bike_id,))
        bike_name = cursor.fetchone()[0]
        log_bike_action(
            bike_id=bike_id,
            user_id=user_id,
            action="Возврат",
            details=f"Велосипед {bike_name} возвращен пользователем {user_id}",
            amount=0
        )

        conn.commit()
        conn.close()

        await update.message.reply_text(
            f"✅ Велосипед {bike_name} успешно возвращен!",
            reply_markup=get_main_menu(update.effective_user.id)
        )
        context.user_data.clear()
        return ConversationHandler.END

    except sqlite3.Error as db_error:
        logger.error(f"Ошибка базы данных при возврате: {str(db_error)}")
        await update.message.reply_text("⚠️ Ошибка базы данных. Попробуйте позже.")
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"Ошибка при возврате: {str(e)}")
        await update.message.reply_text("⚠️ Произошла ошибка. Попробуйте позже.")
        return ConversationHandler.END




# ---------- Функция расчета цены ----------
def calculate_rental_price(rental_days: int) -> int:
    return PRICE_FOR_PERIOD.get(rental_days, rental_days * BASE_PRICE_PER_DAY)


async def add_part(update: Update, context) -> int:
    user_id = update.message.from_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 У вас нет прав для добавления запчастей.")
        return ConversationHandler.END  # Завершает диалог, если пользователь не админ

    await update.message.reply_text("Введите название запчасти:")
    return 1  # Переход к состоянию ввода названия

async def set_part_name(update: Update, context) -> int:
    context.user_data['part_name'] = update.message.text
    await update.message.reply_text("Введите описание запчасти (или просто нажмите 'Пропустить'):")
    return 2  # Переход к следующему шагу (описание)

async def set_part_description(update: Update, context) -> int:
    description = update.message.text.strip()

    # Если описание не указано, можем пропустить его
    if description:
        context.user_data['part_description'] = description

    await update.message.reply_text("Введите количество (шт.):")
    return 3  # Переход к следующему шагу (количество)

async def set_part_quantity(update: Update, context) -> int:
    quantity = update.message.text.strip()

    try:
        quantity = int(quantity)  # Пробуем преобразовать в число
        context.user_data['part_quantity'] = quantity  # Сохраняем количество
    except ValueError:
        await update.message.reply_text("🚫 Пожалуйста, введите корректное количество.")
        return 3  # Остаёмся на шаге ввода количества

    await update.message.reply_text("Отправьте фотографию запчасти:")
    return 4  # Переход к шагу добавления фото

async def work_menu_handler(update: Update, context) -> None:
    text = update.message.text

    if text == "📝 Отметиться на работе":
        await mark_attendance(update, context)  # Обработка отметки на работе
    elif text == "📜 История отметок":
        await view_attendance_history(update, context)  # Обработка истории отметок
    elif text == "🏁 Завершить рабочий день":
        await finish_attendance(update, context)  # Обработка завершения рабочего дня
    elif text == "🏠 Вернуться в главное меню":
        await start(update, context)  # Вернуться в главное меню

async def set_part_photo(update: Update, context) -> int:
    if update.message.photo:
        photo = update.message.photo[-1]
        context.user_data['part_photo_url'] = photo.file_id

        # Сохраняем данные запчасти в базу
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute('''INSERT INTO parts (name, description, available, photo_url, quantity)
                          VALUES (?, ?, ?, ?, ?)''', (
                              context.user_data['part_name'],
                              context.user_data.get('part_description', ""),  # Передаем пустую строку, если описание не указано
                              1,  # Статус доступности (по умолчанию)
                              context.user_data['part_photo_url'],
                              context.user_data['part_quantity'],  # Количество
                          ))
        conn.commit()
        conn.close()

        await update.message.reply_text(f"🎉 Запчасть '{context.user_data['part_name']}' успешно добавлена с количеством {context.user_data['part_quantity']} штук!")
        return ConversationHandler.END
    else:
        await update.message.reply_text("🚫 Пожалуйста, отправьте фотографию запчасти.")
        return 4  # Остаемся на шаге добавления фото

# Команда для редактирования запчастей администратора 🔧
async def edit_parts(update: Update, context) -> None:
    user_id = update.message.from_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 У вас нет прав для редактирования запчастей.")
        return

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id, name FROM parts")
    parts = cursor.fetchall()
    conn.close()

    if not parts:
        await update.message.reply_text("🚫 Запчасти пока не добавлены.")
        return

    keyboard = [[InlineKeyboardButton(part[1], callback_data=f"edit_part_{part[0]}")] for part in parts]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("🖊️ Выберите запчасть для редактирования:", reply_markup=reply_markup)

# Состояния для ConversationHandler
EDITING_MENU, CHANGE_STATUS, CHANGE_QUANTITY = range(3)

async def start_editing_part(update: Update, context) -> int:
    query = update.callback_query
    await query.answer()
    part_id = query.data.split("_")[2]

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT name, description, available, quantity FROM parts WHERE id=?", (part_id,))
    part = cursor.fetchone()
    conn.close()

    if not part:
        await query.message.reply_text("🚫 Запчасть не найдена.")
        return ConversationHandler.END

    context.user_data.update({
        'editing_part': {
            'id': part_id,
            'name': part[0],
            'description': part[1],
            'available': part[2],
            'quantity': part[3]
        },
        'original_data': {
            'available': part[2],
            'quantity': part[3]
        }
    })

    return await show_editing_menu(query.message, context)

async def show_editing_menu(message, context):
    part = context.user_data['editing_part']
    text = (
        f"🛠 Редактирование запчасти:\n\n"
        f"▫️ Название: {part['name']}\n"
        f"▫️ Описание: {part['description'] or 'нет'}\n"
        f"▫️ Количество: {part['quantity']} шт.\n"
        f"▫️ Статус: {'✅ В наличии' if part['available'] else '❌ Нет в наличии'}"
    )

    keyboard = [
        [
            InlineKeyboardButton("🔄 Статус", callback_data="change_status"),
            InlineKeyboardButton("🔢 Количество", callback_data="change_quantity")
        ],
        [InlineKeyboardButton("✅ Сохранить", callback_data="save_changes")]
    ]

    await message.edit_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    return EDITING_MENU

async def handle_editing_menu(update: Update, context) -> int:
    query = update.callback_query
    await query.answer()

    if query.data == "change_status":
        keyboard = [
            [
                InlineKeyboardButton("✅ В наличии", callback_data="set_available_1"),
                InlineKeyboardButton("❌ Нет в наличии", callback_data="set_available_0")
            ],
            [InlineKeyboardButton("↩️ Назад", callback_data="back")]
        ]
        await query.edit_message_text("Выберите новый статус:", reply_markup=InlineKeyboardMarkup(keyboard))
        return CHANGE_STATUS

    elif query.data == "change_quantity":
        keyboard = [
            [
                InlineKeyboardButton("➕1", callback_data="add_1"),
                InlineKeyboardButton("➖1", callback_data="remove_1")
            ],
            [InlineKeyboardButton("🎯 Установить 10", callback_data="set_10")],
            [InlineKeyboardButton("↩️ Назад", callback_data="back")]
        ]
        await query.edit_message_text(
            f"Текущее количество: {context.user_data['editing_part']['quantity']}\nВыберите действие:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return CHANGE_QUANTITY

    elif query.data == "save_changes":
        return await save_changes(update, context)

    elif query.data == "back":
        return await show_editing_menu(query.message, context)

async def handle_status_change(update: Update, context) -> int:
    query = update.callback_query
    await query.answer()

    if query.data.startswith("set_available_"):
        new_status = int(query.data.split("_")[2])
        context.user_data['editing_part']['available'] = new_status
        await query.answer("Статус обновлен!")

    return await show_editing_menu(query.message, context)

async def handle_quantity_change(update: Update, context) -> int:
    query = update.callback_query
    await query.answer()
    current = context.user_data['editing_part']['quantity']

    # Обработка изменения количества
    if query.data == "add_1":
        new_qty = current + 1
    elif query.data == "remove_1":
        new_qty = max(0, current - 1)
    elif query.data == "set_10":
        new_qty = 10
    else:
        return await show_editing_menu(query.message, context)

    # Обновляем значение в памяти
    context.user_data['editing_part']['quantity'] = new_qty

    # Обновляем текущее сообщение вместо возврата в меню
    keyboard = [
        [
            InlineKeyboardButton("➕1", callback_data="add_1"),
            InlineKeyboardButton("➖1", callback_data="remove_1")
        ],
        [InlineKeyboardButton("🎯 Установить 10", callback_data="set_10")],
        [InlineKeyboardButton("↩️ Назад", callback_data="back")]
    ]

    await query.edit_message_text(
        f"Текущее количество: {new_qty}\nВыберите действие:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

    # Остаёмся в том же состоянии
    return CHANGE_QUANTITY

async def save_changes(update: Update, context) -> int:
    query = update.callback_query
    await query.answer()

    part_data = context.user_data['editing_part']
    original_data = context.user_data['original_data']
    changes = []

    conn = sqlite3.connect(DB_FILE)
    try:
        cursor = conn.cursor()

        # Проверяем изменения статуса
        if part_data['available'] != original_data['available']:
            cursor.execute(
                "UPDATE parts SET available = ? WHERE id = ?",
                (part_data['available'], part_data['id'])
            )
            changes.append("статус")

        # Проверяем изменения количества
        if part_data['quantity'] != original_data['quantity']:
            cursor.execute(
                "UPDATE parts SET quantity = ? WHERE id = ?",
                (part_data['quantity'], part_data['id'])
            )
            changes.append("количество")

        conn.commit()

        if changes:
            # Добавьте вашу реализацию log_action
            await query.message.reply_text("✅ Изменения успешно сохранены!")
        else:
            await query.message.reply_text("ℹ️ Нет изменений для сохранения")

    except Exception as e:
        await query.message.reply_text(f"🚫 Ошибка сохранения: {str(e)}")
    finally:
        conn.close()

    return ConversationHandler.END
# Новый пункт: вопрос в поддержку

common_questions = [
    "📜 Правила использования",
    "🚴‍♂️ Аренда",
    "👤 Личный кабинет",
    "🔋 Аккумулятор",
    "💳 Цены",
    "📞 Контакты",
    "🏠 Адрес",
    "🛠️ Поломка",
    "❓ Другое"
]

# Создаем клавиатуру с вопросами
def get_support_keyboard():
    keyboard = [
        common_questions[:2],  # Первые два вопроса
        common_questions[2:4],  # Следующие два вопроса
        common_questions[4:6],  # Следующие два вопроса
        common_questions[6:8],  # Следующие два вопроса
        [common_questions[8]]  # Последний вопрос ("❓ Другое")
    ]
    return ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)


async def ask_support(update: Update, context) -> int:
    # Показываем клавиатуру с вопросами
    reply_markup = get_support_keyboard()
    await update.message.reply_text(
        "Выберите интересующий вас вопрос или нажмите 'Другое':",
        reply_markup=reply_markup
    )
    return 1  # Переход к следующему состоянию

async def save_question(update: Update, context) -> int:
    user_id = update.message.from_user.id
    username = update.message.from_user.username
    question = update.message.text

    if question == "❓ Другое":
        await update.message.reply_text(
            "✍️ Пожалуйста, напишите ваш вопрос для поддержки:",
            reply_markup=ReplyKeyboardRemove()
        )
        return 1

    faq_responses = {
        "📜 Правила использования": (
            "📜 *Правила использования:*\n\n"
            "1. 🚴‍♂️ Велосипед должен быть возвращен в исправном состоянии.\n"
            "2. ⚠️ В случае поломки свяжитесь с поддержкой.\n"
            "3. 🛠️ Запрещается использовать велосипед в неблагоприятных погодных условиях."
        ),
        "🚴‍♂️ Аренда": (
            "🚴‍♂️ *Аренда:*\n\n"
            "1. 📅 Минимальный срок аренды — *2 недели*.\n"
            "2. 💰 Стоимость аренды за 2 недели — *6500 рублей*, за 1 месяц — *12600 рублей*. Залог отсутствует.\n"
            "3. 📝 Для аренды необходимо подтвердить личность. Это можно сделать:\n"
            "   - В личном кабинете.\n"
            "   - Лично по адресу: *Москва,  ул. Салтыковская, д. 53*."
        ),
        "👤 Личный кабинет": (
            "👤 *Личный кабинет:*\n\n"
            "При входе в личный кабинет вы увидите:\n"
            "1. ✅ Список ваших активных аренд.\n"
            "2. 🛠️ Возможность подать заявку на ремонт."
        ),
        "🔋 Аккумулятор": (
            "🔋 *Аккумулятор:*\n\n"
            "1. ⚡ Заряжайте аккумулятор только оригинальным зарядным устройством.\n"
            "2. 🕒 Время зарядки: *4-6 часов*.\n"
            "3. ⚠️ *ВАЖНО!* Хранение и зарядка аккумулятора разрешена **ТОЛЬКО** в специально отведенных и оборудованных для этого местах. **Зарядка и хранение дома категорически запрещены!**\n"
            "4. ❄️ Не оставляйте аккумулятор на морозе."
        ),
        "💳 Цены": (
            "💳 *Цены:*\n\n"
            "1. 💰 Стоимость аренды на 2 недели — *6500 рублей*, на 1 месяц — *12600 рублей*.\n"
            "2. 🛠️ Дополнительные услуги (ремонт, замена аккумулятора) оплачиваются отдельно."
        ),
        "📞 Контакты": (
            "📞 *Контакты:*\n\n"
            "1. 👤 Поддержка в Telegram: @BFbike\n"
            "2. 🏠 Адрес: *Москва,  ул. Салтыковская, д. 53*."
        ),
        "🏠 Адрес": (
            "🏠 *Адрес:*\n\n"
            "Наш офис и пункт выдачи велосипедов находится по адресу:\n"
            "*Москва, ул.  ул. Салтыковская, д. 53*."
        ),
        "🛠️ Поломка": (
            "🛠️ *Поломка:*\n\n"
            "1. ⚠️ Если велосипед сломался, свяжитесь с поддержкой.\n"
            "2. 🔧 Мы организуем ремонт или замену велосипеда.\n"
            "3. 💸 Стоимость ремонта зависит от характера поломки."
        )
    }

    if question in faq_responses:
        await update.message.reply_text(
            faq_responses[question],
            parse_mode="Markdown",
            reply_markup=get_main_menu(user_id)
        )
        await update.message.reply_sticker("CAACAgIAAxkBAAELJLpnafJf41vdO_aBH9vqRqObj_qseAACdx4AAhZXMUoZXzrQO2igmzYE")
        return ConversationHandler.END

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO questions (user_id, username, question) VALUES (?, ?, ?)", (user_id, username, question))
        conn.commit()
        logger.info("Вопрос успешно сохранен в базе данных.")
        await update.message.reply_text(
            "✅ Ваш вопрос отправлен. Администратор ответит вам в ближайшее время.",
            parse_mode="Markdown"
        )
        notification_message = f"📩 Новый вопрос от пользователя @{username}:\n{question}"
        for admin_id in ADMIN_IDS:
            await context.bot.send_message(admin_id, notification_message, parse_mode="Markdown")
            add_notification(notification_message)
        await update.message.reply_sticker("CAACAgIAAxkBAAELJLpnafJf41vdO_aBH9vqRqObj_qseAACdx4AAhZXMUoZXzrQO2igmzYE")
    except Exception as e:
        logger.error(f"Ошибка при сохранении вопроса: {e}")
        await update.message.reply_text(
            "⚠️ Произошла ошибка при сохранении вашего вопроса. Пожалуйста, попробуйте еще раз.",
            parse_mode="Markdown"
        )
    finally:
        conn.close()

    await update.message.reply_text(
        "Выберите действие из меню ниже:",
        reply_markup=get_main_menu(user_id)
    )
    return ConversationHandler.END

async def view_questions(update: Update, context) -> None:
    if not is_admin(update.message.from_user.id):
        await update.message.reply_text("У вас нет доступа к этому разделу.")
        return

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT id, username, question FROM questions")
    questions = cursor.fetchall()
    conn.close()

    if not questions:
        await update.message.reply_text("Нет вопросов от пользователей.")
        return

    for question_id, username, question in questions:
        keyboard = [[InlineKeyboardButton("Ответить", callback_data=f"answer_{question_id}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(f"❓ Вопрос от @{username}:\n{question}", reply_markup=reply_markup)

async def answer_question(update: Update, context) -> int:
    query = update.callback_query
    await query.answer()
    question_id = int(query.data.split("_")[1])
    context.user_data['question_id'] = question_id

    await query.message.reply_text("Введите ответ на вопрос:")
    return 1

async def send_answer(update: Update, context) -> int:
    question_id = context.user_data['question_id']
    answer = update.message.text

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT user_id FROM questions WHERE id=?", (question_id,))
    user_id = cursor.fetchone()[0]

    cursor.execute("DELETE FROM questions WHERE id=?", (question_id,))
    conn.commit()
    conn.close()

    await context.bot.send_message(chat_id=user_id, text=f"Ответ на ваш вопрос:\n{answer}")
    await update.message.reply_text("Ответ отправлен, вопрос удален.")
    return ConversationHandler.END

async def finish_attendance(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Шаг 1 (Конец дня): Просит прислать геолокацию для отметки о завершении работы."""
    user_id = update.message.from_user.id
    context.user_data['attendance_action'] = 'end'
    
    await update.message.reply_text(
        "Чтобы завершить рабочий день, пожалуйста, отправьте вашу геопозицию.",
        reply_markup=ReplyKeyboardMarkup(
            [[KeyboardButton("📍 Отправить геопозицию", request_location=True)]],
            resize_keyboard=True, one_time_keyboard=True
        )
    )

async def receive_location(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Шаг 2 (Универсальный): Принимает геолокацию и, в зависимости от действия,
    сохраняет отметку о начале или конце рабочего дня.
    """
    user_id = update.message.from_user.id
    location = update.message.location
    action = context.user_data.pop('attendance_action', None) # Получаем и удаляем флаг действия

    if not action:
        return # Если геолокация пришла случайно, ничего не делаем

    status_text = 'start of work' if action == 'start' else 'end of work'
    
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            await conn.execute(
                "INSERT INTO attendance (user_id, timestamp, status, latitude, longitude) VALUES (?, ?, ?, ?, ?)",
                (user_id, datetime.now().strftime('%Y-%m-%d %H:%M:%S'), status_text, location.latitude, location.longitude)
            )
            await conn.commit()

        if action == 'start':
            await update.message.reply_text(
                "✅ Отлично! Ваш рабочий день начат. Удачной смены!",
                reply_markup=get_main_menu(user_id)
            )
        else:
            await update.message.reply_text(
                "✅ Рабочий день завершен. Спасибо за работу!",
                reply_markup=get_main_menu(user_id)
            )

    except Exception as e:
        logger.error(f"Ошибка при сохранении геолокации для {user_id}: {e}", exc_info=True)
        await update.message.reply_text("❌ Произошла ошибка при сохранении данных.", reply_markup=get_main_menu(user_id))

async def status(update: Update, context) -> None:
    user_id = update.message.from_user.id
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем статус рабочего дня
    cursor.execute("SELECT status, timestamp FROM attendance WHERE user_id=?", (user_id,))
    attendance_records = cursor.fetchall()

    # Получаем активные бронирования
    cursor.execute("SELECT booking_date, end_date, status FROM bookings WHERE user_id=?", (user_id,))
    bookings = cursor.fetchall()

    conn.close()

    # Формируем статус рабочего дня
    attendance_status = []
    for record in attendance_records:
        status, timestamp = record
        attendance_status.append(f"Статус: {status}, Время: {timestamp}")

    # Формируем статус бронирований
    booking_status = []
    for booking in bookings:
        booking_date, end_date, status = booking
        booking_status.append(f"Дата бронирования: {booking_date}, Дата окончания: {end_date}, Статус: {status}")

    # Собираем сообщение
    status_message = "📊 Ваш текущий статус:\n\n"

    if attendance_status:
        status_message += "🕒 Отметки о посещаемости:\n" + "\n".join(attendance_status) + "\n\n"
    else:
        status_message += "🚫 У вас нет отметок о посещаемости.\n\n"

    if booking_status:
        status_message += "📅 Ваши активные бронирования:\n" + "\n".join(booking_status)
    else:
        status_message += "🚫 У вас нет активных бронирований."

    await update.message.reply_text(status_message)

############# ПРОДЛЕНИЕ АРЕНДЫ #############
############# ПРОДЛЕНИЕ АРЕНДЫ #############
############# ПРОДЛЕНИЕ АРЕНДЫ #############

# НАЙДИТЕ ФУНКЦИЮ request_extension И ЗАМЕНИТЕ ЕЕ НА ЭТУ ВЕРСИЮ

# main.py

# main.py

async def request_extension(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    Принимает ТОЧНЫЙ booking_id от нажатой кнопки и предлагает варианты продления
    именно для этого товара, а не для случайного.
    """
    query = update.callback_query
    await query.answer()

    try:
        # --- ГЛАВНОЕ ИЗМЕНЕНИЕ: Получаем ID брони из callback_data ---
        # Формат callback_data: auto_prolong_7_{booking_id}
        # Нам не важны первые три части, нужен только ID в конце.
        booking_id = int(query.data.split('_')[-1])
    except (ValueError, IndexError):
        await query.message.edit_text("❌ Ошибка: не удалось определить, какую аренду вы хотите продлить.")
        return

    # Удаляем предыдущее сообщение (Личный кабинет)
    await query.message.delete()

    # --- Логика создания кнопок остается прежней, но теперь она использует правильный booking_id ---
    keyboard = [
        [InlineKeyboardButton("На 7 дней", callback_data=f"accept_extension_7_{booking_id}")],
        [InlineKeyboardButton("На 14 дней", callback_data=f"accept_extension_14_{booking_id}")],
        [InlineKeyboardButton("На 30 дней", callback_data=f"accept_extension_30_{booking_id}")],
        [InlineKeyboardButton("❌ Отмена", callback_data="cancel_prolong")]
    ]

    await context.bot.send_message(
        chat_id=query.from_user.id,
        text="📅 Выберите, на сколько дней вы хотите продлить аренду:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
# ДОБАВЬТЕ ЭТИ ДВЕ НОВЫЕ ФУНКЦИИ В ВАШ КОД

# ТВОЯ НЕПРАВИЛЬНАЯ ВЕРСИЯ
# ИСПРАВЛЕННАЯ ВЕРСИЯ
async def start_user_custom_extension(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 1 (для клиента): Начинает диалог кастомного продления.
    Удаляет сообщение с кнопками и отправляет новый запрос на ввод текста.
    """
    query = update.callback_query
    await query.answer()

    # Сохраняем ID брони из callback_data
    booking_id = int(query.data.split("_")[-1])
    context.user_data['user_extending_booking_id'] = booking_id

    # <<< НАЧАЛО ИСПРАВЛЕНИЯ >>>
    # Вместо редактирования старого сообщения, мы его удаляем
    try:
        await query.message.delete()
    except Exception as e:
        # Логируем, если не удалось удалить (например, сообщение слишком старое)
        # но не прерываем выполнение
        logger.warning(f"Не удалось удалить сообщение при запросе кастомного продления: {e}")

    # И отправляем новое, чистое сообщение с запросом
    await context.bot.send_message(
        chat_id=query.from_user.id,
        text="Введите желаемое количество дней для продления (например: 5 или 20):"
    )
    # <<< КОНЕЦ ИСПРАВЛЕНИЯ >>>

    # Переходим в состояние ожидания текстового ввода от пользователя
    return USER_AWAIT_CUSTOM_DAYS

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ

async def process_user_custom_extension(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (для клиента): Принимает дни и отправляет заявку администратору с кнопкой."""
    try:
        days = int(update.message.text.strip())
        if days <= 0:
            raise ValueError
    except ValueError:
        await update.message.reply_text("Пожалуйста, введите корректное число дней.")
        return USER_AWAIT_CUSTOM_DAYS

    booking_id = context.user_data.get('user_extending_booking_id')
    user = update.message.from_user
    user_id = user.id

    # Получаем информацию для уведомления
    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        user_name_formatted = await get_user_info_for_notification(user_id, conn)
        bike_cursor = await conn.execute("SELECT name FROM bikes WHERE id = (SELECT bike_id FROM bookings WHERE id=?)", (booking_id,))
        bike_name_row = await bike_cursor.fetchone()
        bike_name = bike_name_row['name'] if bike_name_row else "Неизвестный велосипед"

    admin_notification = (
        f"🔔 Запрос на индивидуальное продление!\n\n"
        f"👤 Пользователь: {user_name_formatted}\n"
        f"🚲 Велосипед: {bike_name} (бронь #{booking_id})\n"
        f"⏳ Желаемый срок: {days} дней\n\n"
        "Нажмите кнопку ниже, чтобы установить цену и выставить счет."
    )

    # Кнопка передает в callback_data и ID брони, и количество дней
    keyboard = [[
        InlineKeyboardButton("✍️ Обработать продление", callback_data=f"extend_custom_start_{booking_id}_{days}")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    for admin_id in ADMIN_IDS:
        await context.bot.send_message(admin_id, admin_notification, reply_markup=reply_markup)

    await update.message.reply_text(
        "✅ Ваш запрос отправлен администратору. Он свяжется с вами для согласования стоимости. Спасибо!"
    )
    context.user_data.clear()
    return ConversationHandler.END

async def handle_custom_extension_start(update: Update, context: CallbackContext) -> int:
    """Шаг 1 (для админа): Начинает диалог, запрашивая цену."""
    query = update.callback_query
    await query.answer()

    # Разбираем callback_data: extend_custom_start_{booking_id}_{days}
    parts = query.data.split('_')
    booking_id = int(parts[3])
    days_to_extend = int(parts[4])

    context.user_data['extending_booking_id'] = booking_id
    context.user_data['custom_extension_days'] = days_to_extend

    await query.edit_message_text(
        f"Запрос на продление на *{days_to_extend} дней*.\n"
        "Введите ОБЩУЮ стоимость для этого срока (например, 5000):",
        parse_mode="Markdown"
    )
    return AWAIT_CUSTOM_PRICE # Переходим к ожиданию цены


# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ accept_extension НА ЭТУ:
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ accept_extension НА ЭТУ:

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ accept_extension НА ЭТУ:
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ accept_extension НА ЭТУ

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# ### НОВАЯ, ОБНОВЛЕННАЯ ФУНКЦИЯ ###
async def accept_extension(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Шаг 2 (Продление): Принимает выбор срока, получает индивидуальную цену из БД и выставляет счет.
    ИСПРАВЛЕНО: Удаляет старое сообщение перед отправкой нового для надежности.
    """
    query = update.callback_query
    await query.answer()
    
    # Удаляем сообщение с кнопками выбора срока, чтобы избежать путаницы
    await query.message.delete()

    # Обработка кнопки отмены
    if query.data == "cancel_prolong":
        await context.bot.send_message(chat_id=query.from_user.id, text="Продление отменено.")
        return

    # Отправляем новое сообщение о подготовке счета
    status_message = await context.bot.send_message(chat_id=query.from_user.id, text="⏳ Готовлю счет на продление аренды...")

    try:
        # Разбираем callback_data: accept_extension_{days}_{booking_id}
        parts = query.data.split('_')
        days_to_extend = int(parts[2])
        booking_id = int(parts[3])
        user_id = query.from_user.id
        
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            price_column_name = f"rent_price_{days_to_extend}d"
            
            cursor = await conn.execute(
                f"""SELECT u.phone_number, b.name as bike_name, b.{price_column_name} as price
                   FROM bookings bo
                   JOIN users u ON bo.user_id = u.id
                   JOIN bikes b ON bo.bike_id = b.id
                   WHERE bo.id=?
                """,
                (booking_id,)
            )
            data = await cursor.fetchone()

        if not data:
            raise ValueError("Не найдена активная аренда для продления.")
        if not data['phone_number']:
            raise ValueError("Не найден ваш номер телефона для чека.")

        bike_name = data['bike_name']
        price = data['price']
        
        if price is None or price <= 0:
            raise ValueError(f"Для велосипеда '{bike_name}' не установлен тариф на {days_to_extend} дней.")

        # --- Дальнейший код для создания платежа остается без изменений ---
        description = f"Продление аренды '{bike_name}' на {days_to_extend} дней"
        payload = f"prolong_{booking_id}_{days_to_extend}"
        
        metadata = {'internal_payload': payload, 'user_id': user_id}
        items_for_receipt = [{"description": description, "quantity": "1.00", "amount": { "value": f"{float(price):.2f}", "currency": "RUB" }, "vat_code": "1", "payment_subject": "service"}]
        
        payment_info = await create_yookassa_payment(
            amount=price, 
            description=description, 
            metadata=metadata, 
            items=items_for_receipt, 
            customer_info={"phone": data['phone_number']}, 
            payment_method='sbp'
        )
        
        if not payment_info:
            raise ValueError("Не удалось создать ссылку на оплату.")

        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']
        
        keyboard = [[InlineKeyboardButton("💳 Оплатить продление", url=payment_url)]]
        # Редактируем сообщение, которое мы только что создали ("Готовлю счет...")
        animated_message = await status_message.edit_text(
            f"Для продления аренды на {days_to_extend} дней, пожалуйста, оплатите {final_amount:.2f} ₽.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        if 'pending_payments' not in context.bot_data: 
            context.bot_data['pending_payments'] = {}
            
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {
            'user_id': user_id, 
            'start_time': datetime.now(), 
            'payload': payload, 
            'amount': final_amount, 
            'animated_message_id': animated_message.message_id, 
            'url': payment_url, 
            'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 
            'stop_animation_event': stop_animation_event
        }
        
        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(
            callback=check_payment_status, 
            interval=15, 
            first=10, 
            name=f"payment_{payment_id}", 
            data={'yookassa_id': payment_id}
        )

    except Exception as e:
        logger.error(f"Ошибка в accept_extension: {e}", exc_info=True)
        # Редактируем наше сообщение "Готовлю счет...", чтобы показать ошибку
        await status_message.edit_text(f"❌ Произошла ошибка: {e}")

import locale
from datetime import datetime

async def show_receipts(update: Update, context) -> None:
    user_id = update.message.from_user.id  # Получаем ID пользователя для отправки чеков

    month_names = {
        1: "ЯНВАРЬ",
        2: "ФЕВРАЛЬ",
        3: "МАРТ",
        4: "АПРЕЛЬ",
        5: "МАЙ",
        6: "ИЮНЬ",
        7: "ИЮЛЬ",
        8: "АВГУСТ",
        9: "СЕНТЯБРЬ",
        10: "ОКТЯБРЬ",
        11: "НОЯБРЬ",
        12: "ДЕКАБРЬ"
    }

    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()

        # Получаем фотографии из заявок на продление, которые были приняты
        cursor.execute("""
            SELECT er.photo, bk.id, u.first_name, u.last_name, u.username, er.created_at
            FROM extension_requests er
            JOIN bookings bk ON er.booking_id = bk.id
            JOIN users u ON bk.user_id = u.id
            WHERE er.status='accepted'
        """)
        accepted_photos = cursor.fetchall()

    # Проверяем, есть ли принятые заявки
    if not accepted_photos:
        await update.message.reply_text("🚫 У вас нет принятых чеков на продление.")
        return

    # Информируем пользователя о чеках
    await update.message.reply_text("📸 Вот ваши принятые чеки:")

    # Отправляем все принятые фотографии
    for photo, booking_id, first_name, last_name, username, created_at in accepted_photos:
        month = datetime.strptime(created_at, "%Y-%m-%d %H:%M:%S").month  # Получаем номер месяца
        month_name = month_names[month]  # Получаем название месяца

        formatted_date = datetime.strptime(created_at, "%Y-%m-%d %H:%M:%S").strftime('%d.%m.%Y')  # Форматируем дату

        # Используем смайлик для выделения
        caption = (f"{month_name}\n"  # Месяц
                   f"🚨 ПРОДЛЕНИЕ АРЕНДЫ 🚨\n"  # Заголовок о продлении с смайликами
                   f"{last_name} {first_name} @{username}\n"  # Фамилия, имя и username
                   f"Дата: {formatted_date}")  # Дата

        await context.bot.send_photo(chat_id=user_id, photo=photo, caption=caption)

from collections import defaultdict

# Словарь команд с их синонимами
from collections import defaultdict

# Словарь команд с множеством синонимов и краткими формами
commands = defaultdict(list, {
    "чеки": ["чеки", "чек", "чекы", "чеков", "чековый"],
    "пользователи": ["пользователи", "пользователь", "польз", "пользователей", "пользователи"],
    "велосипеды": ["велосипеды", "вел", "велики", "велосипеды", "великие"],
    "заявки на продление": ["заявки на продление", "продление", "заявка на продление", "заявление на продление"],
    "регистрация": ["регистрация", "зарегистрироваться", "регистратор"],
    "личный кабинет": ["личный кабинет", "кабинет", "личный"],
    "управление велосипедом": ["управление велосипедом", "управление велом", "велуправление", "управление велосипедом"],
    "отметиться на работе": ["отметиться на работе", "отметиться", "прийти на работу"],
    "добавить запчасть": ["добавить запчасть", "добавь запчасть", "добавить деталь", "вставить запчасть"],
    "редактировать запчасти": ["редактировать запчасти", "редактировать", "изменить запчасти"],
    "список запчастей": ["список запчастей", "запчасти", "запчасть", "перечень запчастей"],
    "вернуться в главное меню": ["вернуться в главное меню", "вернуться", "назад"],
    "поддержка": ["поддержка", "служба поддержки", "помощь"],
    "вопросы от пользователей": ["вопросы от пользователей", "вопросы", "вопрос", "вопросы пользователей"],
    "статус бронирования": ["статус бронирования", "статус", "забронировать", "бронирование"],
    "ожидающие бронь": ["ожидающие бронь", "ожидающие", "ожидания"],
    "история отметок": ["история отметок", "история", "отметки"],
    "зарегистрированные пользователи": ["зарегистрированные пользователи", "зарегистрированные", "учет"],
    "верификация пользователей": ["верификация пользователей", "верификация", "подтверждение", "вер"],
    "история велосипеда": ["история велосипеда", "история велика", "вел история"],
    "завершить рабочий день": ["завершить рабочий день", "завершить", "закончить день", "кончить рабочий день"],
    "управление арендами": ["управление арендами", "аренда", "управление"],
    "продлить аренду": ["продлить аренду", "продление аренды", "продлить"],
    "показать уведомления": ["показать уведомления", "уведомления", "показать извещения", "уведы"],
})

# Корреляционная функция для выполнения команд
def execute_command(user_input):
    for command, synonyms in commands.items():
        if user_input in synonyms:
            return command  # Вернуть соответствующую команду
    return None  # Если команда не найдена

import sqlite3
from telegram import Update
from telegram.ext import ContextTypes



def generate_next_three_days():
    today = datetime.now()
    return [(today + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(3)]

async def pre_checkout_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.pre_checkout_query
    await query.answer(ok=True)


import logging
import sqlite3
from datetime import datetime, timedelta
from telegram import Update
from telegram.ext import ContextTypes

#

VIRTUAL_BIKE_ID = 999





async def handle_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Обрабатывает РЕАЛЬНЫЙ успешный платеж от ЮKassa.
    """
    payment = update.message.successful_payment
    user_id = update.message.from_user.id
    payload = payment.invoice_payload
    amount_rub = payment.total_amount // 100

    await process_successful_payment(update, context, user_id, payload, amount_rub)
from datetime import datetime

import sqlite3
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext

async def handle_admin_view_queue(update: Update, context: CallbackContext, page=None) -> None:
    per_page = 10  # Количество записей на страницу

    # Инициализация переменных query и chat_id
    query = None
    chat_id = None

    # Проверяем наличие callback_query
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        chat_id = query.message.chat_id
    else:
        chat_id = update.message.chat_id

    # Определяем параметры страницы
    if page is None:
        if query and query.data.startswith('wowwow_page_'):
            page = int(query.data.split('_')[-1])
        else:
            page = 1
    else:
        # Убедимся, что страница корректна (проверка будет позже)
        pass

    conn = None
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Получаем общее количество записей
        cursor.execute("SELECT COUNT(*) FROM queue")
        total = cursor.fetchone()[0]
        total_pages = (total + per_page - 1) // per_page
        page = max(1, min(page, total_pages))

        # Получаем записи для текущей страницы
        cursor.execute("""
            SELECT q.id, q.user_id, q.created_at, q.status, u.first_name, u.last_name, u.username
            FROM queue q
            JOIN users u ON q.user_id = u.id
            ORDER BY q.created_at
            LIMIT ? OFFSET ?
        """, (per_page, (page - 1) * per_page))
        queue = cursor.fetchall()

        if queue:
            queue_text = f"👥 Очередь (администратор) - Страница {page}/{total_pages}:\n"
            keyboard = []
            for idx, row in enumerate(queue, start=1):
                queue_id, user_id, created_at, status, first_name, last_name, username = row
                # Форматирование времени
                try:
                    created_at_dt = datetime.strptime(created_at, "%Y-%m-%d %H:%M:%S")
                except (ValueError, TypeError):
                    created_at_dt = datetime.now()
                time_in_queue = datetime.now() - created_at_dt
                hours, remainder = divmod(time_in_queue.seconds, 3600)
                minutes, _ = divmod(remainder, 60)
                time_str = f"{hours} ч {minutes} мин" if hours > 0 else f"{minutes} мин"
                user_info = f"{last_name} {first_name}"
                if username:
                    user_info += f" (@{username})"
                user_info += f" (в очереди {time_str})"
                # Формирование кнопки удаления
                button_text = f"🗑️ Удалить {last_name} {first_name}"
                if status == 'first_user':
                    queue_text += f"🥇 {idx}. Пользователь {user_info}\n"
                    button_text += f" (🥇 место {idx})"
                else:
                    queue_text += f"{idx}. Пользователь {user_info}\n"
                    button_text += f" (место {idx})"
                callback_data = f"wowwow_remove_{queue_id}_{page}"
                keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])

            # Добавляем кнопки пагинации
            pagination_buttons = []
            if page > 1:
                pagination_buttons.append(
                    InlineKeyboardButton("⬅️ Назад", callback_data=f"wowwow_page_{page - 1}")
                )
            if page < total_pages:
                pagination_buttons.append(
                    InlineKeyboardButton("Вперед ➡️", callback_data=f"wowwow_page_{page + 1}")
                )
            if pagination_buttons:
                keyboard.append(pagination_buttons)

            reply_markup = InlineKeyboardMarkup(keyboard)
            if query:
                await query.edit_message_text(queue_text, reply_markup=reply_markup)
            else:
                await context.bot.send_message(chat_id, queue_text, reply_markup=reply_markup)
        else:
            message = "👥 Очередь пуста."
            if query:
                await query.edit_message_text(message)
            else:
                await context.bot.send_message(chat_id, message)

    except sqlite3.Error as e:
        error_message = "🚫 Ошибка при работе с базой данных."
        if query:
            await query.edit_message_text(error_message)
        else:
            await context.bot.send_message(chat_id, error_message)
        print(f"Database error: {e}")
    finally:
        if conn:
            conn.close()

async def handle_admin_remove_user(update: Update, context: CallbackContext) -> None:
    # Проверяем наличие callback_query
    if not update.callback_query:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="🚫 Эта команда доступна только через кнопки."
        )
        return

    query = update.callback_query
    await query.answer()

    conn = None  # Инициализируем переменную conn
    try:
        # Извлекаем данные из callback_query
        data = query.data.split('_')
        if len(data) < 3:
            raise ValueError("Неверный формат callback_data")

        queue_id = int(data[2])
        current_page = int(data[3]) if len(data) > 3 else 1

        # Работа с базой данных
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Удаление пользователя
        cursor.execute("SELECT user_id, status FROM queue WHERE id=?", (queue_id,))
        queue_info = cursor.fetchone()
        if not queue_info:
            await query.edit_message_text("🚫 Пользователь не найден.")
            return

        user_id, status = queue_info
        cursor.execute("DELETE FROM queue WHERE id=?", (queue_id,))

        # Обновление статусов оставшихся пользователей
        cursor.execute("SELECT id, user_id, status FROM queue ORDER BY created_at ASC")
        queue = cursor.fetchall()
        if queue:
            first_user_id = queue[0][1]
            first_user_status = queue[0][2]
            if first_user_status == 'pending':
                cursor.execute("UPDATE queue SET status='first_user' WHERE user_id=?", (first_user_id,))

        conn.commit()

        # Обновление интерфейса
        await handle_admin_view_queue(update, context, page=current_page)

    except ValueError as ve:
        await query.edit_message_text(f"🚫 Ошибка формата данных: {str(ve)}")
        print(f"ValueError: {ve}")
    except sqlite3.Error as dbe:
        await query.edit_message_text("🚫 Ошибка базы данных.")
        print(f"Database error: {dbe}")
    except Exception as e:
        await query.edit_message_text("🚫 Непредвиденная ошибка.")
        print(f"Unexpected error: {e}")
    finally:
        if conn:
            conn.close()

import sqlite3
from datetime import datetime, timedelta
import pytz
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler, CommandHandler, MessageHandler, CallbackQueryHandler, filters

# Общие проблемы
common_problems = [
    "Спустило колесо.",
    "Прокручивает колесо.",
    "Проблема с рулем.",
    "Проблема с тормозами.",
    "Другое..😔"
]

# Состояния для диалогов
WAITING_FOR_PROBLEM, WAITING_FOR_CUSTOM_PROBLEM = range(1, 3)
WAITING_FOR_TIME, WAITING_FOR_PRICE = range(2)
CHOOSE_WARRANTY_TYPE, ENTER_DELAY_REASON = range(2)  # Новые состояния для гарантии и задержки

# Функция для разбиения текста
def split_text(text, max_length=2000):
    return [text[i:i + max_length] for i in range(0, len(text), max_length)]






# Общие проблемы
common_problems = [
    "Спустило колесо.",
    "Прокручивает колесо.",
    "Проблема с рулем.",
    "Проблема с тормозами.",
    "Другое..😔"
]

# Состояния для диалогов
WAITING_FOR_PROBLEM, WAITING_FOR_CUSTOM_PROBLEM = range(1, 3)
WAITING_FOR_TIME, WAITING_FOR_PRICE = range(2)
CHOOSE_WARRANTY_TYPE, ENTER_DELAY_REASON = range(2)  # Новые состояния для гарантии и задержки

# Функция для разбиения текста
def split_text(text, max_length=2000):
    return [text[i:i + max_length] for i in range(0, len(text), max_length)]

# Обработчик начала диалога




# --- НОВАЯ, ИСПРАВЛЕННАЯ ЛОГИКА ДЛЯ ЗАЯВОК НА РЕМОНТ ---

# Определяем состояния для диалога
WAITING_FOR_PROBLEM, WAITING_FOR_CUSTOM_PROBLEM = range(1, 3)


async def request_repair(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 1: Начинает процесс создания заявки на ремонт.
    """
    user_id = update.message.from_user.id

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            # Проверяем, есть ли у пользователя активные аренды
            cursor = await conn.execute("SELECT id, bike_id FROM bookings WHERE user_id=? AND status='rented' LIMIT 1", (user_id,))
            active_rental = await cursor.fetchone()

        if not active_rental:
            await update.message.reply_text("🚫 У вас нет активных аренд для создания заявки на ремонт.")
            return ConversationHandler.END

        # Сохраняем ID велосипеда для дальнейшего использования
        context.user_data['repair_bike_id'] = active_rental[1]

        keyboard = [
            [InlineKeyboardButton("Проблема с тормозами", callback_data="repair_Тормоза")],
            [InlineKeyboardButton("Спустило/пробило колесо", callback_data="repair_Колесо")],
            [InlineKeyboardButton("Проблемы с рулем/управлением", callback_data="repair_Руль")],
            [InlineKeyboardButton("Другое (описать текстом)", callback_data="repair_Другое")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            "🔧 *Создание заявки на ремонт*\n\n"
            "Пожалуйста, выберите тип проблемы из списка ниже или опишите ее самостоятельно, нажав 'Другое'.",
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        return WAITING_FOR_PROBLEM

    except Exception as e:
        logger.error(f"Ошибка в request_repair: {e}", exc_info=True)
        await update.message.reply_text("🚫 Произошла ошибка. Пожалуйста, попробуйте позже.")
        return ConversationHandler.END


async def handle_problem_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 2: Обрабатывает выбор стандартной проблемы или переход к ручному вводу.
    """
    query = update.callback_query
    await query.answer()
    problem = query.data.split('_', 1)[1]

    if problem == "Другое":
        await query.message.edit_text(
            "✍️ Пожалуйста, подробно опишите проблему с велосипедом:"
        )
        return WAITING_FOR_CUSTOM_PROBLEM
    else:
        # Если выбрана стандартная проблема, сразу вызываем финальную функцию
        await finalize_repair_request(update, context, description=problem)
        return ConversationHandler.END


async def save_custom_problem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 2.1: Принимает текстовое описание проблемы и вызывает финальную функцию.
    """
    description = update.message.text
    await finalize_repair_request(update, context, description=description)
    return ConversationHandler.END


### НОВАЯ ВЕРСИЯ с исправлением дублирования уведомлений ###
async def finalize_repair_request(update: Update, context: ContextTypes.DEFAULT_TYPE, description: str):
    """
    Универсальная функция для сохранения заявки на ремонт,
    логирования и отправки уведомлений без дублей.
    """
    user_id = update.effective_user.id
    bike_id = context.user_data.get('repair_bike_id')
    user_data_copy = context.user_data.copy()

    message_sender = update.effective_message

    try:
        perm_tz = pytz.timezone('Asia/Yekaterinburg')
        current_time_str = datetime.now(perm_tz).strftime("%Y-%m-%d %H:%M:%S")

        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            await conn.execute('BEGIN')

            cursor = await conn.execute(
                "INSERT INTO repair_requests (user_id, bike_id, description, created_at, status) VALUES (?, ?, ?, ?, 'ozhidaet')",
                (user_id, bike_id, description, current_time_str)
            )
            request_id = cursor.lastrowid

            user_info_cursor = await conn.execute("SELECT first_name, last_name, username FROM users WHERE id=?", (user_id,))
            user_info = await user_info_cursor.fetchone()
            user_name_raw = f"{user_info['first_name']} {user_info['last_name'] or ''} (@{user_info['username'] or 'no_username'})" if user_info else f"ID {user_id}"

            bike_info_cursor = await conn.execute("SELECT name FROM bikes WHERE id=?", (bike_id,))
            bike_name = (await bike_info_cursor.fetchone() or ["Неизвестный велосипед"])['name']

            log_details = f"Заявка на ремонт для '{bike_name}'. Проблема: {description}"
            await log_bike_action(conn, bike_id, user_id, "Заявка на ремонт", log_details)

            await conn.commit()

        user_name_escaped = escape_markdown(user_name_raw, version=2)
        bike_name_escaped = escape_markdown(bike_name, version=2)
        description_escaped = escape_markdown(description, version=2)

        notification_message = (
            f"🛠️ *Новая заявка на ремонт \\(ID: {request_id}\\)*\n\n"
            f"👤 *Пользователь:* {user_name_escaped}\n"
            f"🚲 *Велосипед:* {bike_name_escaped}\n"
            f"📝 *Проблема:* {description_escaped}"
        )
        admin_keyboard = [[
            InlineKeyboardButton("✅ Принять в работу", callback_data=f"accept_repair_{request_id}"),
            InlineKeyboardButton("🗑️ Отклонить", callback_data=f"otmena_repair_{request_id}")
        ]]

        # <<< ИСПРАВЛЕНИЕ: Отправка уведомлений без дублей >>>
        all_recipients = set(ADMIN_IDS + MASTER_IDS)

        for recipient_id in all_recipients:
            try:
                await context.bot.send_message(
                    recipient_id,
                    notification_message,
                    parse_mode="MarkdownV2",
                    reply_markup=InlineKeyboardMarkup(admin_keyboard)
                )
            except Exception as e:
                logger.error(f"Не удалось отправить уведомление о ремонте получателю {recipient_id}: {e}")

        add_notification(f"Заявка на ремонт от {user_name_raw}")

        user_reply_text = (
            "✅ *Заявка на ремонт принята!*\n\n"
            "Пожалуйста, оставьте велосипед по адресу: ** ул. Салтыковская, д. 53**.\n\n"
            "Как только вы оставите велосипед, нажмите кнопку ниже, чтобы уведомить мастера."
        )
        user_keyboard = [[InlineKeyboardButton("🚲 Я оставил(а) велосипед на складе", callback_data=f"leave_bike_{request_id}")]]

        if isinstance(update, Update) and update.callback_query:
            await message_sender.edit_text(user_reply_text, reply_markup=InlineKeyboardMarkup(user_keyboard), parse_mode="Markdown")
        else:
            await message_sender.reply_text(user_reply_text, reply_markup=InlineKeyboardMarkup(user_keyboard), parse_mode="Markdown")

        await context.bot.send_sticker(chat_id=user_id, sticker="CAACAgIAAxkBAAELuUBni4NIbVWW023ZB_0uZ4-bcj-fDgAC9T8AAsWoIUriJJxWQR9CtzYE")

    except Exception as e:
        logger.error(f"Ошибка в finalize_repair_request: {e}", exc_info=True)
        await message_sender.reply_text("🚫 Произошла ошибка при создании заявки.")
    finally:
        context.user_data.clear()


async def leave_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Обрабатывает нажатие кнопки "Я оставил(а) велосипед на складе".
    """
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])
    user_id = query.from_user.id

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute("SELECT user_id, left_at FROM repair_requests WHERE id=?", (request_id,))
            result = await cursor.fetchone()

            if result and result['user_id'] == user_id and result['left_at'] is None:
                current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                await conn.execute("UPDATE repair_requests SET left_at=? WHERE id=?", (current_time, request_id))
                await conn.commit()

                left_date = datetime.strptime(current_time, "%Y-%m-%d %H:%M:%S").strftime("%d.%m.%Y")
                await query.edit_message_text(f"✅ Вы отметили, что оставили велосипед на складе {left_date}.")

                # Уведомление администраторам
                cursor = await conn.execute("""
                    SELECT u.first_name, u.last_name, u.username, b.name
                    FROM repair_requests rr
                    JOIN users u ON rr.user_id = u.id
                    JOIN bikes b ON rr.bike_id = b.id
                    WHERE rr.id=?
                """, (request_id,))
                notify_data = await cursor.fetchone()
                user_name = f"{notify_data['first_name']} {notify_data['last_name'] or ''} (@{notify_data['username'] or 'no_username'})"

                notification_message = (
                    f"🚚 *Велосипед доставлен на склад!*\n\n"
                    f"👤 *Пользователь:* {escape_markdown(user_name, 2)}\n"
                    f"🚲 *Велосипед:* {escape_markdown(notify_data['name'], 2)}\n"
                    f"📌 *ID заявки:* `{request_id}`"
                )
                for admin_id in ADMIN_IDS + MASTER_IDS:
                    await context.bot.send_message(admin_id, notification_message, parse_mode="MarkdownV2")

            elif result and result['left_at'] is not None:
                await query.answer("Вы уже отмечали, что оставили велосипед.", show_alert=True)
            else:
                await query.answer("🚫 Вы не можете выполнить это действие.", show_alert=True)

    except Exception as e:
        logger.error(f"Ошибка в leave_bike: {e}", exc_info=True)
        await query.answer("Произошла ошибка.", show_alert=True)

### НОВАЯ ВЕРСИЯ С ИСПРАВЛЕННЫМ ФИЛЬТРОМ ###
async def view_completed_repairs(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Просмотр завершенных ремонтов, ожидающих оплаты."""
    user = update.effective_user
    # Проверка прав доступа
    if not (is_admin(user.id) or user.id in MASTER_IDS):
        await (update.message or update.callback_query.message).reply_text("🚫 У вас нет прав.")
        return

    page = 0
    if update.callback_query and update.callback_query.data.startswith('paginate_completed_'):
        page = int(update.callback_query.data.split('_')[-1])

    # Асинхронно получаем данные из БД
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row

            # <<< ГЛАВНОЕ ИСПРАВЛЕНИЕ ЗДЕСЬ >>>
            # Ищем только те заявки, у которых статус 'completed'
            cursor = await conn.execute("""
                SELECT rr.id, u.first_name, u.last_name, u.username, b.name, rr.description,
                       rr.status, rr.created_at, rr.completed_at, rr.estimated_price, rr.is_warranty, rr.delay_reason
                FROM repair_requests rr
                JOIN users u ON rr.user_id = u.id
                JOIN bikes b ON rr.bike_id = b.id
                WHERE rr.status = 'completed'
                ORDER BY rr.created_at DESC
            """)
            all_requests = await cursor.fetchall()

    except Exception as e:
        logger.error(f"Ошибка получения завершенных ремонтов из БД: {e}", exc_info=True)
        await (update.message or update.callback_query.message).reply_text("🚫 Ошибка при доступе к базе данных.")
        return

    if not all_requests:
        await (update.message or update.callback_query.message).reply_text("🚫 Нет завершенных заявок, ожидающих оплаты.")
        return

    # Отправляем общий заголовок
    await (update.message or update.callback_query.message).reply_text("💳 Заявки, ожидающие оплаты:")

    # Пагинация
    items_per_page = 5
    total_pages = (len(all_requests) + items_per_page - 1) // items_per_page
    start = page * items_per_page
    end = start + items_per_page
    current_requests = all_requests[start:end]

    # Отправляем каждую заявку отдельным сообщением
    for request in current_requests:
        formatted_price = format_rubles(request['estimated_price']) if request['estimated_price'] else "0 рублей (гарантия)"
        completed_date = datetime.strptime(request['completed_at'], "%Y-%m-%d %H:%M:%S").strftime("%d.%m.%Y %H:%M") if request['completed_at'] else "не указана"

        warranty_info = "🛡️ Гарантийный ремонт" if request['is_warranty'] else "💰 Не гарантийный ремонт"
        delay_info = f"\n⚠️ Причина задержки: {request['delay_reason']}" if request['delay_reason'] else ""

        message_text = (
            f"📌 *ID:* {request['id']}\n"
            f"👤 *Пользователь:* {request['first_name']} {request['last_name']} (@{request['username']})\n"
            f"🚲 *Велосипед:* {request['name']}\n"
            f"📅 *Завершено:* {completed_date}\n"
            f"💵 *Сумма:* {formatted_price}\n"
            f"{warranty_info}{delay_info}"
        )

        keyboard = [[InlineKeyboardButton(f"✅ Отметить оплаченной (ID: {request['id']})", callback_data=f"paid_{request['id']}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=message_text,
            parse_mode="Markdown",
            reply_markup=reply_markup
        )

    # Добавляем кнопки пагинации
    if total_pages > 1:
        pagination_buttons = []
        if page > 0:
            pagination_buttons.append(InlineKeyboardButton("⬅️ Назад", callback_data=f"paginate_completed_{page-1}"))
        if page < total_pages - 1:
            pagination_buttons.append(InlineKeyboardButton("Вперед ➡️", callback_data=f"paginate_completed_{page+1}"))

        if pagination_buttons:
            pagination_markup = InlineKeyboardMarkup([pagination_buttons])
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"📃 Страница {page + 1} из {total_pages}",
                reply_markup=pagination_markup
            )

async def view_accepted_repairs(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    if not (is_admin(user.id) or user.id in MASTER_IDS):
        await (update.message or update.callback_query.message).reply_text("🚫 Нет прав.")
        return

    page = 0
    if update.callback_query and update.callback_query.data.startswith('paginate_accepted_'):
        page = int(update.callback_query.data.split('_')[-1])

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("""
        SELECT rr.id, u.first_name, u.last_name, b.name, rr.description,
               rr.status, rr.created_at, rr.estimated_time
        FROM repair_requests rr
        JOIN users u ON rr.user_id = u.id
        JOIN bikes b ON rr.bike_id = b.id
        WHERE rr.status='accepted'
        ORDER BY rr.created_at DESC
    """)
    all_requests = cursor.fetchall()
    conn.close()

    items_per_page = 5
    total_pages = (len(all_requests) + items_per_page - 1) // items_per_page
    start = page * items_per_page
    end = start + items_per_page
    current_requests = all_requests[start:end]

    if not current_requests:
        await (update.message or update.callback_query.message).reply_text("🚫 Нет заявок в работе.")
        return

    message_text = "🛠️ Заявки в работе:\n\n"
    for request in current_requests:
        request_id, first_name, last_name, bike_name, description, status, created_at, estimated_time = request
        message_text += (
            f"📌 ID: {request_id}\n"
            f"👤 Пользователь: {first_name} {last_name}\n"
            f"🚲 Велосипед: {bike_name}\n"
            f"📝 Описание: {description}\n\n"
        )

    keyboard = [
        [InlineKeyboardButton(f"✅ Готово (ID: {req[0]})", callback_data=f"complete_repair_{req[0]}")]
        for req in current_requests
    ]

    pagination_buttons = []
    if page > 0:
        pagination_buttons.append(InlineKeyboardButton("⬅️ Назад", callback_data=f"paginate_accepted_{page-1}"))
    if page < total_pages - 1:
        pagination_buttons.append(InlineKeyboardButton("Вперед ➡️", callback_data=f"paginate_accepted_{page+1}"))
    if pagination_buttons:
        keyboard.append(pagination_buttons)

    reply_markup = InlineKeyboardMarkup(keyboard)

    if update.callback_query:
        await update.callback_query.edit_message_text(message_text, reply_markup=reply_markup)
    else:
        await (update.message or update.callback_query.message).reply_text(message_text, reply_markup=reply_markup)

### НОВАЯ ВЕРСИЯ view_repair_requests - Приборная панель ремонтов ###
### НОВАЯ ВЕРСИЯ view_repair_requests - Приборная панель ремонтов ###
async def view_repair_requests(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    if not (is_admin(user.id) or user.id in MASTER_IDS):
        message = update.message or update.callback_query.message
        await message.reply_text("🚫 Нет прав.")
        return

    message = update.message or update.callback_query.message

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row

            # <<< ИЗМЕНЕНИЕ: Добавили rr.description в запрос >>>
            cursor = await conn.execute("""
                SELECT rr.id, rr.status, u.first_name, u.last_name, b.name as bike_name, rr.description
                FROM repair_requests rr
                JOIN users u ON rr.user_id = u.id
                JOIN bikes b ON rr.bike_id = b.id
                WHERE rr.status != 'oplacheno'
                ORDER BY CASE rr.status
                    WHEN 'ozhidaet' THEN 1
                    WHEN 'accepted' THEN 2
                    WHEN 'completed' THEN 3
                    ELSE 4
                END, rr.created_at DESC
            """)
            all_requests = await cursor.fetchall()

        if not all_requests:
            await message.reply_text("✅ Все заявки обработаны, новых нет.")
            return

        requests_by_status = {
            'ozhidaet': [],
            'accepted': [],
            'completed': []
        }
        for req in all_requests:
            if req['status'] in requests_by_status:
                requests_by_status[req['status']].append(req)

        message_parts = ["*🛠️ Панель управления ремонтами*\n"]
        keyboard = []

        # <<< ИСПРАВЛЕНИЕ: Добавляем описание проблемы в текст >>>
        if requests_by_status['ozhidaet']:
            message_parts.append("\n*Новые заявки (ожидают принятия):*")
            for req in requests_by_status['ozhidaet']:
                message_parts.append(f"• ID {req['id']}: {req['bike_name']} от {req['first_name']} `({req['description']})`")
                keyboard.append([
                    InlineKeyboardButton(f"👀 Посмотреть заявку #{req['id']}", callback_data=f"view_repair_{req['id']}")
                ])

        if requests_by_status['accepted']:
            message_parts.append("\n*В работе:*")
            for req in requests_by_status['accepted']:
                message_parts.append(f"• ID {req['id']}: {req['bike_name']} от {req['first_name']} `({req['description']})`")
                keyboard.append([
                    InlineKeyboardButton(f"✅ Завершить ремонт #{req['id']}", callback_data=f"complete_repair_{req['id']}")
                ])

        if requests_by_status['completed']:
            message_parts.append("\n*Ожидают оплаты:*")
            for req in requests_by_status['completed']:
                message_parts.append(f"• ID {req['id']}: {req['bike_name']} от {req['first_name']} `({req['description']})`")
                keyboard.append([
                    InlineKeyboardButton(f"💰 Отметить оплаченной #{req['id']}", callback_data=f"paid_{req['id']}")
                ])

        final_message = "\n".join(message_parts)
        await message.reply_text(
            final_message,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )

    except Exception as e:
        logger.error(f"Ошибка в view_repair_requests: {e}", exc_info=True)
        await message.reply_text("🚫 Произошла ошибка при загрузке заявок.")

# Новая функция для просмотра деталей одной заявки
async def view_single_repair_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split('_')[2])

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute("""
                SELECT rr.id, u.first_name, u.last_name, u.username, b.name, rr.description,
                       rr.status, rr.created_at, rr.left_at
                FROM repair_requests rr
                JOIN users u ON rr.user_id = u.id
                JOIN bikes b ON rr.bike_id = b.id
                WHERE rr.id=?
            """, (request_id,))
            request = await cursor.fetchone()

        if not request:
            await query.edit_message_text("🚫 Заявка не найдена.")
            return

        created_date = datetime.strptime(request['created_at'], "%Y-%m-%d %H:%M:%S").strftime("%d.%m.%Y") if request['created_at'] else "неизвестно"

        message_text = (
            f"🛠️ *Заявка #{request['id']}*\n\n"
            f"👤 *Пользователь:* {request['first_name']} {request['last_name']} (@{request['username']})\n"
            f"🚲 *Велосипед:* {request['name']}\n"
            f"📝 *Описание:* {request['description']}\n"
            f"📊 *Статус:* {request['status']}\n"
            f"📅 *Дата подачи:* {created_date}"
        )

        keyboard = [[
            InlineKeyboardButton("✅ Принять в работу", callback_data=f"accept_repair_{request['id']}"),
            InlineKeyboardButton("🗑️ Отклонить", callback_data=f"otmena_repair_{request['id']}")
        ]]

        await query.edit_message_text(
            message_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )

    except Exception as e:
        logger.error(f"Ошибка в view_single_repair_request: {e}", exc_info=True)
        await query.edit_message_text("🚫 Ошибка при загрузке заявки.")



async def start_assignment_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ШАГ 0: Развилка. Запускает ветку АРЕНДЫ, ВЫКУПА или КАСТОМНОЙ сделки."""
    query = update.callback_query
    await query.answer()
    context.user_data.clear()

    booking_id = int(query.data.split('_')[1])
    context.user_data['processing_booking_id'] = booking_id
    logging.info(f"--- [ШАГ 0] Вход в start_assignment_flow. Заявка #{booking_id}")

    async with aiosqlite.connect(DB_FILE) as conn:
        cursor = await conn.execute("SELECT bike_id, booking_type FROM bookings WHERE id=?", (booking_id,))
        result = await cursor.fetchone()

    if not result:
        await query.message.edit_text("Ошибка: заявка не найдена.")
        return ConversationHandler.END

    bike_id_from_booking, booking_type = result
    context.user_data['booking_type'] = booking_type

    # Ветка для кастомной сделки
    if bike_id_from_booking == VIRTUAL_BIKE_ID:
        logging.info(f"Заявка #{booking_id} - КАСТОМНАЯ. Тип: {booking_type}.")
        await query.message.edit_text("✍️ Индивидуальная сделка. Введите реальное описание комплекта (например, 'Монстр-Гибрид 12345 + 2 АКБ 30Ah с номерами 312123 и 312312'):")
        return AWAIT_CUSTOM_DESC

    # Ветка для стандартной АРЕНДЫ
    elif booking_type == 'rent':
        logging.info(f"Заявка #{booking_id} на АРЕНДУ. Запрашиваю номер велосипеда.")
        await query.message.edit_text(f"➡️ Заявка на аренду #{booking_id}.\nВведите физический номер велосипеда (например, 123321):")
        return AWAIT_BIKE_NUMBER_RENT

    # Ветка для стандартного ВЫКУПА
    elif booking_type == 'buyout':
        logging.info(f"Заявка #{booking_id} на ВЫКУП. Запрашиваю номер для присвоения.")
        await query.message.edit_text(f"➡️ Заявка на выкуп #{booking_id}.\nВведите номер, который будет присвоен этому велосипеду (например, по ID клиента):")
        return AWAIT_BIKE_NUMBER_BUYOUT

    return ConversationHandler.END

# --- ФУНКЦИИ ДЛЯ ВЕТКИ СТАНДАРТНОЙ АРЕНДЫ ---
# <<< НАЧАЛО НОВОГО БЛОКА КОДА >>>

async def repair_dashboard_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает новое главное меню для управления ремонтами со счетчиками заявок.
    """
    try:
        # Асинхронно получаем количество заявок по каждому статусу
        async with aiosqlite.connect(DB_FILE) as conn:
            # Новые заявки
            new_cursor = await conn.execute("SELECT COUNT(*) FROM repair_requests WHERE status = 'ozhidaet'")
            new_count = (await new_cursor.fetchone())[0]
            # В работе
            accepted_cursor = await conn.execute("SELECT COUNT(*) FROM repair_requests WHERE status = 'accepted'")
            accepted_count = (await accepted_cursor.fetchone())[0]
            # Ожидают оплаты
            completed_cursor = await conn.execute("SELECT COUNT(*) FROM repair_requests WHERE status = 'completed'")
            completed_count = (await completed_cursor.fetchone())[0]
            # Оплаченные
            paid_cursor = await conn.execute("SELECT COUNT(*) FROM repair_requests WHERE status = 'oplacheno'")
            paid_count = (await paid_cursor.fetchone())[0]

    except Exception as e:
        logger.error(f"Ошибка при подсчете заявок на ремонт: {e}", exc_info=True)
        new_count, accepted_count, completed_count, paid_count = '?', '?', '?', '?'

    # Формируем клавиатуру с Reply кнопками
    keyboard = [
        [f"🆕 Новые заявки ({new_count})"],
        [f"🛠️ В работе ({accepted_count})"],
        [f"💳 Ожидают оплаты ({completed_count})"],
        [f"✅ Оплаченные ({paid_count})"],
        ["🏠 Вернуться в главное меню"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    await update.message.reply_text(
        "🛠️ *Панель управления ремонтами*\n\nВыберите категорию для просмотра:",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )

# <<< КОНЕЦ НОВОГО БЛОКА КОДА >>>
async def get_bike_number_for_rent(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 1: Принимает номер велосипеда от администратора.
    Различает, для какой сделки (аренда/выкуп) вводится номер.
    """
    entered_number = update.message.text.strip()
    if not entered_number:
        await update.message.reply_text("❌ Номер не может быть пустым.")
        # Возвращаемся в то же состояние, чтобы ждать корректного ввода
        return AWAIT_BIKE_NUMBER_RENT

    context.user_data['entered_physical_bike_number'] = entered_number
    booking_type = context.user_data.get('booking_type')

    # ### КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: ВЫЗОВ РАЗНЫХ ФИНАЛЬНЫХ ФУНКЦИЙ ###
    if booking_type == 'rent':
        # Если это аренда, запрашиваем количество батарей
        await update.message.reply_text("🔋 Введите количество батарей (например, 2):")
        return AWAIT_BATTERY_COUNT
    elif booking_type == 'buyout':
        # Если это выкуп, сразу переходим к финальному оформлению
        return await finalize_buyout_assignment(update, context)
    else:
        # Обработка непредвиденной ситуации
        await update.message.reply_text("❌ Ошибка: неизвестный тип сделки. Начните заново.")
        return ConversationHandler.END

async def get_battery_count(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2 (Аренда): Принимает кол-во АКБ, запрашивает номера."""
    logging.info("--- [АРЕНДА Шаг 2] Принято кол-во батарей.")
    try:
        count = int(update.message.text.strip())
        if not (0 <= count <= 5): raise ValueError
        context.user_data['battery_count'] = count
    except ValueError:
        await update.message.reply_text("❌ Введите корректное число от 0 до 5.")
        return AWAIT_BATTERY_COUNT

    if count == 0:
        update.message.text = ""
        return await finalize_rent_assignment(update, context)

    await update.message.reply_text(f"✍️ Введите номера для {count} батарей, каждый с новой строки.")
    return AWAIT_BATTERY_NUMS

# main.py

# Убедитесь, что все эти импорты у вас есть в начале файла
import aiosqlite
import json
import os
from datetime import datetime
import asyncio
import random

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ
# main.py

# ... (все ваши импорты) ...

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ
# Убедитесь, что все эти импорты у вас есть в начале файла
import aiosqlite
import json
import os
from datetime import datetime
import asyncio
import random
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler

# ... (здесь должны быть ваши другие функции, включая generate_contract_docx, create_yookassa_payment и т.д.)


# Убедитесь, что все эти импорты у вас есть в начале файла
import aiosqlite
import json
import os
from datetime import datetime
import asyncio
import random
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler

# ... (здесь должны быть ваши другие функции, включая generate_contract_docx, create_yookassa_payment и т.д.)


async def finalize_assignment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ФИНАЛ (Кастом): Создает сделку, генерирует договор, отправляет клиенту
    условия и счет, и завершает сделку.
    """
    query = update.callback_query
    await query.answer()

    await query.edit_message_text("⏳ Создаю сделку, генерирую договор и выставляю счет... Пожалуйста, подождите.")
    logging.info("--- [КАСТОМ ФИНАЛ] Вход в finalize_assignment ---")

    deal_data = context.user_data
    booking_id = deal_data.get('processing_booking_id')
    admin_chat_id = query.message.chat_id

    try:
        # 1. Сбор данных из БД
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute(
                "SELECT b.user_id, u.phone_number, u.passport_data, u.first_name, u.last_name, b.booking_type, b.end_date, b.booking_date "
                "FROM bookings b JOIN users u ON b.user_id = u.id WHERE b.id=?",
                (booking_id,)
            )
            user_db_data = await cursor.fetchone()

        if not user_db_data: raise ValueError(f"Не удалось найти данные по заявке #{booking_id}")
        if not user_db_data['phone_number']: raise ValueError(f"У пользователя ID {user_db_data['user_id']} не указан номер телефона.")

        user_id = user_db_data['user_id']
        price_to_pay = deal_data.get('assign_price', 0.0)
        full_description = deal_data.get('assign_full_desc', 'Индивидуальный комплект')
        booking_type = deal_data.get('booking_type')
        parsed_data = deal_data.get('parsed_deal_data', {})

        # 2. Подготовка словарей с данными для генератора договора
        passport_data = json.loads(user_db_data['passport_data']) if user_db_data['passport_data'] else {}
        user_data_for_doc = {
            'full_name': f"{passport_data.get('Фамилия', '')} {passport_data.get('Имя', '')} {passport_data.get('Отчество', '')}".strip(),
            'ending': 'ый' if passport_data.get('Пол', '').upper().startswith('МУЖ') else 'ая',
            'passport_series': passport_data.get('Серия и номер паспорта', '____ ______').split(' ')[0],
            'passport_number': passport_data.get('Серия и номер паспорта', '____ ______').split(' ')[-1],
            'passport_issued_by': passport_data.get('Кем выдан', '_________________'),
            'address': passport_data.get('Адрес регистрации', '_________________'),
            'initials': f"{passport_data.get('Фамилия', ' ')} {passport_data.get('Имя', ' ')[0]}.{passport_data.get('Отчество', ' ')[0]}."
        }
        
        bike_data_for_doc = {
            'model': parsed_data.get('model_name', "Индивидуальный комплект"),
            'vin': parsed_data.get('bike_number', "б/н"),
            'batteries_count': str(len(parsed_data.get('batteries', [])))
        }

        deal_info_for_doc = {}
        plan_key_to_save = None
        user_notification_details = ""

        if booking_type == 'rent':
            deal_info_for_doc = {'price': int(price_to_pay)}
            start_date_obj = datetime.strptime(user_db_data['booking_date'], '%d.%m.%Y')
            end_date_obj = datetime.strptime(user_db_data['end_date'], '%d.%m.%Y')
            duration_days = (end_date_obj - start_date_obj).days
            user_notification_details = f"Аренда на {duration_days} дней"
        
        elif booking_type == 'buyout':
            plan_key_to_save = deal_data['selected_plan_key']
            plan_info = deal_data['generated_plans'][plan_key_to_save]
            deal_info_for_doc = {
                'total_price': int(plan_info['total_payments'] * plan_info['first_payment']),
                'weekly_payment': int(plan_info['first_payment']),
                'weeks_count': int(plan_info['total_payments']),
                'battery_ah': parsed_data.get('batteries', [{}])[0].get('capacity', '?? Ah'),
                'battery_count': len(parsed_data.get('batteries', []))
            }
            user_notification_details = f"Выкуп по плану: {plan_info['full_label']}"

        # 3. Генерация договора
        file_path = generate_contract_docx(
            booking_id=booking_id,
            deal_type=booking_type,
            deal_data=deal_info_for_doc,
            user_data=user_data_for_doc,
            bike_data=bike_data_for_doc
        )
        with open(file_path, 'rb') as doc_file:
            await context.bot.send_document(admin_chat_id, doc_file, caption=f"✅ Договор для кастомной сделки #{booking_id}")
        os.remove(file_path)

        # 4. Создание и отправка счета клиенту
        invoice_title = f"Оплата: {full_description[:50]}"
        payload = f"custom_payment_{booking_id}"
        metadata = {'internal_payload': payload, 'user_id': user_id}
        items_for_receipt = [{"description": invoice_title, "quantity": "1.00", "amount": {"value": f"{price_to_pay:.2f}", "currency": "RUB"}, "vat_code": "1", "payment_subject": "service"}]
        payment_info = await create_yookassa_payment(amount=price_to_pay, description=invoice_title, metadata=metadata, items=items_for_receipt, customer_info={"phone": user_db_data['phone_number']}, payment_method='sbp')
        if not payment_info: raise ValueError("Не удалось создать ссылку на оплату.")

        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']

        user_approval_message = (
            f"✅ Ваша индивидуальная сделка согласована!\n\n"
            f"**Состав:** `{full_description}`\n"
            f"**Условия:** `{user_notification_details}`\n\n"
            "Готовим счет на оплату..."
        )
        await context.bot.send_message(user_id, user_approval_message, parse_mode="Markdown")

        user_invoice_message = f"Нажмите кнопку для оплаты {final_amount:.2f} ₽"
        keyboard = [[InlineKeyboardButton("💳 Оплатить", url=payment_url)]]
        animated_message = await context.bot.send_message(user_id, user_invoice_message, reply_markup=InlineKeyboardMarkup(keyboard))

        if 'pending_payments' not in context.bot_data: context.bot_data['pending_payments'] = {}
        stop_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {'user_id': user_id, 'start_time': datetime.now(), 'payload': payload, 'amount': final_amount, 'animated_message_id': animated_message.message_id, 'url': payment_url, 'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 'stop_animation_event': stop_event}
        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(callback=check_payment_status, interval=15, first=10, name=f"payment_{payment_id}", data={'yookassa_id': payment_id})

        # 5. Обновление БД
        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("INSERT INTO bikes (name, description, available, type) VALUES (?, ?, 0, ?)", (full_description, "Индивидуальная сделка", booking_type))
            assigned_bike_id = cursor.lastrowid
            await conn.execute("UPDATE bookings SET bike_id = ?, payment_plan_key = ? WHERE id = ?", (assigned_bike_id, plan_key_to_save, booking_id))
            await conn.commit()

        await query.message.edit_text(f"✅ Успешно! Кастомная сделка #{booking_id} создана, счет отправлен пользователю.")

    except Exception as e:
        logger.error(f"КРИТИЧЕСКАЯ ОШИБКА в finalize_assignment: {e}", exc_info=True)
        await query.message.edit_text(f"❌ ОШИБКА: {e}.\nНазначение отменено.")

    context.user_data.clear()
    return ConversationHandler.END


# --- ФУНКЦИИ ДЛЯ ВЕТКИ СТАНДАРТНОГО ВЫКУПА ---

# main.py

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ НА ЭТУ ВЕРСИЮ
async def finalize_buyout_assignment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 1 (Выкуп): Принимает номер велосипеда и ПЕРЕНАПРАВЛЯЕТ на шаг запроса АКБ.
    """
    logging.info("--- [ВЫКУП Шаг 1] Принят номер велосипеда. Перехожу к запросу АКБ.")

    physical_number = update.message.text.strip()
    if not physical_number:
        await update.message.reply_text("❌ Номер не может быть пустым.")
        # Возвращаемся в то же состояние, чтобы ждать корректного ввода
        return AWAIT_BIKE_NUMBER_BUYOUT

    # Сохраняем введенный номер в контекст
    context.user_data['entered_physical_bike_number'] = physical_number

    # Отправляем тот же вопрос, что и для аренды
    await update.message.reply_text("🔋 Введите количество батарей, идущих в комплекте (например, 2):")

    # >>> ГЛАВНОЕ ИЗМЕНЕНИЕ <<<
    # Вместо завершения, мы переводим диалог в состояние AWAIT_BATTERY_COUNT,
    # которое уже обрабатывается функцией get_battery_count.
    return AWAIT_BATTERY_COUNT


# --- ФУНКЦИИ ДЛЯ ВЕТКИ КАСТОМНОЙ СДЕЛКИ ---

# main.py

# Импортируем новую функцию
from passport_recognition_gemini import parse_custom_deal_with_gemini

# main.py

# Убедись, что эта функция импортирована
from passport_recognition_gemini import parse_custom_deal_with_gemini

async def get_custom_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 1 (Кастом): Принимает описание, парсит его с помощью Gemini и показывает результат для подтверждения.
    """
    description = update.message.text.strip()

    # Сразу сохраняем полное описание, как и раньше
    context.user_data['assign_full_desc'] = description

    thinking_message = await update.message.reply_text("🧠 Анализирую описание комплекта...")

    # Вызываем новую функцию Gemini для парсинга
    parsed_data = parse_custom_deal_with_gemini(description)

    if not parsed_data:
        await thinking_message.edit_text("😔 Не удалось распознать описание. Пожалуйста, попробуйте еще раз, описав комплект более четко (например: 'Монстр 54321 + 2 АКБ 30Ah 123, 456').")
        return AWAIT_CUSTOM_DESC # Возвращаемся, чтобы админ попробовал снова

    # Сохраняем распознанные части в контекст
    context.user_data['parsed_deal_data'] = parsed_data

    booking_type = context.user_data.get('booking_type')

    # В зависимости от типа сделки, переходим к следующему шагу
    if booking_type == 'rent':
        await thinking_message.edit_text("Введите итоговую ЦЕНУ АРЕНДЫ для этого комплекта:")
        return AWAIT_CUSTOM_RENT_PRICE
    elif booking_type == 'buyout':
        await thinking_message.edit_text("Опишите желаемый план рассрочки (например, '5 месяцев по 10к раз в две недели'):")
        return AWAIT_CUSTOM_BUYOUT_PLAN

    return ConversationHandler.END

# main.py

async def get_custom_rent_price(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Принимает цену, сохраняет ее и показывает финальное подтверждение.
    """
    try:
        price = float(update.message.text.replace(',', '.'))
        context.user_data['assign_price'] = price
    except ValueError:
        await update.message.reply_text("🚫 Введите корректную цену (только число).")
        return AWAIT_CUSTOM_RENT_PRICE
    # Сразу вызываем функцию, которая покажет все данные для подтверждения
    return await show_custom_deal_confirmation(update.message, context)

async def process_custom_buyout_plan(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    plan_description = update.message.text.strip()
    deal_description = context.user_data['assign_full_desc']

    thinking_message = await update.message.reply_text("🤖 Генерирую структурированный план с помощью AI... 🧠")

    plans = get_buyout_plans_with_gemini(deal_description, plan_description)
    if not plans:
        await thinking_message.edit_text("😔 Не удалось сгенерировать план. Попробуйте описать его по-другому.")
        return AWAIT_CUSTOM_BUYOUT_PLAN

    context.user_data['generated_plans'] = plans
    context.user_data['selected_plan_key'] = list(plans.keys())[0]
    return await show_custom_deal_confirmation(thinking_message, context)

### НАЧАЛО ИСПРАВЛЕННОЙ ФУНКЦИИ ###

# main.py

# main.py

# main.py

# main.py
import aiosqlite # Убедись, что этот импорт есть в начале

async def show_custom_deal_confirmation(message, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Показывает подтверждение для кастомной сделки, теперь включая срок аренды из БД.
    """
    deal_data = context.user_data
    parsed_data = deal_data.get('parsed_deal_data', {})
    booking_id = deal_data.get('processing_booking_id')

    text_parts = ["*Проверьте данные для кастомной сделки:*\n"]

    # Блок с моделью и АКБ (без изменений)
    text_parts.append(f"• Модель: `{parsed_data.get('model_name', 'Не распознано')}`")
    text_parts.append(f"• Номер велосипеда: `{parsed_data.get('bike_number', 'Не распознан')}`")
    batteries = parsed_data.get('batteries', [])
    if not batteries:
        text_parts.append("• Аккумуляторы: `нет`")
    else:
        battery_lines = [f"{i+1}) Аккумулятор {b.get('capacity', '??Ah')} (№ {b.get('number', 'б/н')})" for i, b in enumerate(batteries)]
        text_parts.append(f"• Аккумуляторы:\n " + "\n ".join(battery_lines))

    text_parts.append("-" * 20)

    if deal_data.get('booking_type') == 'rent':
        # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
        # Получаем даты из БД, чтобы рассчитать срок
        duration_days_text = "?? дней"
        try:
            async with aiosqlite.connect(DB_FILE) as conn:
                cursor = await conn.execute("SELECT booking_date, end_date FROM bookings WHERE id = ?", (booking_id,))
                dates = await cursor.fetchone()

            if dates and dates[0] and dates[1]:
                start_date = datetime.strptime(dates[0], '%d.%m.%Y')
                end_date = datetime.strptime(dates[1], '%d.%m.%Y')
                duration_days = (end_date - start_date).days
                duration_days_text = f"{duration_days} дней"
            else:
                raise ValueError("Даты не найдены в заявке")

        except Exception as e:
            logger.error(f"Не удалось получить срок аренды для заявки #{booking_id}: {e}")

        text_parts.append("• Тип: Аренда")
        text_parts.append(f"• Срок: {duration_days_text}")
        text_parts.append(f"• Цена: {deal_data.get('assign_price', 0.0):.2f} руб.")
        # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
    else: # Выкуп
        # (блок выкупа без изменений)
        plan_key = deal_data.get('selected_plan_key', 'plan_1')
        plan_info = deal_data.get('generated_plans', {}).get(plan_key, {})
        text_parts.append("• Тип: Выкуп")
        text_parts.append(f"• План: {plan_info.get('full_label', 'Не указан')}")
        deal_data['assign_price'] = plan_info.get('first_payment', 0)

    # (кнопки без изменений)
    keyboard = [[
        InlineKeyboardButton("✅ Да, создать и выставить счет", callback_data="assign_finalize"),
        InlineKeyboardButton("❌ Отмена", callback_data="cancel_assignment")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    final_text = "\n".join(text_parts)

    if message.from_user.is_bot:
        await message.edit_text(final_text, reply_markup=reply_markup, parse_mode="Markdown")
    else:
        await message.reply_text(final_text, reply_markup=reply_markup, parse_mode="Markdown")

    return AWAIT_CUSTOM_CONFIRM

### КОНЕЦ ИСПРАВЛЕННОЙ ФУНКЦИИ ###

# Убедитесь, что все эти импорты есть в начале вашего файла
import aiosqlite
import json
import os
from datetime import datetime
import asyncio
import random
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler

# ### ПОЛНАЯ ВЕРСИЯ ФУНКЦИИ ДЛЯ КАСТОМНЫХ СДЕЛОК ###
### НАЧАЛО ПОЛНОЙ ИСПРАВЛЕННОЙ ФУНКЦИИ ###

### НАЧАЛО ПОЛНОЙ ИСПРАВЛЕННОЙ ФУНКЦИИ ###

# main.py

# Убедитесь, что все эти импорты у вас есть в начале файла
import aiosqlite
import json
import os
from datetime import datetime
import asyncio
import random
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler

# --- ПОЛНАЯ ФИНАЛЬНАЯ ФУНКЦИЯ ДЛЯ КАСТОМНЫХ СДЕЛОК ---

# main.py

# main.py

# main.py

async def finalize_assignment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ФИНАЛ (Кастом): Создает сделку, генерирует договор, ОТПРАВЛЯЕТ КЛИЕНТУ
    СНАЧАЛА УСЛОВИЯ, А ПОТОМ СЧЕТ, и завершает сделку.
    """
    query = update.callback_query
    await query.answer()

    await query.edit_message_text("⏳ Создаю сделку, генерирую договор и выставляю счет... Пожалуйста, подождите.")
    logging.info("--- [КАСТОМ ФИНАЛ] Вход в finalize_assignment ---")

    deal_data = context.user_data
    booking_id = deal_data.get('processing_booking_id')
    admin_chat_id = query.message.chat_id

    try:
        # 1. Сбор данных из БД
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute(
                "SELECT b.user_id, u.phone_number, u.passport_data, u.first_name, u.last_name, b.booking_type, b.end_date, b.booking_date "
                "FROM bookings b JOIN users u ON b.user_id = u.id WHERE b.id=?",
                (booking_id,)
            )
            user_db_data = await cursor.fetchone()

        if not user_db_data: raise ValueError("Не удалось найти пользователя для сделки.")
        if not user_db_data['phone_number']: raise ValueError("У пользователя не указан номер телефона.")

        user_id = user_db_data['user_id']
        price_to_pay = deal_data.get('assign_price', 0.0)
        full_description = deal_data.get('assign_full_desc', 'Индивидуальный комплект')
        booking_type = deal_data.get('booking_type')
        parsed_data = deal_data.get('parsed_deal_data', {})

        # 2. Подготовка данных для договора и уведомлений (без изменений)
        passport_data = json.loads(user_db_data['passport_data']) if user_db_data['passport_data'] else {}
        user_data_for_doc = { "full_name": f"{user_db_data['last_name'] or ''} {user_db_data['first_name'] or ''}".strip(), "phone": user_db_data['phone_number'], "passport_data": passport_data }
        batteries_list = parsed_data.get('batteries', [])
        if not batteries_list: battery_info_for_doc = "без АКБ"
        else:
            battery_lines = [f"{b.get('capacity', '')} (№{b.get('number', 'б/н')})" for b in batteries_list]
            battery_info_for_doc = f"{len(batteries_list)} шт: " + ", ".join(battery_lines)
        bike_data_for_doc = { "model_name": parsed_data.get('model_name', "Не указано"), "number": parsed_data.get('bike_number', "б/н"), "battery_info": battery_info_for_doc, "estimated_cost": "80000р."}

        rental_info_for_doc = {}
        plan_key_to_save = None
        user_notification_details = ""
        duration_text = ""

        if booking_type == 'rent':
            try:
                start_date_obj = datetime.strptime(user_db_data['booking_date'], '%d.%m.%Y')
                end_date_obj = datetime.strptime(user_db_data['end_date'], '%d.%m.%Y')
                duration_days = (end_date_obj - start_date_obj).days
                if duration_days % 10 == 1 and duration_days % 100 != 11: days_word = "день"
                elif 2 <= duration_days % 10 <= 4 and (duration_days % 100 < 10 or duration_days % 100 >= 20): days_word = "дня"
                else: days_word = "дней"
                duration_text = f"{duration_days} {days_word}"
            except (ValueError, TypeError) as e:
                logging.warning(f"Не удалось рассчитать срок аренды: {e}")
                duration_text = "индивидуальный срок"
            rental_info_for_doc = {"type": "rent", "price_text": f"{price_to_pay:.2f} руб.", "duration_text": duration_text}
            user_notification_details = f"Аренда на {duration_text}"
        else: # buyout
            plan_key_to_save = deal_data['selected_plan_key']
            plan_info = deal_data['generated_plans'][plan_key_to_save]
            rental_info_for_doc = {"type": "buyout", "payment_schedule": plan_info['full_label'], "buyout_period": f"{plan_info.get('total_payments')} платежей"}
            user_notification_details = f"Выкуп по плану: {plan_info['full_label']}"

        # 3. Генерация договора (без изменений)
        file_path = generate_contract_docx(booking_id, user_data_for_doc, bike_data_for_doc, rental_info_for_doc)
        with open(file_path, 'rb') as doc_file:
            await context.bot.send_document(admin_chat_id, doc_file, caption=f"✅ Договор для кастомной сделки #{booking_id}")
        os.remove(file_path)

        # 4. Создание платежа (без изменений)
        invoice_title = f"Оплата: {full_description[:50]}"
        payload = f"custom_payment_{booking_id}"
        metadata = {'internal_payload': payload, 'user_id': user_id}
        items_for_receipt = [{"description": invoice_title, "quantity": "1.00", "amount": {"value": f"{price_to_pay:.2f}", "currency": "RUB"}, "vat_code": "1", "payment_subject": "service"}]
        payment_info = await create_yookassa_payment(amount=price_to_pay, description=invoice_title, metadata=metadata, items=items_for_receipt, customer_info={"phone": user_db_data['phone_number']}, payment_method='sbp')
        if not payment_info: raise ValueError("Не удалось создать ссылку на оплату.")

        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']

        # <<< НАЧАЛО ИСПРАВЛЕНИЙ: Разделяем сообщения для клиента >>>

        # ПЕРВОЕ сообщение клиенту с условиями сделки
        user_approval_message = (
            f"✅ Ваша индивидуальная сделка согласована!\n\n"
            f"**Состав:** `{full_description}`\n"
            f"**Условия:** `{user_notification_details}`\n\n"
            "Готовим счет на оплату..."
        )
        await context.bot.send_message(user_id, user_approval_message, parse_mode="Markdown")

        # ВТОРОЕ сообщение клиенту со счетом
        user_invoice_message = f"Нажмите кнопку для оплаты {final_amount:.2f} ₽"
        keyboard = [[InlineKeyboardButton("💳 Оплатить", url=payment_url)]]
        animated_message = await context.bot.send_message(
            user_id,
            user_invoice_message,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        # <<< КОНЕЦ ИСПРАВЛЕНИЙ >>>

        # Запускаем проверку платежа (без изменений)
        if 'pending_payments' not in context.bot_data: context.bot_data['pending_payments'] = {}
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {'user_id': user_id, 'start_time': datetime.now(), 'payload': payload, 'amount': final_amount, 'animated_message_id': animated_message.message_id, 'url': payment_url, 'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 'stop_animation_event': stop_animation_event}
        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(callback=check_payment_status, interval=15, first=10, name=f"payment_{payment_id}", data={'yookassa_id': payment_id})

        # 5. Обновление БД (без изменений)
        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("INSERT INTO bikes (name, description, available, type) VALUES (?, ?, 0, ?)",(full_description, "Индивидуальная сделка", booking_type))
            assigned_bike_id = cursor.lastrowid
            await conn.execute("UPDATE bookings SET bike_id = ?, payment_plan_key = ? WHERE id = ?",(assigned_bike_id, plan_key_to_save, booking_id))
            await conn.commit()

        await query.message.edit_text(f"✅ Успешно! Кастомная сделка #{booking_id} создана, счет отправлен пользователю.")

    except Exception as e:
        logger.error(f"КРИТИЧЕСКАЯ ОШИБКА в finalize_assignment: {e}", exc_info=True)
        await query.message.edit_text(f"❌ ОШИБКА: {e}.\nНазначение отменено.")

    context.user_data.clear()
    return ConversationHandler.END

### КОНЕЦ ПОЛНОЙ ИСПРАВЛЕННОЙ ФУНКЦИИ ###

### КОНЕЦ ПОЛНОЙ ИСПРАВЛЕННОЙ ФУНКЦИИ ###


# --- ОБЩАЯ ФУНКЦИЯ ОТМЕНЫ ---

async def cancel_assignment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Общая функция отмены для всего диалога."""
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text("Назначение отменено.")
    else:
        await update.message.reply_text("Назначение отменено.")
    context.user_data.clear()
    return ConversationHandler.END

# ==============================================================================
# КОНЕЦ БЛОКА ПОЛНОЙ ЗАМЕНЫ
# ==============================================================================

async def leave_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Обрабатывает нажатие кнопки "Я оставил(а) велосипед на складе".
    """
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])
    user_id = query.from_user.id

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute("SELECT user_id, left_at FROM repair_requests WHERE id=?", (request_id,))
            result = await cursor.fetchone()

            if result and result['user_id'] == user_id and result['left_at'] is None:
                current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                await conn.execute("UPDATE repair_requests SET left_at=? WHERE id=?", (current_time, request_id))
                await conn.commit()

                left_date = datetime.strptime(current_time, "%Y-%m-%d %H:%M:%S").strftime("%d.%m.%Y")
                await query.edit_message_text(f"✅ Вы отметили, что оставили велосипед на складе {left_date}.")

                # Уведомление администраторам
                cursor = await conn.execute("""
                    SELECT u.first_name, u.last_name, u.username, b.name
                    FROM repair_requests rr
                    JOIN users u ON rr.user_id = u.id
                    JOIN bikes b ON rr.bike_id = b.id
                    WHERE rr.id=?
                """, (request_id,))
                notify_data = await cursor.fetchone()
                user_name = f"{notify_data['first_name']} {notify_data['last_name'] or ''} (@{notify_data['username'] or 'no_username'})"

                notification_message = (
                    f"🚚 *Велосипед доставлен на склад!*\n\n"
                    f"👤 *Пользователь:* {escape_markdown(user_name, 2)}\n"
                    f"🚲 *Велосипед:* {escape_markdown(notify_data['name'], 2)}\n"
                    f"📌 *ID заявки:* `{request_id}`"
                )
                for admin_id in ADMIN_IDS + MASTER_IDS:
                    await context.bot.send_message(admin_id, notification_message, parse_mode="MarkdownV2")

            elif result and result['left_at'] is not None:
                await query.answer("Вы уже отмечали, что оставили велосипед.", show_alert=True)
            else:
                await query.answer("🚫 Вы не можете выполнить это действие.", show_alert=True)

    except Exception as e:
        logger.error(f"Ошибка в leave_bike: {e}", exc_info=True)
        await query.answer("Произошла ошибка.", show_alert=True)

async def back_to_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.message.from_user.id
    menu_keyboard = get_main_menu(user_id)
    await update.message.reply_text("Вы вернулись в главное меню.", reply_markup=menu_keyboard)
    return ConversationHandler.END

def get_accepted_repairs_count():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM repair_requests WHERE status='accepted'")
    count = cursor.fetchone()[0]
    conn.close()
    return count

def get_completed_repairs_count():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM repair_requests WHERE status='completed' AND status != 'oplacheno'")
    count = cursor.fetchone()[0]
    conn.close()
    return count

# Обновленная функция завершения ремонта с выбором типа (гарантийный/не гарантийный)


#



# Обновленная функция отметки заявки как оплаченной
# --- НОВАЯ, УПРОЩЕННАЯ ЛОГИКА ЗАВЕРШЕНИЯ РЕМОНТА ---

# Определяем состояния для нового диалога
(AWAIT_REPAIR_PRICE, AWAIT_DELAY_REASON) = range(2)

async def start_complete_repair(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 1: Начинает процесс завершения ремонта, запрашивая итоговую цену.
    """
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])
    context.user_data['completing_repair_id'] = request_id

    # Сразу запрашиваем цену
    await query.edit_message_text(
        f"✅ Завершение заявки #{request_id}.\n\n"
        "Пожалуйста, введите итоговую стоимость ремонта в рублях. \n"
        "Если ремонт гарантийный, введите **0**."
    )
    return AWAIT_REPAIR_PRICE


async def process_repair_price(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Шаг 2: Принимает цену, проверяет на просрочку и, если нужно, запрашивает причину задержки.
    """
    try:
        price = float(update.message.text.replace(',', '.'))
        if price < 0:
            raise ValueError
        context.user_data['final_repair_price'] = price
    except ValueError:
        await update.message.reply_text("🚫 Введите корректную сумму (число, можно 0).")
        return AWAIT_REPAIR_PRICE

    request_id = context.user_data['completing_repair_id']

    # Проверяем, был ли ремонт просрочен
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute("SELECT expected_completion_date FROM repair_requests WHERE id=?", (request_id,))
            result = await cursor.fetchone()

        if result and result['expected_completion_date']:
            expected_date = datetime.strptime(result['expected_completion_date'], "%d.%m.%Y").date()
            if datetime.now().date() > expected_date:
                # Ремонт просрочен, запрашиваем причину
                await update.message.reply_text(
                    f"⚠️ Ремонт просрочен (план. дата: {expected_date.strftime('%d.%m.%Y')}).\n"
                    "Пожалуйста, укажите причину задержки:"
                )
                return AWAIT_DELAY_REASON
    except Exception as e:
        logger.warning(f"Не удалось проверить дату просрочки для заявки {request_id}: {e}")

    # Если не просрочен, сразу переходим к финалу
    return await finalize_completed_repair(update, context)


# --- ФИНАЛЬНАЯ ВЕРСИЯ ---
### НОВАЯ ВЕРСИЯ, ТОЛЬКО ДЛЯ АДМИНА ###
async def finalize_completed_repair(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Финал: Сохраняет все данные, выставляет счет пользователю (если цена > 0)
    и завершает диалог. Вызывается только из админского пути.
    """
    message_to_reply = update.message # Теперь мы точно знаем, что это сообщение
    delay_reason = None

    # Проверяем, в каком состоянии мы находимся, чтобы получить причину задержки
    if 'current_state' in context.user_data and context.user_data['current_state'] == AWAIT_DELAY_REASON:
        delay_reason = message_to_reply.text

    request_id = context.user_data['completing_repair_id']
    price = context.user_data['final_repair_price']
    admin_chat_id = update.effective_chat.id

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            await conn.execute('BEGIN')

            completed_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            await conn.execute(
                "UPDATE repair_requests SET status='completed', estimated_price=?, completed_at=?, is_warranty=?, delay_reason=? WHERE id=?",
                (price, completed_at, 1 if price == 0 else 0, delay_reason, request_id)
            )

            cursor = await conn.execute("""
                SELECT rr.user_id, rr.bike_id, u.phone_number, b.name as bike_name
                FROM repair_requests rr
                JOIN users u ON rr.user_id = u.id
                JOIN bikes b ON rr.bike_id = b.id
                WHERE rr.id=?
            """, (request_id,))
            data = await cursor.fetchone()
            if not data: raise ValueError("Не удалось найти данные по заявке.")

            await conn.execute(
                "UPDATE repair_logs SET repair_end_date = ?, delay_reason = ? WHERE bike_id = ? AND repair_end_date IS NULL",
                (datetime.now().strftime('%d.%m.%Y'), delay_reason, data['bike_id'])
            )

            log_details = f"Ремонт для '{data['bike_name']}' завершен. Сумма: {price} ₽."
            if delay_reason: log_details += f" Причина задержки: {delay_reason}"
            await log_bike_action(conn, data['bike_id'], data['user_id'], "Ремонт завершен", log_details, amount=price)

            await conn.commit()

        await message_to_reply.reply_text(f"✅ Заявка #{request_id} завершена. Сумма: {price} ₽.")

        if price > 0:
            if not data['phone_number']:
                 await context.bot.send_message(admin_chat_id, f"⚠️ Не удалось выставить счет пользователю {data['user_id']} (нет номера телефона).")
            else:
                description = f"Оплата ремонта велосипеда '{data['bike_name']}' (заявка #{request_id})"
                payload = f"repair_payment_{request_id}"
                metadata = {'internal_payload': payload, 'user_id': data['user_id']}
                items = [{"description": description, "quantity": "1.00", "amount": {"value": f"{price:.2f}", "currency": "RUB"}, "vat_code": "1"}]
                customer = {"phone": data['phone_number']}

                payment_info = await create_yookassa_payment(price, description, metadata, items, customer, 'sbp')
                if payment_info:
                    payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']
                    keyboard = [[InlineKeyboardButton("💳 Оплатить ремонт", url=payment_url)]]

                    animated_message = await context.bot.send_message(
                        data['user_id'],
                        f"🛠️ Ваш ремонт завершен! Сумма к оплате: {final_amount:.2f} ₽. Нажмите, чтобы оплатить.",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )

                    if 'pending_payments' not in context.bot_data:
                        context.bot_data['pending_payments'] = {}
                    stop_animation_event = asyncio.Event()
                    context.bot_data['pending_payments'][payment_id] = {
                        'user_id': data['user_id'], 'start_time': datetime.now(),
                        'payload': payload, 'amount': final_amount,
                        'animated_message_id': animated_message.message_id, 'url': payment_url,
                        'animation_sequence': random.choice(PAYMENT_ANIMATIONS),
                        'stop_animation_event': stop_animation_event
                    }

                    asyncio.create_task(animate_payment_message(context, payment_id))
                    context.job_queue.run_repeating(
                        callback=check_payment_status, interval=15, first=10,
                        name=f"payment_{payment_id}", data={'yookassa_id': payment_id}
                    )
                else:
                    await context.bot.send_message(admin_chat_id, f"⚠️ Ошибка создания платежа для заявки #{request_id}.")
        else:
             # Если ремонт бесплатный, сразу меняем статус на "oplacheno"
             async with aiosqlite.connect(DB_FILE) as conn:
                 await conn.execute("UPDATE repair_requests SET status='oplacheno' WHERE id=?", (request_id,))
                 await conn.commit()
             await context.bot.send_message(
                data['user_id'],
                "🛠️ Ваш ремонт завершен! Так как он был гарантийным, оплата не требуется. Вы можете забрать свой велосипед."
             )

    except Exception as e:
        logger.error(f"Ошибка в finalize_completed_repair: {e}", exc_info=True)
        await message_to_reply.reply_text("❌ Произошла критическая ошибка при завершении ремонта.")
    finally:
        context.user_data.clear()
        return ConversationHandler.END

WAITING_FOR_TIME, WAITING_FOR_PRICE = range(2)

async def accept_repair_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])
    context.user_data['request_id'] = request_id

    await query.edit_message_text("🕒 Введите примерное время выполнения работы (например, '2 часа' или '1 день'):")
    return WAITING_FOR_TIME

async def get_time(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка ввода времени выполнения ремонта с сохранением конкретной даты"""

    if 'awaiting_time_correction' not in context.user_data:
        await update.message.reply_text(
            "🕒 Введите дату завершения ремонта в формате ДД.ММ.ГГГГ, например:\n"
            "• 17.03.2025\n"
            "• 25.04.2025\n\n"
            "Либо укажите количество дней (например):\n"
            "• 1 день\n"
            "• 2 дня\n"
            "• 5 дней"
        )
        context.user_data['awaiting_time_correction'] = False
        return WAITING_FOR_TIME

    time_input = update.message.text.strip()

    # Проверяем на формат дней
    days_pattern = re.compile(r'^\d+\s+(день|дня|дней)$')
    # Проверяем на формат даты
    date_pattern = re.compile(r'^\d{2}\.\d{2}\.\d{4}$')

    current_date = datetime.now()

    if days_pattern.match(time_input):
        # Если ввод в формате "X дней"
        days = int(''.join(filter(str.isdigit, time_input)))

        # Рассчитываем дату завершения
        completion_date = current_date + timedelta(days=days)
        completion_date_str = completion_date.strftime("%d.%m.%Y")

        # Для отображения сохраняем оба формата
        context.user_data['time'] = time_input  # Для отображения в UI
        context.user_data['expected_completion_date'] = completion_date_str  # Для сохранения в БД

        time_message = f"{time_input} (до {completion_date_str})"

    elif date_pattern.match(time_input):
        # Если ввод уже в формате даты
        try:
            completion_date = datetime.strptime(time_input, "%d.%m.%Y")

            # Рассчитываем количество дней для отображения
            days_diff = (completion_date - current_date).days
            if days_diff < 1:
                days_diff = 1

            # Формируем правильное склонение слова "день"
            if days_diff % 10 == 1 and days_diff % 100 != 11:
                days_word = "день"
            elif 2 <= days_diff % 10 <= 4 and (days_diff % 100 < 10 or days_diff % 100 >= 20):
                days_word = "дня"
            else:
                days_word = "дней"

            time_string = f"{days_diff} {days_word}"

            # Сохраняем оба формата
            context.user_data['time'] = time_string  # Для отображения в UI
            context.user_data['expected_completion_date'] = time_input  # Для сохранения в БД

            time_message = f"{time_string} (до {time_input})"

        except ValueError:
            await update.message.reply_text("❌ Неверный формат даты. Используйте формат ДД.ММ.ГГГГ, например 17.03.2025")
            return WAITING_FOR_TIME

    else:
        await update.message.reply_text(
            "❌ Неверный формат. Введите дату в одном из форматов:\n"
            "• Конкретная дата (например, 17.03.2025)\n"
            "• Количество дней (например, 5 дней)"
        )
        return WAITING_FOR_TIME

    # Очищаем флаг коррекции
    if 'awaiting_time_correction' in context.user_data:
        del context.user_data['awaiting_time_correction']

    # Показываем информацию о сроке выполнения
    await update.message.reply_text(
        f"✅ Записана дата завершения: {time_message}\n\n"
        f"💵 Теперь введите примерную цену за работу (например, '1000 рублей'):"
    )

    return WAITING_FOR_PRICE

### НОВАЯ, ИСПРАВЛЕННАЯ ФУНКЦИЯ ###
async def get_price(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка ввода цены и сохранение заявки"""
    price_text = update.message.text

    # <<< ИЗМЕНЕНИЕ: Преобразуем текст в число и проверяем >>>
    try:
        # Убираем "рублей" и пробелы, заменяем запятую на точку
        cleaned_price = price_text.lower().replace("рублей", "").replace("рубля", "").replace("рубль", "").strip()
        price_float = float(cleaned_price.replace(',', '.'))
        if price_float < 0:
            raise ValueError("Цена не может быть отрицательной")
    except (ValueError, TypeError):
        await update.message.reply_text("🚫 Введите корректную сумму (только число, например, 1500 или 0).")
        return WAITING_FOR_PRICE # Остаемся в том же состоянии для повторного ввода

    request_id = context.user_data['request_id']
    time = context.user_data['time']
    expected_completion_date = context.user_data.get('expected_completion_date', '')

    formatted_price = format_rubles(price_float) # Используем число для форматирования

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute(
        """UPDATE repair_requests
           SET status='accepted', estimated_time=?, estimated_price=?, expected_completion_date=?
           WHERE id=?""",
        (time, price_float, expected_completion_date, request_id) # <<< Сохраняем число (price_float)
    )
    conn.commit()
    conn.close()

    time_message = f"{time} (до {expected_completion_date})" if expected_completion_date else time

    await update.message.reply_text(
        f"✅ Заявка на ремонт ID {request_id} принята в работу.\n"
        f"🕒 Время: {time_message}\n"
        f"💵 Цена: {formatted_price}."
    )

    user_id = get_user_id_by_request_id(request_id)
    await context.bot.send_message(
        chat_id=user_id,
        text=(
            f"🛠️ Ваша заявка на ремонт принята в работу.\n"
            f"🕒 Примерное время выполнения: {time_message}\n"
            f"💵 Примерная цена: {formatted_price}.\n\n"
            f"❓ По всем дополнительным вопросам обращайтесь в поддержку: @Desscov."
        )
    )
    await context.bot.send_sticker(
        chat_id=user_id,
        sticker="CAACAgIAAxkBAAELuQ5ni347Uj7vYpmrUlRm0hMv-OuwRwACBBoAAqJdeUtq-6Jpx5iCFjYE"
    )
    # await view_repair_requests(update, context) # Эту строку можно закомментировать, чтобы не дублировать вывод
    return ConversationHandler.END

def format_rubles(amount):
    if isinstance(amount, str):
        amount = int(''.join(filter(str.isdigit, amount)))  # Извлекаем число из строки
    last_digit = amount % 10
    last_two_digits = amount % 100

    if last_two_digits in [11, 12, 13, 14]:
        return f"{amount} рублей"
    elif last_digit == 1:
        return f"{amount} рубль"
    elif last_digit in [2, 3, 4]:
        return f"{amount} рубля"
    else:
        return f"{amount} рублей"

# Функция для получения user_id по request_id
def get_user_id_by_request_id(request_id):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT user_id FROM repair_requests WHERE id=?", (request_id,))
    user_id = cursor.fetchone()[0]
    conn.close()
    return user_id

async def delete_repair_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])  # Получаем ID заявки

    # Удаляем заявку из базы данных
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM repair_requests WHERE id=?", (request_id,))
    conn.commit()
    conn.close()

    # Уведомляем пользователя
    await query.edit_message_text(f"🗑️ Заявка на ремонт ID {request_id} была успешно удалена.")
    await view_repair_requests(update, context)




async def leave_bike(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])
    user_id = query.from_user.id

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT user_id, left_at FROM repair_requests WHERE id=?", (request_id,))
    result = cursor.fetchone()

    if result and result[0] == user_id and result[1] is None:
        # Сохраняем время оставления
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        cursor.execute("UPDATE repair_requests SET left_at=? WHERE id=?", (current_time, request_id))
        conn.commit()

        # Форматируем дату для отображения
        left_at_dt = datetime.strptime(current_time, "%Y-%m-%d %H:%M:%S")
        left_date = left_at_dt.strftime("%d.%m.%Y")  # 19.03.2025

        # Уведомляем пользователя
        await query.edit_message_text(f"✅ Вы отметили, что оставили велосипед на складе {left_date}.")

        # Получаем данные для уведомления администраторов
        cursor.execute("""
            SELECT u.first_name, u.last_name, u.username, b.name, rr.description
            FROM repair_requests rr
            JOIN users u ON rr.user_id = u.id
            JOIN bikes b ON rr.bike_id = b.id
            WHERE rr.id=?
        """, (request_id,))
        user_data = cursor.fetchone()
        user_name = f"{user_data[0]} {user_data[1]}" if user_data[1] else user_data[0]
        if user_data[2]:
            user_name += f" (@{user_data[2]})"
        bike_name, description = user_data[3], user_data[4]

        notification_message = (
            f"🚴 *Велосипед оставлен на складе*\n"
            f"👤 *Пользователь*: {user_name}\n"
            f"🚲 *Велосипед*: {bike_name}\n"
            f"📅 *Дата*: {left_date}\n"  # 19.03.2025
            f"📝 *Описание проблемы*: {description}\n"
            f"📌 *ID заявки*: {request_id}"
        )
        for admin_id in ADMIN_IDS + MASTER_IDS:
            await context.bot.send_message(admin_id, notification_message, parse_mode='Markdown')
    else:
        await query.edit_message_text("🚫 Вы не можете выполнить это действие.")

    conn.close()

async def back_to_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.message.from_user.id
    menu_keyboard = get_main_menu(user_id)
    await update.message.reply_text("Вы вернулись в главное меню.", reply_markup=menu_keyboard)
    return ConversationHandler.END

def get_accepted_repairs_count():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM repair_requests WHERE status='accepted'")
    count = cursor.fetchone()[0]
    conn.close()
    return count

def get_completed_repairs_count():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM repair_requests WHERE status='completed' AND status != 'oplacheno'")
    count = cursor.fetchone()[0]
    conn.close()
    return count

# Обновленная функция завершения ремонта с выбором типа (гарантийный/не гарантийный)
async def complete_repair(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Функция для завершения ремонта с проверкой просрочки"""
    query = update.callback_query
    await query.answer()

    # Извлекаем ID заявки из callback_data
    request_id = int(query.data.split("_")[2])
    context.user_data['request_id'] = request_id

    # Проверяем, просрочен ли ремонт
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Получаем данные о ремонте: дату создания и ожидаемую дату завершения
    cursor.execute("""
        SELECT created_at, expected_completion_date
        FROM repair_requests
        WHERE id=?
    """, (request_id,))
    result = cursor.fetchone()
    conn.close()

    # ВАЖНО: Сохраняем информацию о просрочке в глобальную переменную
    # Это решит проблему с context.user_data
    global repair_delayed_info
    repair_delayed_info = {
        'request_id': request_id,
        'is_delayed': False,
        'expected_date': "нет данных"
    }

    if result:
        created_at, expected_completion_date = result

        print(f"DEBUG: created_at={created_at}, expected_completion_date={expected_completion_date}")

        # Проверка на просрочку только если есть дата завершения
        if expected_completion_date:
            repair_delayed_info['expected_date'] = expected_completion_date

            try:
                # Текущая дата для сравнения
                current_date = datetime.now()

                # Преобразуем строку expected_completion_date в объект datetime
                expected_completion = datetime.strptime(expected_completion_date, "%d.%m.%Y")

                print(f"DEBUG: Ожидаемая дата завершения: {expected_completion.strftime('%d.%m.%Y')}")
                print(f"DEBUG: Текущая дата: {current_date.strftime('%d.%m.%Y')}")

                # Проверяем просрочку
                if current_date.date() > expected_completion.date():
                    repair_delayed_info['is_delayed'] = True
                    print(f"DEBUG: Ремонт просрочен! ID={request_id}, дата={expected_completion_date}")
            except Exception as e:
                print(f"Ошибка при проверке просрочки: {e}")

    # Предлагаем выбрать тип ремонта с обычным форматом callback_data
    keyboard = [
        [InlineKeyboardButton("🛡️ Гарантийный ремонт", callback_data=f"warranty_yes_{request_id}")],
        [InlineKeyboardButton("💰 Не гарантийный ремонт", callback_data=f"warranty_no_{request_id}")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        "Выберите тип ремонта:",
        reply_markup=reply_markup
    )

    return CHOOSE_WARRANTY_TYPE

# Глобальная переменная для хранения информации о просрочке
repair_delayed_info = {}

async def handle_warranty_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка выбора типа ремонта (гарантийный/негарантийный)"""
    query = update.callback_query
    await query.answer()

    # Разбираем callback_data в старом формате
    data = query.data.split("_")
    is_warranty = data[1] == "yes"
    request_id = int(data[2])

    context.user_data['request_id'] = request_id
    context.user_data['is_warranty'] = is_warranty

    # Получаем информацию о просрочке из глобальной переменной
    global repair_delayed_info
    is_delayed = False
    expected_date = "нет данных"

    if repair_delayed_info.get('request_id') == request_id:
        is_delayed = repair_delayed_info.get('is_delayed', False)
        expected_date = repair_delayed_info.get('expected_date', "нет данных")
        context.user_data['is_delayed'] = is_delayed
        context.user_data['expected_completion_date'] = expected_date

    print(f"DEBUG: handle_warranty_choice - is_delayed={is_delayed}, expected_date={expected_date}")

    # Если ремонт задержан, запрашиваем причину
    if is_delayed:
        await query.edit_message_text(
            f"⚠️ Ремонт просрочен! Ожидаемая дата завершения была {expected_date}.\n\n"
            f"Пожалуйста, укажите причину задержки:"
        )
        return ENTER_DELAY_REASON
    else:
        # Если ремонт не задержан, завершаем процесс
        return await complete_repair_final(update, context)

async def handle_delay_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка причины задержки ремонта"""
    delay_reason = update.message.text
    context.user_data['delay_reason'] = delay_reason

    # Завершаем процесс ремонта
    return await complete_repair_final(update, context)

async def complete_repair_final(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Финальное завершение ремонта и уведомление пользователя"""
    request_id = context.user_data.get('request_id')
    is_warranty = context.user_data.get('is_warranty', False)
    delay_reason = context.user_data.get('delay_reason', None)

    # Получаем текущую дату и время
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Подключаемся к базе данных
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Обновляем запись в базе данных
    cursor.execute(
        """UPDATE repair_requests
           SET status='completed', completed_at=?, is_warranty=?, delay_reason=?
           WHERE id=?""",
        (current_time, 1 if is_warranty else 0, delay_reason, request_id)
    )
    conn.commit()

    # Получаем информацию о заявке
    cursor.execute("""
        SELECT rr.user_id, rr.estimated_price, u.first_name, u.last_name, b.name
        FROM repair_requests rr
        JOIN users u ON rr.user_id = u.id
        JOIN bikes b ON rr.bike_id = b.id
        WHERE rr.id=?
    """, (request_id,))

    result = cursor.fetchone()
    if result:
        user_id, price, first_name, last_name, bike_name = result
        formatted_price = format_rubles(price) if price else "не указана"
    else:
        user_id, formatted_price = None, "не указана"

    conn.close()

    # Определяем, была ли задержка
    delay_info = f"\n⚠️ Причина задержки: {delay_reason}" if delay_reason else ""

    # Определяем сообщение о типе ремонта
    warranty_info = "🛡️ Гарантийный ремонт" if is_warranty else "💰 Не гарантийный ремонт"

    # Отправляем сообщение администратору
    message_text = f"✅ Заявка на ремонт ID {request_id} завершена.\n{warranty_info}{delay_info}"

    if isinstance(update, Update) and update.callback_query:
        await update.callback_query.edit_message_text(message_text)
    else:
        await update.message.reply_text(message_text)

    # Уведомляем пользователя в зависимости от типа ремонта
    if user_id:
        if is_warranty:
            await context.bot.send_message(
                chat_id=user_id,
                text=(
                    "🛠️ Ремонт завершен. Спасибо за обращение!\n\n"
                    "🛡️ Ваш ремонт был выполнен по гарантии. Оплата не требуется.\n"
                    "❓ По всем вопросам обращайтесь к @Desscov."
                )
            )
        else:
            await context.bot.send_message(
                chat_id=user_id,
                text=(
                    "🛠️ Ремонт завершен. Спасибо за обращение!\n\n"
                    f"💳 Вам необходимо оплатить услуги ремонта. Сумма к оплате: {formatted_price}.\n"
                    "Для оплаты обратитесь к @BFbike."
                )
            )

        # Отправляем стикер пользователю
        await context.bot.send_sticker(
            chat_id=user_id,
            sticker="CAACAgIAAxkBAAELXWVneZ_El-AGf8unhOmOz5K34qS0iwACJBsAAn30iEmLH9JI8jo-cjYE"
        )

    # Обновляем список заявок
    if isinstance(update, Update) and update.callback_query:
        await view_repair_requests(update, context)

    return ConversationHandler.END

# Обновленная функция отметки заявки как оплаченной
async def mark_paid(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Функция для отметки ремонта как оплаченного с учетом гарантии"""
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[1])

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Проверяем, является ли ремонт гарантийным
    cursor.execute("SELECT is_warranty, user_id FROM repair_requests WHERE id=?", (request_id,))
    result = cursor.fetchone()
    is_warranty = result[0] if result else 0
    user_id = result[1] if result else None

    # Всегда обновляем статус заявки на oplacheno, независимо от типа
    cursor.execute("UPDATE repair_requests SET status='oplacheno' WHERE id=?", (request_id,))
    conn.commit()

    # Подготавливаем сообщение админу
    admin_message = f"✅ Заявка ID {request_id} отмечена оплаченной."
    if is_warranty:
        admin_message += " (Гарантийный ремонт)"

    # Для логирования и админа обрабатываем в любом случае
    cursor.execute("""
        SELECT
            u.first_name,
            u.last_name,
            b.name,
            rr.description,
            rr.estimated_price,
            rr.created_at,
            rr.bike_id
        FROM repair_requests rr
        JOIN users u ON rr.user_id = u.id
        JOIN bikes b ON rr.bike_id = b.id
        WHERE rr.id=?
    """, (request_id,))

    result = cursor.fetchone()
    first_name, last_name, bike_name, description, price, created_date, bike_id = result

    # Форматируем дату
    if '-' in created_date:
        date_obj = datetime.strptime(created_date, "%Y-%m-%d %H:%M:%S")
        formatted_date = date_obj.strftime("%d.%m.%y")
    else:
        formatted_date = created_date

    # Форматируем сумму
    formatted_price = format_rubles(price) if price else "не указана"

    # Логирование с датой в формате DD.MM.YY
    action_text = "Оплата ремонта" + (" (гарантийный)" if is_warranty else "")
    details = (
        f"📅 Дата: {formatted_date}\n"
        f"👤 Пользователь: {first_name} {last_name}\n"
        f"🚲 Велосипед: {bike_name}\n"
        f"📝 Проблема: {description}\n"
        f"💳 Сумма: {formatted_price}\n"
        f"🛡️ Гарантийный: {'Да' if is_warranty else 'Нет'}"
    )

    log_bike_action(
        bike_id=bike_id,
        user_id=user_id,
        action=action_text,
        details=details
    )

    # Уведомление админу
    await query.edit_message_text(admin_message)

    # Уведомление пользователю ТОЛЬКО если не гарантийный ремонт
    if not is_warranty and user_id:
        await context.bot.send_message(user_id, "🎉 Вы успешно оплатили ремонт! Удачных поездок!")
        await context.bot.send_sticker(user_id, sticker="CAACAgIAAxkBAAELuQ5ni347Uj7vYpmrUlRm0hMv-OuwRwACBBoAAqJdeUtq-6Jpx5iCFjYE")

    await view_repair_requests(update, context)
    conn.close()

WAITING_FOR_TIME, WAITING_FOR_PRICE = range(2)

async def accept_repair_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])
    context.user_data['request_id'] = request_id

    await query.edit_message_text("🕒 Введите примерное время выполнения работы (например, '2 часа' или '1 день'):")
    return WAITING_FOR_TIME

async def get_time(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка ввода времени выполнения ремонта с сохранением конкретной даты"""

    if 'awaiting_time_correction' not in context.user_data:
        await update.message.reply_text(
            "🕒 Введите дату завершения ремонта в формате ДД.ММ.ГГГГ, например:\n"
            "• 17.03.2025\n"
            "• 25.04.2025\n\n"
            "Либо укажите количество дней (например):\n"
            "• 1 день\n"
            "• 2 дня\n"
            "• 5 дней"
        )
        context.user_data['awaiting_time_correction'] = False
        return WAITING_FOR_TIME

    time_input = update.message.text.strip()

    # Проверяем на формат дней
    days_pattern = re.compile(r'^\d+\s+(день|дня|дней)$')
    # Проверяем на формат даты
    date_pattern = re.compile(r'^\d{2}\.\d{2}\.\d{4}$')

    current_date = datetime.now()

    if days_pattern.match(time_input):
        # Если ввод в формате "X дней"
        days = int(''.join(filter(str.isdigit, time_input)))

        # Рассчитываем дату завершения
        completion_date = current_date + timedelta(days=days)
        completion_date_str = completion_date.strftime("%d.%m.%Y")

        # Для отображения сохраняем оба формата
        context.user_data['time'] = time_input  # Для отображения в UI
        context.user_data['expected_completion_date'] = completion_date_str  # Для сохранения в БД

        time_message = f"{time_input} (до {completion_date_str})"

    elif date_pattern.match(time_input):
        # Если ввод уже в формате даты
        try:
            completion_date = datetime.strptime(time_input, "%d.%m.%Y")

            # Рассчитываем количество дней для отображения
            days_diff = (completion_date - current_date).days
            if days_diff < 1:
                days_diff = 1

            # Формируем правильное склонение слова "день"
            if days_diff % 10 == 1 and days_diff % 100 != 11:
                days_word = "день"
            elif 2 <= days_diff % 10 <= 4 and (days_diff % 100 < 10 or days_diff % 100 >= 20):
                days_word = "дня"
            else:
                days_word = "дней"

            time_string = f"{days_diff} {days_word}"

            # Сохраняем оба формата
            context.user_data['time'] = time_string  # Для отображения в UI
            context.user_data['expected_completion_date'] = time_input  # Для сохранения в БД

            time_message = f"{time_string} (до {time_input})"

        except ValueError:
            await update.message.reply_text("❌ Неверный формат даты. Используйте формат ДД.ММ.ГГГГ, например 17.03.2025")
            return WAITING_FOR_TIME

    else:
        await update.message.reply_text(
            "❌ Неверный формат. Введите дату в одном из форматов:\n"
            "• Конкретная дата (например, 17.03.2025)\n"
            "• Количество дней (например, 5 дней)"
        )
        return WAITING_FOR_TIME

    # Очищаем флаг коррекции
    if 'awaiting_time_correction' in context.user_data:
        del context.user_data['awaiting_time_correction']

    # Показываем информацию о сроке выполнения
    await update.message.reply_text(
        f"✅ Записана дата завершения: {time_message}\n\n"
        f"💵 Теперь введите примерную цену за работу (например, '1000 рублей'):"
    )

    return WAITING_FOR_PRICE

async def get_price(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Обработка ввода цены и сохранение заявки"""
    price = update.message.text
    request_id = context.user_data['request_id']
    time = context.user_data['time']  # Текстовое описание (например, "1 день")
    expected_completion_date = context.user_data.get('expected_completion_date', '') # Конкретная дата (например, "17.03.2025")

    # Форматируем цену с правильным склонением
    formatted_price = format_rubles(price)

    # Обновляем статус заявки на "accepted" и сохраняем время, цену и ожидаемую дату завершения
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute(
        """UPDATE repair_requests
           SET status='accepted', estimated_time=?, estimated_price=?, expected_completion_date=?
           WHERE id=?""",
        (time, price, expected_completion_date, request_id)
    )
    conn.commit()
    conn.close()

    # Формируем сообщение о сроках выполнения
    time_message = f"{time} (до {expected_completion_date})"

    # Уведомляем администратора
    await update.message.reply_text(
        f"✅ Заявка на ремонт ID {request_id} принята в работу.\n"
        f"🕒 Время: {time_message}\n"
        f"💵 Цена: {formatted_price}."
    )

    # Уведомляем пользователя
    user_id = get_user_id_by_request_id(request_id)
    await context.bot.send_message(
        chat_id=user_id,
        text=(
            f"🛠️ Ваша заявка на ремонт принята в работу.\n"
            f"🕒 Примерное время выполнения: {time_message}\n"
            f"💵 Примерная цена: {formatted_price}.\n\n"
            f"❓ По всем дополнительным вопросам обращайтесь в поддержку: @@BFbikechat."
        )
    )
    await context.bot.send_sticker(
        chat_id=user_id,
        sticker="CAACAgIAAxkBAAELuQ5ni347Uj7vYpmrUlRm0hMv-OuwRwACBBoAAqJdeUtq-6Jpx5iCFjYE"
    )
    await view_repair_requests(update, context)
    return ConversationHandler.END

def format_rubles(amount):
    if isinstance(amount, str):
        amount = int(''.join(filter(str.isdigit, amount)))  # Извлекаем число из строки
    last_digit = amount % 10
    last_two_digits = amount % 100

    if last_two_digits in [11, 12, 13, 14]:
        return f"{amount} рублей"
    elif last_digit == 1:
        return f"{amount} рубль"
    elif last_digit in [2, 3, 4]:
        return f"{amount} рубля"
    else:
        return f"{amount} рублей"

# Функция для получения user_id по request_id
def get_user_id_by_request_id(request_id):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT user_id FROM repair_requests WHERE id=?", (request_id,))
    user_id = cursor.fetchone()[0]
    conn.close()
    return user_id

async def delete_repair_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    request_id = int(query.data.split("_")[2])  # Получаем ID заявки

    # Удаляем заявку из базы данных
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM repair_requests WHERE id=?", (request_id,))
    conn.commit()
    conn.close()

    # Уведомляем пользователя
    await query.edit_message_text(f"🗑️ Заявка на ремонт ID {request_id} была успешно удалена.")
    await view_repair_requests(update, context)

async def pay_fine_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    fine_id = query.data.split("_")[2]
    user_id = query.from_user.id

    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT amount, reason FROM fines WHERE id = ? AND user_id = ? AND status != 'paid'
        """, (fine_id, user_id))
        fine = cursor.fetchone()

    if not fine:
        await query.message.reply_text("❌ Штраф не найден или уже оплачен")
        return

    amount_rub = int(fine[0])
    reason = fine[1] if fine[1] else "не указана"

    title = f"Штраф #{fine_id}"
    description = f"Оплата штрафа\nПричина: {reason}\nСумма: {amount_rub}₽"
    payload = f"fine_{fine_id}"

    if TEST_MODE:
        keyboard = [[
            InlineKeyboardButton(
                f"Тест: Оплатить {amount_rub} ₽",
                callback_data=f"mock_payment_{payload}_{amount_rub}"
            )
        ]]
        await query.message.reply_text(
            f"ТЕСТОВЫЙ РЕЖИМ\n\nТребуется оплата штрафа #{fine_id} на сумму {amount_rub} ₽.\nНажмите для имитации успешной оплаты.",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    else:
        prices = [LabeledPrice(label=f"Штраф #{fine_id}", amount=int(amount_rub * 100))]
        await context.bot.send_invoice(
            chat_id=user_id, title=title, description=description,
            payload=payload, provider_token=PROVIDER_TOKEN, currency="RUB", prices=prices,
            need_name=True, need_phone_number=True, send_phone_number_to_provider=True
        )

async def test_overdue_rental(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Тестовая функция для уменьшения даты окончания аренды и проверки начисления штрафов.
    """
    try:
        # Получаем пользователя и его ID
        user = update.effective_user
        if not user or user.is_bot:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="❌ Ошибка: боты не могут использовать эту функцию."
            )
            return
        user_id = user.id
        chat_id = update.effective_chat.id

        # Подключаемся к базе данных
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()

            # Получаем активные аренды пользователя
            cursor.execute("""
                SELECT b.id, b.end_date, bi.name
                FROM bookings b
                JOIN bikes bi ON b.bike_id = bi.id
                WHERE b.user_id = ? AND b.status = 'rented'
            """, (user_id,))
            rentals = cursor.fetchall()

            if not rentals:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="🚫 У вас нет активных аренд для тестирования."
                )
                return

            # Уменьшаем дату окончания аренды для первой аренды
            rental_id, old_end_date, bike_name = rentals[0]
            try:
                old_end_date_obj = datetime.strptime(old_end_date, "%d.%m.%Y")
                new_end_date_obj = old_end_date_obj - timedelta(days=5)  # Уменьшаем на 5 дней
                new_end_date = new_end_date_obj.strftime("%d.%m.%Y")

                # Обновляем дату в базе данных
                cursor.execute("""
                    UPDATE bookings
                    SET end_date = ?
                    WHERE id = ?
                """, (new_end_date, rental_id))
                conn.commit()

                await context.bot.send_message(
                    chat_id=chat_id,
                    text=(
                        f"🚴 Аренда велосипеда '{bike_name}' обновлена.\n"
                        f"Старая дата окончания: {old_end_date}\n"
                        f"Новая дата окончания: {new_end_date}"
                    )
                )
            except ValueError as e:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text=f"❌ Ошибка обработки даты: {e}"
                )
                return

            # Проверяем начисление штрафов
            await manage_bike(update, context)

    except Exception as e:
        logging.error(f"Ошибка в test_overdue_rental: {str(e)}")
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="❌ Произошла ошибка при тестировании. Попробуйте позже."
        )


from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CallbackContext, ConversationHandler


# Состояния для ConversationHandler
import sqlite3
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler, filters, MessageHandler, CallbackQueryHandler

# Define states
SELECTING_BIKE, SELECTING_ACTION, ENTERING_REPAIR_PERSON, ENTERING_REASON, ENTERING_WARRANTY, \
ENTERING_WARRANTY_AMOUNT, ENTERING_ESTIMATED_DATE, ENTERING_DELAY_REASON, SEARCHING = range(9)

# Database initialization
def init_db():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS bikes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            repair_status TEXT,
            repair_reason TEXT,
            repair_date TEXT,
            available INTEGER DEFAULT 1
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS repair_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            bike_id INTEGER,
            repair_start_date TEXT,
            repair_end_date TEXT,
            repair_person TEXT,
            reason TEXT,
            is_warranty INTEGER,
            warranty_amount REAL,
            estimated_completion_date TEXT,
            delay_reason TEXT,
            FOREIGN KEY (bike_id) REFERENCES bikes(id)
        )
    ''')
    conn.commit()
    conn.close()

# Repair menu
async def repair_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [
        ["🔧 Велосипеды в ремонте"],
        ["🚲 Рабочие велосипеды"],
        ["⚠️ Управление статусом"],
        ["🏠 Вернуться в главное меню"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text(
        "🔧 Меню управления ремонтом:\n\n"
        "Выберите нужное действие:",
        reply_markup=reply_markup
    )

# Show bikes by status
async def show_bikes_by_status(update: Update, context: ContextTypes.DEFAULT_TYPE, status: str) -> None:
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    if status == 'in_repair':
        cursor.execute('''
            SELECT name, repair_reason, repair_date
            FROM bikes
            WHERE repair_status = 'in_repair'
            ORDER BY repair_date DESC
        ''')
        message = "🔧 *Велосипеды в ремонте:*\n\n"
    else:
        cursor.execute('''
            SELECT name
            FROM bikes
            WHERE repair_status = 'working' OR repair_status IS NULL
            ORDER BY name
        ''')
        message = "✅ *Рабочие велосипеды:*\n\n"

    bikes = cursor.fetchall()
    conn.close()

    if not bikes:
        await update.message.reply_text(
            "📝 В данной категории нет велосипедов",
            parse_mode='Markdown'
        )
        return

    for bike in bikes:
        if status == 'in_repair':
            name, reason, date = bike
            message += f"🚲 *{name}*\n📝 Причина: _{reason}_\n📅 Дата: _{date}_\n\n"
        else:
            name = bike[0]
            message += f"🚲 *{name}*\n\n"

    await update.message.reply_text(message, parse_mode='Markdown')

BIKES_PER_PAGE = 5

async def show_bike_list(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    search_query = context.user_data.get('repair_search_query', '')
    page = context.user_data.get('repair_page', 0)

    keyboard = [[InlineKeyboardButton("🔍 Поиск", callback_data="repair_search")]]

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    query = '''
        SELECT id, name, repair_status, repair_reason, repair_date
        FROM bikes
        WHERE name LIKE ?
        ORDER BY name
    '''
    search_pattern = f'%{search_query}%' if search_query else '%'

    cursor.execute(f"SELECT COUNT(*) FROM bikes WHERE name LIKE ?", (search_pattern,))
    total_bikes = cursor.fetchone()[0]

    cursor.execute(query + ' LIMIT ? OFFSET ?', (search_pattern, BIKES_PER_PAGE, page * BIKES_PER_PAGE))
    bikes = cursor.fetchall()
    conn.close()

    for bike in bikes:
        bike_id, name, status, reason, date = bike
        status_emoji = "🔧" if status == "in_repair" else "✅"
        keyboard.append([InlineKeyboardButton(f"{status_emoji} {name}", callback_data=f"select_bike_{bike_id}")])

    pagination_buttons = []
    if page > 0:
        pagination_buttons.append(InlineKeyboardButton("⬅️", callback_data="remont_pagi_prev"))
    if (page + 1) * BIKES_PER_PAGE < total_bikes:
        pagination_buttons.append(InlineKeyboardButton("➡️", callback_data="remont_pagi_next"))

    if pagination_buttons:
        keyboard.append(pagination_buttons)
    keyboard.append([InlineKeyboardButton("Отмена", callback_data="cancel_repair")])

    reply_markup = InlineKeyboardMarkup(keyboard)

    message_text = "Выберите велосипед для управления статусом:"
    if search_query:
        message_text = f"🔍 Поиск: {search_query}\n\n" + message_text
    message_text += f"\n\nСтраница {page + 1} из {(total_bikes + BIKES_PER_PAGE - 1) // BIKES_PER_PAGE}"

    if update.callback_query:
        await update.callback_query.edit_message_text(message_text, reply_markup=reply_markup)
    else:
        await update.message.reply_text(message_text, reply_markup=reply_markup)

    return SELECTING_BIKE

async def handle_repair_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    action = query.data.split('_')[2]
    current_page = context.user_data.get('repair_page', 0)

    if action == 'prev' and current_page > 0:
        context.user_data['repair_page'] = current_page - 1
    elif action == 'next':
        context.user_data['repair_page'] = current_page + 1

    await show_bike_list(update, context)
    return SELECTING_BIKE

async def start_repair_search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    await query.edit_message_text(
        "Введите номер или название велосипеда для поиска:\nНапример: 00123 или Монстр"
    )
    return SEARCHING

async def handle_repair_search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    search_query = update.message.text
    context.user_data['repair_search_query'] = search_query
    context.user_data['repair_page'] = 0

    await show_bike_list(update, context)
    return SELECTING_BIKE

async def bike_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    bike_id = query.data.split('_')[2]
    context.user_data['selected_bike_id'] = bike_id

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('SELECT name, repair_status FROM bikes WHERE id = ?', (bike_id,))
    bike_name, repair_status = cursor.fetchone()
    conn.close()

    context.user_data['selected_bike_name'] = bike_name

    keyboard = []
    if repair_status == 'in_repair':
        keyboard.append([InlineKeyboardButton("✅ Убрать из ремонта", callback_data="set_working")])
    else:
        keyboard.append([InlineKeyboardButton("🔧 Отправить в ремонт", callback_data="set_repair")])
    keyboard.append([InlineKeyboardButton("Отмена", callback_data="cancel_repair")])

    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        f"Велосипед: *{bike_name}*\n"
        f"Текущий статус: {'🔧 В ремонте' if repair_status == 'in_repair' else '✅ Рабочий'}\n\n"
        "Выберите действие:",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    return SELECTING_ACTION

async def action_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    action = query.data
    bike_id = context.user_data['selected_bike_id']
    bike_name = context.user_data['selected_bike_name']

    if action == "set_repair":
        await query.edit_message_text("Введите имя мастера, который ставит велосипед в ремонт:")
        return ENTERING_REPAIR_PERSON
    elif action == "set_working":
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("SELECT id, estimated_completion_date FROM repair_logs WHERE bike_id = ? AND repair_end_date IS NULL", (bike_id,))
        repair_log = cursor.fetchone()
        if repair_log:
            repair_log_id, estimated_date = repair_log
            if estimated_date:
                estimated_date_obj = datetime.strptime(estimated_date, "%d.%m.%Y")
                if datetime.now() > estimated_date_obj:
                    context.user_data['repair_log_id'] = repair_log_id
                    await query.edit_message_text("Ремонт просрочен. Укажите причину задержки:")
                    return ENTERING_DELAY_REASON
            current_date = datetime.now().strftime("%d.%m.%Y")
            cursor.execute("UPDATE repair_logs SET repair_end_date = ? WHERE id = ?", (current_date, repair_log_id))
            cursor.execute("UPDATE bikes SET repair_status = 'working', repair_reason = NULL, repair_date = NULL, available = 1 WHERE id = ?", (bike_id,))
            conn.commit()
            conn.close()
            await query.edit_message_text(f"✅ Велосипед *{bike_name}* убран из ремонта и доступен для аренды.", parse_mode='Markdown')
            return ConversationHandler.END
        else:
            cursor.execute("UPDATE bikes SET repair_status = 'working', repair_reason = NULL, repair_date = NULL, available = 1 WHERE id = ?", (bike_id,))
            conn.commit()
            conn.close()
            await query.edit_message_text(f"✅ Велосипед *{bike_name}* убран из ремонта и доступен для аренды.", parse_mode='Markdown')
            return ConversationHandler.END
    return ConversationHandler.END

async def enter_repair_person(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    repair_person = update.message.text
    context.user_data['repair_person'] = repair_person
    await update.message.reply_text("Введите причину ремонта:")
    return ENTERING_REASON

async def enter_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reason = update.message.text
    context.user_data['reason'] = reason
    keyboard = [
        [InlineKeyboardButton("Да", callback_data="warranty_yes")],
        [InlineKeyboardButton("Нет", callback_data="warranty_no")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Это гарантийный ремонт?", reply_markup=reply_markup)
    return ENTERING_WARRANTY

async def enter_warranty(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    if query.data == "warranty_yes":
        context.user_data['is_warranty'] = True
        await query.edit_message_text("Введите сумму гарантийного ремонта:")
        return ENTERING_WARRANTY_AMOUNT
    else:
        context.user_data['is_warranty'] = False
        await query.edit_message_text("Введите предполагаемую дату завершения ремонта (формат ДД.ММ.ГГГГ):")
        return ENTERING_ESTIMATED_DATE

async def enter_warranty_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        amount = float(update.message.text)
        context.user_data['warranty_amount'] = amount
    except ValueError:
        await update.message.reply_text("Неверный формат суммы. Попробуйте еще раз:")
        return ENTERING_WARRANTY_AMOUNT
    await update.message.reply_text("Введите предполагаемую дату завершения ремонта (формат ДД.ММ.ГГГГ):")
    return ENTERING_ESTIMATED_DATE

async def enter_estimated_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    date_str = update.message.text
    try:
        datetime.strptime(date_str, "%d.%m.%Y")
        context.user_data['estimated_completion_date'] = date_str
    except ValueError:
        await update.message.reply_text("Неверный формат даты. Используйте ДД.ММ.ГГГГ. Попробуйте еще раз:")
        return ENTERING_ESTIMATED_DATE

    bike_id = context.user_data['selected_bike_id']
    repair_person = context.user_data['repair_person']
    reason = context.user_data['reason']
    is_warranty = context.user_data['is_warranty']
    warranty_amount = context.user_data.get('warranty_amount', None)
    estimated_completion_date = context.user_data['estimated_completion_date']
    current_date = datetime.now().strftime("%d.%m.%Y")

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO repair_logs (bike_id, repair_start_date, repair_person, reason, is_warranty, warranty_amount, estimated_completion_date)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    ''', (bike_id, current_date, repair_person, reason, 1 if is_warranty else 0, warranty_amount, estimated_completion_date))
    cursor.execute('''
        UPDATE bikes
        SET repair_status = 'in_repair',
            repair_reason = ?,
            repair_date = ?,
            available = 0
        WHERE id = ?
    ''', (reason, current_date, bike_id))
    conn.commit()
    conn.close()

    await update.message.reply_text(f"🔧 Велосипед *{context.user_data['selected_bike_name']}* отправлен в ремонт.", parse_mode='Markdown')
    return ConversationHandler.END

async def enter_delay_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    delay_reason = update.message.text
    repair_log_id = context.user_data['repair_log_id']
    bike_id = context.user_data['selected_bike_id']
    current_date = datetime.now().strftime("%d.%m.%Y")

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        UPDATE repair_logs
        SET repair_end_date = ?, delay_reason = ?
        WHERE id = ?
    ''', (current_date, delay_reason, repair_log_id))
    cursor.execute('''
        UPDATE bikes
        SET repair_status = 'working',
            repair_reason = NULL,
            repair_date = NULL,
            available = 1
        WHERE id = ?
    ''', (bike_id,))
    conn.commit()
    conn.close()

    await update.message.reply_text(f"✅ Велосипед *{context.user_data['selected_bike_name']}* убран из ремонта и доступен для аренды. Причина задержки сохранена.", parse_mode='Markdown')
    return ConversationHandler.END

async def cancel_repair(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if 'repair_search_query' in context.user_data:
        del context.user_data['repair_search_query']
    if 'repair_page' in context.user_data:
        del context.user_data['repair_page']

    query = update.callback_query
    if query:
        await query.answer()
        await query.edit_message_text("❌ Операция отменена")
    else:
        await update.message.reply_text("❌ Операция отменена")
    return ConversationHandler.END

def is_reject_reason_active(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    return "reject_fine_id" in context.user_data

import random
import asyncio
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
STICKER_START = "CAACAgIAAxkBAAEL6XZnlAkkoS8cKLZfu0mxWFBrXvZMAQACCQADiITmDeOD1Vb1d_1DNgQ"
STICKER_END = "CAACAgIAAxkBAAEL6XRnlAi4AAGUWN8UFTlrn6SQ0_E9HhEAAngAA-2rdw9CYfrbqrz0WjYE"
# Константы игры
GRID_SIZE = 10
CELL_EMPTY = '▪️'
CELL_HEAD = '🐉'
CELL_FOOD = '🍓'
BORDER_TOP = '⬛️' * (GRID_SIZE + 2)
BORDER_SIDE = '⬛️'

DIRECTIONS = {
    'up': (0, -1),
    'down': (0, 1),
    'left': (-1, 0),
    'right': (1, 0)
}

def init_game_state():
    return {
        'snake': [(GRID_SIZE//2, GRID_SIZE//2)],
        'direction': 'right',
        'food': None,
        'score': 0,
        'is_running': False,
        'message_id': None,
        'task': None,
        'reply_markup': None,
    }

def generate_food(snake):
    free_cells = [ (x,y) for x in range(GRID_SIZE)
                  for y in range(GRID_SIZE) if (x,y) not in snake]
    return random.choice(free_cells) if free_cells else None

def render_grid(snake, food):
    grid = [BORDER_TOP]
    for y in range(GRID_SIZE):
        row = [BORDER_SIDE]
        for x in range(GRID_SIZE):
            if (x, y) == food: row.append(CELL_FOOD)
            elif (x, y) == snake[0]: row.append(CELL_HEAD)
            elif (x, y) in snake: row.append('🟩' if (x+y)%2 else '🟢')
            else: row.append(CELL_EMPTY)
        grid.append(f'{BORDER_SIDE}{"".join(row)}{BORDER_SIDE}')
    grid.append(BORDER_TOP)
    return '\n'.join(grid)

async def start_snake(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Отправляем стартовый стикер
    await context.bot.send_sticker(
        chat_id=update.effective_chat.id,
        sticker=STICKER_START
    )

    user_data = context.user_data
    if user_data.get('snake_game', {}).get('is_running'):
        await update.message.reply_text("Игра уже запущена! 🐍")
        return

    game = init_game_state()
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(d, callback_data=f'snake_{d}') for d in ('up', 'down')],
        [InlineKeyboardButton(d, callback_data=f'snake_{d}') for d in ('left', 'right')],
        [InlineKeyboardButton("💀 Завершить", callback_data='snake_exit')]
    ])
    game.update({
        'food': generate_food(game['snake']),
        'is_running': True,
        'reply_markup': keyboard
    })
    user_data['snake_game'] = game

    msg = await update.message.reply_text(
        f"Счет: 0\n{render_grid(game['snake'], game['food'])}",
        reply_markup=game['reply_markup']
    )
    game['message_id'] = msg.message_id
    game['task'] = asyncio.create_task(snake_loop(update, context))

async def snake_loop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    game = context.user_data.get('snake_game')
    if not game:
        return

    chat_id = update.effective_chat.id
    message_id = game['message_id']

    while game['is_running']:
        await asyncio.sleep(0.7)  # Увеличенный интервал для уменьшения нагрузки

        # Получаем текущее направление и новую позицию головы
        head = game['snake'][0]
        dx, dy = DIRECTIONS[game['direction']]
        new_head = (head[0] + dx, head[1] + dy)

        # Проверка на столкновение со стеной или с собой
        if (new_head in game['snake']
            or not (0 <= new_head[0] < GRID_SIZE)
            or not (0 <= new_head[1] < GRID_SIZE)):
            await game_over(context, chat_id, message_id, "Игра окончена! 💀")
            return

        # Двигаем змейку
        game['snake'].insert(0, new_head)
        if new_head == game['food']:
            game['score'] += 1
            game['food'] = generate_food(game['snake'])
        else:
            game['snake'].pop()

        # Обновляем отображение с сохранением клавиатуры
        try:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=f"Счет: {game['score']}\n{render_grid(game['snake'], game['food'])}",
                reply_markup=game['reply_markup']  # Клавиатура сохраняется
            )
        except Exception as e:
            logging.error(f"Ошибка обновления: {e}")
            await game_over(context, chat_id, message_id, "Ошибка обновления игры 😢")
            return

async def handle_controls(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    game = context.user_data.get('snake_game')
    if not game or not game['is_running']: return

    if query.data == 'snake_exit':
        await game_over(context, query.message.chat_id, query.message.message_id, "Игра прервана")
        return

    new_dir = query.data.split('_')[1]
    current = game['direction']
    opposite = {'up':'down', 'down':'up', 'left':'right', 'right':'left'}

    if new_dir != opposite[current]:
        game['direction'] = new_dir

async def game_over(context, chat_id, message_id, reason):
    game = context.user_data.get('snake_game')
    if not game:
        return

    # Останавливаем игру
    game['is_running'] = False

    # Формируем финальное сообщение
    final_text = (
        f"🏁 {reason}\n"
        f"══════════════\n"
        f"🏆 Финальный счет: {game['score']}\n"
        f"🐍 Длина змеи: {len(game['snake'])}\n"
        f"🍓 Съедено ягод: {game['score']}\n"
        f"══════════════\n"
        "Спасибо за игру! 🎮"
    )

    try:
        # Убираем клавиатуру только при завершении игры
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=final_text,
            reply_markup=None  # Явное удаление клавиатуры
        )
    except Exception as e:
        # Если не удалось отредактировать сообщение, отправляем новое
        logging.error(f"Ошибка завершения игры: {e}")
        await context.bot.send_message(
            chat_id=chat_id,
            text=final_text,
            reply_markup=None
        )

    # Отправляем финальный стикер
    await context.bot.send_sticker(
        chat_id=chat_id,
        sticker=STICKER_END
    )

    # Очищаем состояние игры
    if 'snake_game' in context.user_data:
        del context.user_data['snake_game']


# Состояния для диалогов
WAITING_FOR_TIME, WAITING_FOR_PRICE = range(2)
# Новые состояния для гарантийного ремонта и задержки
CHOOSE_WARRANTY_TYPE, ENTER_DELAY_REASON = range(2)



async def morning_reminder(context):
    admin_id = "6493147878"  # Замените на ID администратора
    morning_message = "Утренний чек-лист:\n- Проверить АКБ\n- Проверить чистоту рабочего места\n- Проверить отчет бота\n- Инвентаризация велосипедов\n- Проверить чистоту велосипедов"
    await context.bot.send_message(chat_id=admin_id, text=morning_message)

async def evening_reminder(context):
    manager_id = "752012766"  # Замените на ID менеджера
    evening_message = "До конца смены остался час. Не забудь:\n- Заполнить данные в боте\n- Прибраться на рабочем месте"
    await context.bot.send_message(chat_id=manager_id, text=evening_message)

async def send_test_notification(update, context):
    chat_id = update.effective_chat.id
    test_message = "Это тестовое уведомление! Система оповещений работает корректно."
    await context.bot.send_message(chat_id=chat_id, text=test_message)

    # Сообщение об успешной отправке
    await update.message.reply_text("Тестовое уведомление отправлено успешно!")

WAITING_FOR_ADMIN_MESSAGE = 100
async def smska_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Запускает процесс отправки сообщения администраторам."""
    await update.message.reply_text(
        "Введите сообщение, которое нужно отправить всем администраторам:"
    )
    return WAITING_FOR_ADMIN_MESSAGE

async def send_message_to_admins(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отправляет введенное сообщение всем администраторам."""
    message_text = update.message.text
    user = update.effective_user

    # Формируем текст сообщения с информацией об отправителе
    admin_message = f"📩 Сообщение от пользователя {user.full_name} (ID: {user.id}):\n\n{message_text}"

    # Счетчик успешно отправленных сообщений
    sent_count = 0

    # Отправляем сообщение каждому администратору
    for admin_id in ADMIN_IDS:
        try:
            await context.bot.send_message(chat_id=admin_id, text=admin_message)
            sent_count += 1
        except Exception as e:
            # Логируем ошибку, если сообщение не удалось отправить
            print(f"Ошибка при отправке сообщения администратору {admin_id}: {e}")

    # Отправляем пользователю информацию о результате
    await update.message.reply_text(
        f"Ваше сообщение отправлено {sent_count} из {len(ADMIN_IDS)} администраторов."
    )

    return ConversationHandler.END

# ВСТАВЬТЕ ВЕСЬ ЭТОТ БЛОК КОДА НА МЕСТО УДАЛЕННЫХ ФУНКЦИЙ

# --- НОВАЯ УНИВЕРСАЛЬНАЯ ЛОГИКА ДОБАВЛЕНИЯ ТОВАРОВ ---



# ==============================================================================
# НАЧАЛО БЛОКА: УНИВЕРСАЛЬНЫЙ МОДУЛЬ ДОБАВЛЕНИЯ ТОВАРОВ
# (Полностью заменяет старые add_part_handler и add_product_handler)
# ==============================================================================

import sqlite3
import json
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler

# --- Новые, расширенные состояния для диалога ---
(
    SELECT_PRODUCT_TYPE, 
    ENTER_NAME, 
    ENTER_DESCRIPTION, 
    AWAIT_PHOTO, 
    ENTER_QUANTITY,
    # Новые состояния для велосипеда
    ENTER_RENT_PRICES,
    ENTER_BUYOUT_TOTAL_PAYMENTS,
    ENTER_BUYOUT_PAYMENT_AMOUNT,
    ENTER_BUYOUT_PERIOD_DAYS,
    # Старое состояние для АКБ
    ENTER_BATTERY_DETAILS 
) = range(800, 810) # Используем новый диапазон для избежания конфликтов

async def start_add_product(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 1: Спрашивает тип товара."""
    user_id = update.message.from_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 У вас нет прав для этой команды.")
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton("🚲 Велосипед", callback_data=f"add_type_{PRODUCT_TYPE_BIKE}")],
        [InlineKeyboardButton("🔋 Аккумулятор", callback_data=f"add_type_{PRODUCT_TYPE_BATTERY}")],
        [InlineKeyboardButton("❌ Отмена", callback_data="add_type_cancel")]
    ]
    await update.message.reply_text("Выберите тип товара:", reply_markup=InlineKeyboardMarkup(keyboard))
    return SELECT_PRODUCT_TYPE

async def select_product_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 2: Сохраняет тип и запрашивает название."""
    query = update.callback_query
    await query.answer()
    product_type = query.data.split('_')[-1]
    if product_type == 'cancel':
        await query.edit_message_text("Добавление отменено.")
        context.user_data.clear()
        return ConversationHandler.END

    context.user_data['product_type'] = product_type
    type_rus = "велосипеда" if product_type == PRODUCT_TYPE_BIKE else "аккумулятора"
    await query.edit_message_text(f"Введите название/модель {type_rus}:")
    return ENTER_NAME

async def get_product_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 3: Сохраняет название, запрашивает описание."""
    context.user_data['name'] = update.message.text
    await update.message.reply_text("Введите описание товара:")
    return ENTER_DESCRIPTION

async def get_product_description(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 4: Сохраняет описание и решает, что делать дальше."""
    context.user_data['description'] = update.message.text
    product_type = context.user_data.get('product_type')

    if product_type == PRODUCT_TYPE_BIKE:
        await update.message.reply_text(
            "💰 *Тарифы аренды*\n\n"
            "Введите цены для аренды на *7, 14 и 30 дней* через пробел.\n\n"
            "*Пример:* `3500 6500 12000`",
            parse_mode="Markdown"
        )
        return ENTER_RENT_PRICES
    else: # Для аккумулятора
        await update.message.reply_text("Введите характеристики в формате 'Напряжение,Емкость' (Пример: 60V,21Ah):")
        return ENTER_BATTERY_DETAILS

# --- Функции для ветки ВЕЛОСИПЕДА ---

async def get_rent_prices(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 5 (Велосипед): Принимает цены аренды, запрашивает план выкупа."""
    try:
        prices = [float(p) for p in update.message.text.split()]
        if len(prices) != 3: raise ValueError
        context.user_data['rent_prices'] = prices
    except ValueError:
        await update.message.reply_text("❌ Ошибка. Введите *3 числа* через пробел. Попробуйте снова.", parse_mode="Markdown")
        return ENTER_RENT_PRICES

    await update.message.reply_text(
        "💰 *План выкупа*\n\n"
        "Введите *общее количество* платежей для полного выкупа:",
        parse_mode="Markdown"
    )
    return ENTER_BUYOUT_TOTAL_PAYMENTS

async def get_buyout_total_payments(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 6 (Велосипед): Принимает кол-во платежей, запрашивает сумму."""
    try:
        context.user_data['buyout_total_payments'] = int(update.message.text)
        await update.message.reply_text("Теперь введите *сумму одного* платежа в рублях:")
        return ENTER_BUYOUT_PAYMENT_AMOUNT
    except ValueError:
        await update.message.reply_text("❌ Введите целое число.")
        return ENTER_BUYOUT_TOTAL_PAYMENTS

async def get_buyout_payment_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 7 (Велосипед): Принимает сумму, запрашивает периодичность."""
    try:
        context.user_data['buyout_payment_amount'] = float(update.message.text)
        await update.message.reply_text("Введите *периодичность* платежей в днях (например, `7` для еженедельных):")
        return ENTER_BUYOUT_PERIOD_DAYS
    except ValueError:
        await update.message.reply_text("❌ Введите корректную сумму.")
        return ENTER_BUYOUT_PAYMENT_AMOUNT

async def get_buyout_period(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 8 (Велосипед): Принимает период, запрашивает количество."""
    try:
        context.user_data['buyout_period_days'] = int(update.message.text)
        await update.message.reply_text("🔢 Отлично! Теперь введите, сколько велосипедов этой модели вы добавляете:")
        return ENTER_QUANTITY
    except ValueError:
        await update.message.reply_text("❌ Введите целое число дней.")
        return ENTER_BUYOUT_PERIOD_DAYS

# --- Функции для ветки АККУМУЛЯТОРА ---

async def get_battery_details(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 5 (АКБ): Принимает детали, запрашивает количество."""
    try:
        voltage, capacity = update.message.text.split(',')
        context.user_data['details_json'] = json.dumps({"voltage": voltage.strip(), "capacity": capacity.strip()})
        await update.message.reply_text("🔢 Введите количество аккумуляторов:")
        return ENTER_QUANTITY
    except ValueError:
        await update.message.reply_text("Неверный формат. Пример: 60V,21Ah")
        return ENTER_BATTERY_DETAILS

# --- Общие финальные функции ---

async def get_product_quantity(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Шаг 9 (Общий): Принимает количество, запрашивает фото."""
    try:
        quantity = int(update.message.text)
        if quantity <= 0: raise ValueError
        context.user_data['quantity'] = quantity
        await update.message.reply_text("📸 Отправьте фотографию для этой модели:")
        return AWAIT_PHOTO
    except ValueError:
        await update.message.reply_text("🚫 Введите корректное количество (целое положительное число).")
        return ENTER_QUANTITY

async def finalize_product_add(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ФИНАЛ: Принимает фото и сохраняет все в БД."""
    if not update.message.photo:
        await update.message.reply_text("🚫 Пожалуйста, отправьте фотографию.")
        return AWAIT_PHOTO

    photo_id = update.message.photo[-1].file_id
    data = context.user_data
    product_type = data.get('product_type')
    quantity = data.get('quantity', 1)

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    try:
        for _ in range(quantity):
            if product_type == PRODUCT_TYPE_BIKE:
                cursor.execute(
                    """INSERT INTO bikes (name, description, photo_url, type, available, 
                                       rent_price_7d, rent_price_14d, rent_price_30d, 
                                       buyout_total_payments, buyout_payment_amount, buyout_period_days)
                       VALUES (?, ?, ?, ?, 1, ?, ?, ?, ?, ?, ?)""",
                    (
                        data['name'], data['description'], photo_id, product_type,
                        data['rent_prices'][0], data['rent_prices'][1], data['rent_prices'][2],
                        data['buyout_total_payments'], data['buyout_payment_amount'], data['buyout_period_days']
                    )
                )
            else: # Аккумулятор
                cursor.execute(
                    """INSERT INTO bikes (name, description, photo_url, type, details_json, available)
                       VALUES (?, ?, ?, ?, ?, 1)""",
                    (data['name'], data['description'], photo_id, product_type, data.get('details_json'))
                )
        conn.commit()
        type_rus = "Велосипеды" if product_type == PRODUCT_TYPE_BIKE else "Аккумуляторы"
        await update.message.reply_text(f"✅ Успешно! {type_rus} '{data['name']}' ({quantity} шт.) добавлены.")
    
    except Exception as e:
        logger.error(f"Ошибка при добавлении товара в БД: {e}", exc_info=True)
        await update.message.reply_text(f"❌ Произошла ошибка при сохранении в базу данных: {e}")
    finally:
        conn.close()
        context.user_data.clear()
        return ConversationHandler.END

async def cancel_add_product(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет диалог."""
    if update.callback_query:
        await update.callback_query.edit_message_text("Добавление отменено.")
    else:
        await update.message.reply_text("Добавление отменено.")
    context.user_data.clear()
    return ConversationHandler.END

# ==============================================================================
# КОНЕЦ БЛОКА
# ==============================================================================
def get_payment_suffix(count):
    """Возвращает правильное окончание для слова 'платеж'."""
    if count % 10 == 1 and count % 100 != 11:
        return "платеж"
    elif 2 <= count % 10 <= 4 and (count % 100 < 10 or count % 100 >= 20):
        return "платежа"
    else:
        return "платежей"

async def abort_smska(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отменяет отправку сообщения."""
    await update.message.reply_text("Отправка сообщения отменена.")
    return ConversationHandler.END

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ admin_approve_deal НА ЭТУ ВЕРСИЮ

# ПОЛНОСТЬЮ ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ

# ШАГ 2: ПОЛНОСТЬЮ ЗАМЕНИТЕ ЭТУ ФУНКЦИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ admin_approve_deal НА ЭТУ ВЕРСИЮ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ admin_approve_deal НА ЭТУ ВЕРСИЮ

# Убедитесь, что все эти импорты у вас есть в начале файла
import aiosqlite
import json
import os
from datetime import datetime
import asyncio
import random
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, LabeledPrice
from telegram.ext import ContextTypes

# ==============================================================================
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ ADMIN_APPROVE_DEAL НА ЭТУ ВЕРСИЮ
# ==============================================================================

import aiosqlite
import json
import os
import asyncio
import random
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
from telegram.ext import ContextTypes, ConversationHandler

# Убедитесь, что эти функции уже определены в вашем коде:
# async def generate_contract_docx(...) -> str: ...
# async def client_handle_signature(...) -> int: ...
# def parse_bike_name_and_vin(full_name: str) -> dict: ...

async def admin_approve_deal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    УНИВЕРСАЛЬНАЯ И ПОЛНАЯ ФУНКЦИЯ ОБРАБОТКИ ЗАЯВОК:
    1.  Запускается по кнопке "Обработать заявку".
    2.  Пошагово опрашивает администратора о количестве и номерах батарей.
    3.  Получает ИНДИВИДУАЛЬНЫЕ тарифы (аренда/выкуп) из базы данных для конкретного велосипеда.
    4.  Формирует данные для договора и счета на основе этих тарифов.
    5.  Вызывает функцию `generate_contract_docx` для создания документа.
    6.  Отправляет договор клиенту на подпись (акцепт).
    7.  Уведомляет администратора об успешной отправке.
    """
    user_data = context.user_data
    
    # --- Шаг 1: Админ нажал кнопку "Обработать заявку" ---
    if update.callback_query:
        query = update.callback_query
        await query.answer()
        
        # Очищаем user_data от предыдущих сессий
        user_data.clear()
        
        booking_id = int(query.data.split('_')[1])
        user_data['processing_booking_id'] = booking_id
        
        await query.edit_message_text(
            f"⚙️ Обработка заявки #{booking_id}.\n\n"
            "Введите количество батарей, которые выдаются с велосипедом (например, 1 или 2):"
        )
        # Устанавливаем флаг, что бот ожидает ответа от админа
        user_data['awaiting_admin_input'] = 'battery_count'
        return # Выходим, ждем ответа админа

    # --- Шаги 2 и 3: Админ прислал текстовый ответ (количество или номера батарей) ---
    elif update.message and user_data.get('awaiting_admin_input'):
        
        # Шаг 2: Обрабатываем количество батарей
        if user_data['awaiting_admin_input'] == 'battery_count':
            try:
                count = int(update.message.text.strip())
                if not (0 <= count <= 4): raise ValueError
                user_data['battery_count'] = count
            except ValueError:
                await update.message.reply_text("❌ Введите корректное число от 0 до 4.")
                return # Остаемся в том же состоянии

            if count == 0:
                user_data['battery_numbers'] = []
                await update.message.reply_text("⏳ Батарей нет. Генерирую договор и счет...")
                del user_data['awaiting_admin_input'] # Завершаем опрос
            else:
                await update.message.reply_text(f"✍️ Отлично. Теперь введите серийные номера для {count} батарей, каждый с новой строки:")
                user_data['awaiting_admin_input'] = 'battery_numbers'
                return # Выходим, ждем следующего ответа

        # Шаг 3: Обрабатываем номера батарей
        elif user_data['awaiting_admin_input'] == 'battery_numbers':
            battery_numbers_text = update.message.text or ""
            battery_numbers = [num.strip() for num in battery_numbers_text.strip().split('\n') if num.strip()]
            required_count = user_data.get('battery_count', 0)

            if len(battery_numbers) != required_count:
                await update.message.reply_text(f"❌ Ошибка: вы ввели {len(battery_numbers)} номеров, а нужно было {required_count}. Попробуйте снова:")
                return # Остаемся в том же состоянии
            
            user_data['battery_numbers'] = battery_numbers
            await update.message.reply_text("✅ Все данные собраны. Генерирую договор и выставляю счет...")
            del user_data['awaiting_admin_input'] # Завершаем опрос

    # --- Шаг 4: ФИНАЛЬНАЯ ЛОГИКА (генерация и отправка) ---
    # Этот блок кода выполнится только после того, как все данные от админа будут собраны
    
    booking_id = user_data.get('processing_booking_id')
    if not booking_id: 
        # Предотвращаем выполнение, если что-то пошло не так
        return

    admin_chat_id = update.effective_chat.id
    battery_count = user_data.get('battery_count', 0)
    battery_numbers = user_data.get('battery_numbers', [])

    try:
        # --- Сбор всех необходимых данных из БД одним запросом ---
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute(
                """SELECT 
                       b.user_id, b.bike_id, b.end_date, b.booking_date, b.booking_type,
                       u.phone_number, u.passport_data, u.first_name, u.last_name,
                       m.name as model_name,
                       m.rent_price_7d, m.rent_price_14d, m.rent_price_30d,
                       m.buyout_total_payments, m.buyout_payment_amount, m.buyout_period_days
                   FROM bookings b
                   JOIN users u ON b.user_id = u.id
                   JOIN bikes m ON b.bike_id = m.id
                   WHERE b.id=?
                """, (booking_id,)
            )
            data = await cursor.fetchone()

        if not data: 
            raise ValueError(f"Заявка #{booking_id} не найдена или уже обработана.")

        booking_type = data['booking_type']
        
        # --- Подготовка словарей с данными для генератора договора ---
        passport_data = json.loads(data['passport_data']) if data and data['passport_data'] else {}
        user_data_for_doc = {
            'full_name': f"{passport_data.get('Фамилия', '')} {passport_data.get('Имя', '')} {passport_data.get('Отчество', '')}".strip(),
            'ending': 'ый' if passport_data.get('Пол', '').upper().startswith('МУЖ') else 'ая',
            'passport_series': passport_data.get('Серия и номер паспорта', '____ ______').split(' ')[0],
            'passport_number': passport_data.get('Серия и номер паспорта', '____ ______').split(' ')[-1],
            'passport_issued_by': passport_data.get('Кем выдан', '_________________'),
            'address': passport_data.get('Адрес регистрации', '_________________'),
            'initials': f"{passport_data.get('Фамилия', ' ')} {passport_data.get('Имя', ' ')[0]}.{passport_data.get('Отчество', ' ')[0]}."
        }
        
        parsed_bike_info = parse_bike_name_and_vin(data['model_name'])
        bike_data_for_doc = {
            'model': parsed_bike_info['model'], 
            'vin': parsed_bike_info['vin'],
            'batteries_count': str(battery_count), 
            'battery_numbers': battery_numbers
        }
        
        deal_info_for_doc = {}

        # --- Логика получения тарифов напрямую из данных велосипеда ---
        if booking_type == 'rent':
            days = (datetime.strptime(data['end_date'], '%d.%m.%Y') - datetime.strptime(data['booking_date'], '%d.%m.%Y')).days
            price_to_pay = data[f'rent_price_{days}d']
            if price_to_pay is None or price_to_pay <= 0: 
                raise ValueError(f"Для велосипеда ID {data['bike_id']} не установлена цена на {days} дней.")
            deal_info_for_doc = {'price': int(price_to_pay)}

        elif booking_type == 'buyout':
            price_to_pay = data['buyout_payment_amount']
            total_payments = data['buyout_total_payments']
            if not price_to_pay or price_to_pay <= 0 or not total_payments or total_payments <= 0:
                raise ValueError(f"Для велосипеда ID {data['bike_id']} не настроен план выкупа.")
                
            deal_info_for_doc = {
                'total_price': int(total_payments * price_to_pay),
                'weekly_payment': int(price_to_pay),
                'weeks_count': int(total_payments),
            }
        else:
            raise ValueError(f"Неизвестный тип сделки: {booking_type}")
            
        # --- Генерация и отправка договора ---
        file_path = generate_contract_docx(
            booking_id=booking_id, deal_type=booking_type, deal_data=deal_info_for_doc,
            user_data=user_data_for_doc, bike_data=bike_data_for_doc
        )
        
        # Отправка копии админу
        with open(file_path, 'rb') as doc_file:
            await context.bot.send_document(admin_chat_id, doc_file, caption=f"Копия договора для заявки #{booking_id}")
        
        user_id = data['user_id']
        keyboard_client = [[
            InlineKeyboardButton("✅ Принимаю и подписываю", callback_data=f"client_sign_{booking_id}"),
            InlineKeyboardButton("❌ Отказаться", callback_data=f"client_decline_{booking_id}")
        ]]
        caption_for_client = (
            "Пожалуйста, ознакомьтесь с договором.\n\n"
            "⚠️ Нажатие кнопки «Принимаю и подписываю» ниже является полным и безоговорочным принятием (акцептом) "
            "всех условий договора и равносильно его подписанию."
        )
        
        # Отправка договора клиенту
        with open(file_path, 'rb') as doc_file:
            await context.bot.send_document(
                chat_id=user_id, 
                document=doc_file, 
                caption=caption_for_client, 
                reply_markup=InlineKeyboardMarkup(keyboard_client)
            )
        
        # Удаляем временный файл
        os.remove(file_path)

        await context.bot.send_message(admin_chat_id, f"✅ Договор для заявки #{booking_id} с индивидуальными тарифами отправлен клиенту для акцепта.")

    except Exception as e:
        logger.error(f"Критическая ошибка в admin_approve_deal: {e}", exc_info=True)
        await context.bot.send_message(admin_chat_id, f"❌ Произошла ошибка при обработке заявки: {e}")
    finally:
        # Очищаем user_data после завершения операции
        user_data.clear()
# ШАГ 3 ИСПРАВЛЕННЫЙ: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ client_handle_signature НА ЭТУ
from telegram import BotCommand, BotCommandScopeChat, BotCommandScopeDefault

async def post_init(application: Application):
    """Выполняется после инициализации бота для настройки команд."""
    
    # --- Команды для ОБЫЧНЫХ ПОЛЬЗОВАТЕЛЕЙ ---
    default_commands = [
        BotCommand("start", "🚀 Перезапустить бота / Главное меню")
    ]
    await application.bot.set_my_commands(default_commands, scope=BotCommandScopeDefault())
    logger.info("Стандартные команды для пользователей установлены.")

    # --- Команды ТОЛЬКО ДЛЯ АДМИНОВ ---
    admin_commands = [
        BotCommand("start", "🚀 Перезапустить бота / Главное меню"),
        BotCommand("cancel", "❌ Отменить текущее действие"), # <-- ДОБАВЛЕНА НОВАЯ КОМАНДА
        BotCommand("edit_user", "👤 Редактировать профиль пользователя"),
        BotCommand("smska", "📨 Отправить сообщение админам")
    ]
    
    for admin_id in ADMIN_IDS:
        try:
            await application.bot.set_my_commands(admin_commands, scope=BotCommandScopeChat(chat_id=admin_id))
            logger.info(f"Админские команды установлены для ID: {admin_id}")
        except Exception as e:
            logger.error(f"Не удалось установить команды для админа {admin_id}: {e}")

# ==============================================================================
#           НОВЫЙ МОДУЛЬ: ЕЖЕДНЕВНЫЕ УВЕДОМЛЕНИЯ ОБ ОПЛАТЕ
# ==============================================================================

async def check_payment_reminders(context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Ежедневно в 20:00 МСК проверяет все активные сделки:
    - Уведомляет клиентов и админов о платежах, до которых осталось <= 3 дня.
    - Уведомляет клиентов и админов о просроченных платежах.
    """
    logging.info("🚀 [ЕЖЕДНЕВНАЯ ПРОВЕРКА] Запуск проверки сроков оплаты...")
    
    # Вспомогательная функция для правильного склонения слова "день"
    def get_day_suffix(days: int) -> str:
        days = abs(days)
        if days % 10 == 1 and days % 100 != 11:
            return "день"
        elif 2 <= days % 10 <= 4 and (days % 100 < 10 or days % 100 >= 20):
            return "дня"
        return "дней"

    admin_reminders = []  # Список для уведомлений админам о скорых оплатах
    admin_overdue = []    # Список для уведомлений админам о просрочках

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            cursor = await conn.execute("""
                SELECT 
                    b.user_id, b.booking_type, b.end_date, b.next_payment_date,
                    u.first_name, u.last_name,
                    bk.name as bike_name
                FROM bookings b
                JOIN users u ON b.user_id = u.id
                JOIN bikes bk ON b.bike_id = bk.id
                WHERE b.status = 'rented'
            """)
            active_deals = await cursor.fetchall()
        
        logging.info(f"[ПРОВЕРКА] Найдено {len(active_deals)} активных сделок.")
        today = datetime.now().date()

        for deal in active_deals:
            relevant_date_str = None
            deal_type_rus = ""
            
            if deal['booking_type'] == 'rent':
                relevant_date_str = deal['end_date']
                deal_type_rus = "аренды"
            elif deal['booking_type'] == 'buyout':
                relevant_date_str = deal['next_payment_date']
                deal_type_rus = "платежа по выкупу"

            if not relevant_date_str:
                continue

            try:
                payment_date = datetime.strptime(relevant_date_str, "%d.%m.%Y").date()
                days_remaining = (payment_date - today).days
                client_name = f"{deal['first_name']} {deal['last_name'] or ''}".strip()
                
                # --- Логика для скорых оплат (3 дня, 2, 1, 0) ---
                if 0 <= days_remaining <= 3:
                    time_left = "сегодня" if days_remaining == 0 else f"через {days_remaining} {get_day_suffix(days_remaining)}"
                    
                    # Уведомление для клиента
                    client_message = (
                        f"🔔 *Напоминание об оплате*\n\n"
                        f"Уважаемый(ая) {client_name}, напоминаем, что срок вашей {deal_type_rus} "
                        f"велосипеда «{deal['bike_name']}» истекает *{time_left}* ({payment_date.strftime('%d.%m.%Y')}).\n\n"
                        f"Пожалуйста, не забудьте продлить аренду или внести платеж. Это можно сделать в разделе '👤 Личный кабинет'."
                    )
                    await context.bot.send_message(chat_id=deal['user_id'], text=client_message, parse_mode="Markdown")

                    # Запись для админа
                    admin_reminders.append(f"• {client_name} - «{deal['bike_name']}» - оплата *{time_left}*")

                # --- Логика для просрочек ---
                elif days_remaining < 0:
                    overdue_days = abs(days_remaining)
                    
                    # Уведомление для клиента
                    client_message = (
                        f"🚨 *ПРОСРОЧКА ОПЛАТЫ*\n\n"
                        f"Уважаемый(ая) {client_name}, по вашей {deal_type_rus} "
                        f"велосипеда «{deal['bike_name']}» имеется просрочка на *{overdue_days} {get_day_suffix(overdue_days)}*.\n\n"
                        f"Пожалуйста, срочно внесите платеж через '👤 Личный кабинет' или свяжитесь с поддержкой!"
                    )
                    await context.bot.send_message(chat_id=deal['user_id'], text=client_message, parse_mode="Markdown")
                    
                    # Запись для админа
                    admin_overdue.append(f"• {client_name} - «{deal['bike_name']}» - просрочка *{overdue_days} {get_day_suffix(overdue_days)}*")

            except (ValueError, TypeError) as e:
                logging.error(f"Не удалось обработать дату '{relevant_date_str}' для user_id {deal['user_id']}: {e}")
                continue

        # --- Формирование и отправка итогового отчета администраторам ---
        admin_message_parts = ["*Ежедневная сводка по платежам (20:00 МСК)*\n"]
        
        if admin_reminders:
            admin_message_parts.append("*⚠️ Ближайшие оплаты (3 дня или меньше):*")
            admin_message_parts.extend(admin_reminders)
        
        if admin_overdue:
            admin_message_parts.append("\n*🚨 ПРОСРОЧЕННЫЕ ПЛАТЕЖИ:*")
            admin_message_parts.extend(admin_overdue)
            
        if not admin_reminders and not admin_overdue:
            admin_message_parts.append("\n✅ На сегодня просрочек и ближайших оплат нет.")
        
        final_admin_message = "\n".join(admin_message_parts)
        
        for admin_id in ADMIN_IDS:
            try:
                await context.bot.send_message(chat_id=admin_id, text=final_admin_message, parse_mode="Markdown")
            except Exception as e:
                logging.error(f"Не удалось отправить сводку админу {admin_id}: {e}")
        
        logging.info("[ПРОВЕРКА] Ежедневная проверка сроков оплаты успешно завершена.")

    except Exception as e:
        logging.error(f"КРИТИЧЕСКАЯ ОШИБКА в `check_payment_reminders`: {e}", exc_info=True)

async def client_handle_signature(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    ИСПРАВЛЕННАЯ ВЕРСИЯ:
    - Корректно обрабатывает подпись договора для сделок с индивидуальными тарифами из БД.
    - Получает сумму для оплаты напрямую из записи о велосипеде.
    """
    query = update.callback_query
    await query.answer()

    parts = query.data.split('_')
    action = parts[1]
    booking_id = int(parts[2])
    user_id = query.from_user.id

    try:
        try:
            await query.message.delete()
        except Exception as e:
            logger.warning(f"Не удалось удалить сообщение с договором (заявка #{booking_id}): {e}")

        if action == 'decline':
            async with aiosqlite.connect(DB_FILE) as conn:
                await conn.execute("DELETE FROM bookings WHERE id=?", (booking_id,))
                await conn.commit()
            await context.bot.send_message(user_id, "❌ Вы отказались от сделки. Заявка аннулирована.")
            for admin_id in ADMIN_IDS:
                await context.bot.send_message(admin_id, f"🚨 Клиент (ID: {user_id}) отказался подписывать договор по заявке #{booking_id}.")
            return ConversationHandler.END

        await context.bot.send_message(user_id, "✅ Договор подписан! Готовлю счет на оплату...")

        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            # <<< НАЧАЛО ИЗМЕНЕНИЙ: Добавляем в запрос поля с тарифами из `bikes` >>>
            cursor = await conn.execute(
                """SELECT b.bike_id, b.end_date, b.booking_date, b.booking_type,
                          u.phone_number, 
                          m.name as model_name,
                          m.rent_price_7d, m.rent_price_14d, m.rent_price_30d,
                          m.buyout_payment_amount
                   FROM bookings b 
                   JOIN users u ON b.user_id = u.id 
                   JOIN bikes m ON b.bike_id = m.id 
                   WHERE b.id=?
                """,
                (booking_id,)
            )
            data = await cursor.fetchone()

        if not data:
            raise ValueError("Не удалось найти данные для выставления счета.")

        price = 0
        description = ""
        payload = ""

        if data['booking_type'] == 'rent':
            days = (datetime.strptime(data['end_date'], '%d.%m.%Y') - datetime.strptime(data['booking_date'], '%d.%m.%Y')).days
            # Получаем цену из соответствующего поля `rent_price_*d`
            price = data[f'rent_price_{days}d']
            if price is None or price <= 0:
                raise ValueError(f"Цена для аренды на {days} дней не найдена для велосипеда '{data['model_name']}'.")
            description = f"Оплата аренды '{data['model_name']}' на {days} дней"
            payload = f"rental_payment_{booking_id}"
        
        else: # buyout
            # Получаем цену первого взноса напрямую из поля `buyout_payment_amount`
            price = data['buyout_payment_amount']
            if price is None or price <= 0:
                 raise ValueError(f"Цена для выкупа не найдена для велосипеда '{data['model_name']}'.")
            description = f"Первый взнос по выкупу: {data['model_name']}"
            payload = f"buyout_payment_{booking_id}"
        # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>

        # --- Дальнейший код для создания платежа остается без изменений ---
        metadata = {'internal_payload': payload, 'user_id': user_id}
        items_for_receipt = [{"description": description, "quantity": "1.00", "amount": { "value": f"{price:.2f}", "currency": "RUB" }, "vat_code": "1", "payment_subject": "service"}]
        payment_info = await create_yookassa_payment(amount=price, description=description, metadata=metadata, items=items_for_receipt, customer_info={"phone": data['phone_number']}, payment_method='sbp')

        if not payment_info:
            await context.bot.send_message(user_id, "❌ Не удалось создать ссылку на оплату. Свяжитесь с поддержкой.")
            return ConversationHandler.END

        payment_url, payment_id, final_amount = payment_info['url'], payment_info['id'], payment_info['final_amount']

        keyboard = [[InlineKeyboardButton("💳 Оплатить", url=payment_url)]]
        animated_message = await context.bot.send_message(
            user_id,
            f"Нажмите кнопку для оплаты {final_amount:.2f} ₽",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        if 'pending_payments' not in context.bot_data: context.bot_data['pending_payments'] = {}
        stop_animation_event = asyncio.Event()
        context.bot_data['pending_payments'][payment_id] = {'user_id': user_id, 'start_time': datetime.now(), 'payload': payload, 'amount': final_amount, 'animated_message_id': animated_message.message_id, 'url': payment_url, 'animation_sequence': random.choice(PAYMENT_ANIMATIONS), 'stop_animation_event': stop_animation_event}
        asyncio.create_task(animate_payment_message(context, payment_id))
        context.job_queue.run_repeating(callback=check_payment_status, interval=15, first=10, name=f"payment_{payment_id}", data={'yookassa_id': payment_id})

        return ConversationHandler.END

    except Exception as e:
        logger.error(f"Ошибка в client_handle_signature: {e}", exc_info=True)
        await context.bot.send_message(user_id, f"❌ Произошла критическая ошибка: {e}. Пожалуйста, свяжитесь с поддержкой.")
        return ConversationHandler.END
async def edit_user_back_to_profile(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Просто возвращает пользователя к экрану редактирования профиля.
    """
    query = update.callback_query
    await query.answer()

    # Перерисовываем профиль, используя данные из context.user_data
    text, markup = await build_profile_for_edit(context)
    await query.edit_message_text(text, reply_markup=markup, parse_mode='Markdown')
    
    # Возвращаем в состояние выбора поля для редактирования
    return EDIT_SELECT_FIELD
async def cancel_deal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Отмена со стороны клиента."""
    await update.message.reply_text("Действие отменено.")
    return ConversationHandler.END

# <<< НАЧАЛО НОВОГО БЛОКА КОДА ДЛЯ СТАТИСТИКИ >>>
# <<< НАЧАЛО НОВОГО БЛОКА КОДА ДЛЯ EXCEL-ОТЧЕТОВ >>>
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter

# <<< НАЧАЛО УЛУЧШЕННОГО БЛОКА КОДА ДЛЯ EXCEL-ОТЧЕТОВ >>>
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter

# <<< НАЧАЛО ФИНАЛЬНОГО БЛОКА КОДА ДЛЯ EXCEL-ОТЧЕТОВ >>>
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter

# <<< НАЧАЛО ФИНАЛЬНОГО БЛОКА КОДА ДЛЯ EXCEL-ОТЧЕТОВ (ВЕРСИЯ 4.0 - ИСТОЧНИК ПРАВДЫ: BIKE_HISTORY) >>>
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter

def format_excel_sheet(worksheet, currency_column_indices=[]):
    """Применяет профессиональные стили к листу Excel."""
    header_font = Font(bold=True, color="FFFFFF", name='Calibri', size=11)
    header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
    center_align = Alignment(horizontal='center', vertical='center', wrap_text=True)
    left_align = Alignment(horizontal='left', vertical='center', wrap_text=True)
    right_align = Alignment(horizontal='right', vertical='center')
    
    currency_format = '#,##0.00 ₽'
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))

    for cell in worksheet[1]:
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = center_align
        cell.border = thin_border
    worksheet.row_dimensions[1].height = 25

    for i, col in enumerate(worksheet.columns, 1):
        max_length = 0
        column_letter = get_column_letter(i)
        for cell in col:
            if cell.row > 1:
                cell.border = thin_border
                cell.font = Font(name='Calibri', size=11)
                if i - 1 in currency_column_indices:
                    cell.number_format = currency_format
                    cell.alignment = right_align
                else:
                    cell.alignment = left_align
            
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(str(cell.value))
            except: pass
        
        adjusted_width = (max_length + 4) if max_length < 45 else 47
        worksheet.column_dimensions[column_letter].width = adjusted_width


# <<< НАЧАЛО ФИНАЛЬНОЙ ВЕРСИИ ДЛЯ ОТЧЕТА ПО АРЕНДЕ (V5.0 - РЕВЕРС-ИНЖИНИРИНГ СРОКА) >>>

# <<< НАЧАЛО ФИНАЛЬНОЙ ВЕРСИИ ДЛЯ ОТЧЕТА ПО АРЕНДЕ (V6.0 - ГИБРИДНЫЙ ПОИСК ДАТ) >>>

def _find_rental_period_from_price(model_key: str, price: float) -> int | None:
    """
    Находит срок аренды в днях, сопоставляя модель и точную сумму платежа
    с тарифной сеткой RENTAL_PRICES.
    """
    if not model_key:
        return None
    # Ищем точное совпадение цены
    for key, rent_price in RENTAL_PRICES.items():
        # Проверяем, что ключ тарифа относится к нашей модели и цена совпадает
        if model_key in key and abs(rent_price - price) < 0.01:
            try:
                # Извлекаем дни из ключа (например, 'kugoo_jl_14' -> 14)
                return int(key.split('_')[-1])
            except (ValueError, IndexError):
                continue
    return None # Если совпадение не найдено

def _parse_period_from_details(details: str) -> tuple[str, str] | None:
    """
    Ищет в строке 'details' период аренды в формате ДД.ММ.ГГГГ-ДД.ММ.ГГГГ.
    """
    if not details:
        return None
    # Ищем паттерн "Период: ДАТА-ДАТА"
    match = re.search(r'период:\s*(\d{2}\.\d{2}\.\d{4})\s*-\s*(\d{2}\.\d{2}\.\d{4})', details, re.IGNORECASE)
    if match:
        start_date, end_date = match.groups()
        return start_date, end_date
    return None

# <<< НАЧАЛО БЛОКА ПРОФЕССИОНАЛЬНЫХ EXCEL-ОТЧЕТОВ (ВЕРСИЯ "ПИЗДЕЦ КРАСИВО") >>>
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter

# --- Функции для стилизации ---

def _create_main_header(sheet, title: str, col_span: int):
    """Создает главный заголовок отчета."""
    HEADER_COLOR = "4F81BD" # Темно-синий
    sheet.merge_cells(start_row=1, start_column=1, end_row=1, end_column=col_span)
    title_cell = sheet['A1']
    title_cell.value = title
    title_cell.font = Font(name='Calibri', size=16, bold=True, color='FFFFFF')
    title_cell.fill = PatternFill(start_color=HEADER_COLOR, end_color=HEADER_COLOR, fill_type='solid')
    title_cell.alignment = Alignment(horizontal='center', vertical='center')
    sheet.row_dimensions[1].height = 40

def _create_subtitle(sheet, col_span: int):
    """Создает подзаголовок с датой генерации."""
    sheet.merge_cells(start_row=2, start_column=1, end_row=2, end_column=col_span)
    subtitle_cell = sheet['A2']
    subtitle_cell.value = f"Отчет сформирован: {datetime.now().strftime('%d %B %Y г. в %H:%M')}"
    subtitle_cell.font = Font(name='Calibri', size=10, italic=True, color='595959')
    subtitle_cell.alignment = Alignment(horizontal='center', vertical='center')
    sheet.row_dimensions[2].height = 20

def _format_table_headers(sheet, start_row: int, headers: list):
    """Форматирует заголовки таблицы."""
    HEADER_COLOR = "4F81BD"
    for col, header in enumerate(headers, 1):
        cell = sheet.cell(row=start_row, column=col)
        cell.value = header
        cell.font = Font(name='Calibri', size=11, bold=True, color='FFFFFF')
        cell.fill = PatternFill(start_color=HEADER_COLOR, end_color=HEADER_COLOR, fill_type='solid')
        cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
    sheet.row_dimensions[start_row].height = 30

def _format_data_rows_and_autofit(sheet, header_row: int, data_start_row: int, currency_columns: list):
    """
    Форматирует строки с данными, применяет чередующуюся заливку и автоширину.
    ИСПРАВЛЕНО: Полностью переработан алгоритм расчета ширины для корректного отображения
    больших чисел, валюты и учета длины заголовков.
    """
    LIGHT_FILL = "DDEBF7"
    WHITE_FILL = "FFFFFF"
    thin_border = Border(left=Side(style='thin', color='BFBFBF'), right=Side(style='thin', color='BFBFBF'),
                         top=Side(style='thin', color='BFBFBF'), bottom=Side(style='thin', color='BFBFBF'))

    column_widths = {}

    # Шаг 1: Получаем ширину на основе заголовков
    for col_idx, cell in enumerate(sheet[header_row], 1):
        if cell.value:
            column_widths[col_idx] = len(str(cell.value))

    # Шаг 2: Обновляем ширину на основе данных, если они длиннее
    for r_idx, row in enumerate(sheet.iter_rows(min_row=data_start_row, max_row=sheet.max_row)):
        fill = PatternFill(start_color=LIGHT_FILL if r_idx % 2 == 0 else WHITE_FILL, fill_type='solid')
        for c_idx, cell in enumerate(row, 1):
            cell.fill = fill
            cell.border = thin_border
            cell.font = Font(name='Calibri', size=11)
            
            if c_idx in currency_columns:
                cell.number_format = '#,##0.00 ₽'
                cell.alignment = Alignment(horizontal='right', vertical='center')
            else:
                cell.alignment = Alignment(horizontal='left', vertical='center', wrap_text=True)
            
            if cell.value:
                # Для чисел берем длину их строкового представления с форматированием
                if isinstance(cell.value, (int, float)):
                    cell_len = len(f"{cell.value:,.2f}")
                else:
                    cell_len = len(str(cell.value))
                
                # Обновляем максимальную ширину
                current_max = column_widths.get(c_idx, 0)
                if cell_len > current_max:
                    column_widths[c_idx] = cell_len

    # Шаг 3: Применяем рассчитанную ширину с запасом
    for col_idx, width in column_widths.items():
        # Для колонок с валютой даем дополнительный запас
        extra_padding = 6 if col_idx in currency_columns else 4
        sheet.column_dimensions[get_column_letter(col_idx)].width = min(width + extra_padding, 50) # Ограничиваем макс. ширину


# ШАГ 1: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ _add_summary_block НА ЭТУ

def _add_summary_block(sheet, total_income: float, num_operations: int, col_span: int):
    """
    Добавляет блок с итогами.
    ИСПРАВЛЕНО: Гарантирует, что столбец с итоговой суммой будет достаточно широким.
    """
    summary_row = sheet.max_row + 2
    
    # Объединяем ячейки для текста "ИТОГО ЗА МЕСЯЦ"
    sheet.merge_cells(start_row=summary_row, start_column=1, end_row=summary_row, end_column=col_span - 1)
    summary_cell = sheet.cell(row=summary_row, column=1, value="ИТОГО ЗА МЕСЯЦ:")
    summary_cell.font = Font(name='Calibri', size=14, bold=True, color="2F5597")
    summary_cell.alignment = Alignment(horizontal='right', vertical='center')
    
    # Ячейка с итоговой суммой
    total_cell = sheet.cell(row=summary_row, column=col_span, value=total_income)
    total_cell.font = Font(name='Calibri', size=14, bold=True)
    total_cell.number_format = '#,##0.00 ₽'
    total_cell.alignment = Alignment(horizontal='right', vertical='center')

    # === ГЛАВНОЕ ИСПРАВЛЕНИЕ ЗДЕСЬ ===
    # Рассчитываем необходимую ширину для итоговой ячейки и обновляем ширину столбца, если нужно
    total_col_letter = get_column_letter(col_span)
    required_width = len(f"{total_income:,.2f} ₽") + 4 # Добавляем запас
    if sheet.column_dimensions[total_col_letter].width < required_width:
        sheet.column_dimensions[total_col_letter].width = required_width

    # Строка со статистикой (средний чек и т.д.)
    stats_row = summary_row + 1
    sheet.merge_cells(start_row=stats_row, start_column=1, end_row=stats_row, end_column=col_span)
    avg_check = total_income / num_operations if num_operations > 0 else 0
    stats_cell = sheet.cell(row=stats_row, column=1, value=f"Всего операций: {num_operations} | Средний чек: {avg_check:,.2f} ₽")
    stats_cell.font = Font(name='Calibri', size=10, italic=True, color='595959')
    stats_cell.alignment = Alignment(horizontal='right')

# --- Функции-генераторы отчетов ---

async def generate_rent_excel_report(owner_type: str) -> str | None:
    """
    Генерирует финальную версию отчета по аренде.
    ИЗМЕНЕНО: Исключены пользователи "Тест Тестов" и "Кирилл Патрушев" с помощью
    "умного" фильтра, который работает даже при кривых данных в БД.
    """
    today = datetime.now()
    start_of_month = today.replace(day=1, hour=0, minute=0, second=0)
    
    owner_filter_sql = ""
    if owner_type == 'own': owner_filter_sql = "AND b.investor_id IS NULL"
    elif owner_type == 'investor': owner_filter_sql = "AND b.investor_id IS NOT NULL"
        
    sql_query = f"""
        SELECT u.first_name, u.last_name, b.name AS bike_name, bh.details, bh.timestamp
        FROM bike_history bh
        JOIN bikes b ON bh.bike_id = b.id
        JOIN users u ON bh.user_id = u.id
        WHERE bh.action IN ('Оплата аренды', 'Продление аренды', 'Аренда доп. АКБ', 'Аренда') 
        {owner_filter_sql}
        -- === ПУЛЕНЕПРОБИВАЕМЫЙ ФИЛЬТР, КОТОРЫЙ ТОЧНО РАБОТАЕТ ===
        AND LOWER(TRIM(COALESCE(u.first_name, '') || ' ' || COALESCE(u.last_name, ''))) NOT IN ('тест тестов', 'кирилл патрушев')
    """
    
    report_data = []
    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        async with conn.execute(sql_query) as cursor:
            async for row in cursor:
                try:
                    payment_date_str = row['timestamp']
                    if not payment_date_str: continue 
                    payment_date = datetime.strptime(payment_date_str, '%Y-%m-%d %H:%M:%S')
                    if payment_date < start_of_month: continue
                    
                    income = _get_income_from_details(row['details'])
                    if not income or income == 0: continue

                    start_date_str, end_date_str = 'N/A', 'N/A'
                    period = _parse_period_from_details(row['details'])
                    if period:
                        start_date_str, end_date_str = period
                    else:
                        model_key = get_bike_model_key(row['bike_name'])
                        duration_days = _find_rental_period_from_price(model_key, income)
                        if duration_days:
                            start_date_obj = payment_date
                            end_date_obj = start_date_obj + timedelta(days=duration_days)
                            start_date_str = start_date_obj.strftime('%d.%m.%Y')
                            end_date_str = end_date_obj.strftime('%d.%m.%Y')

                    report_data.append({
                        "client": f"{row['first_name'] or ''} {row['last_name'] or ''}".strip(),
                        "bike_name": row['bike_name'], "income": income, "payment_date": payment_date,
                        "start_date": start_date_str, "end_date": end_date_str,
                    })
                except Exception as e:
                    logger.error(f"Ошибка при обработке строки отчета по аренде: {e}, row: {dict(row)}")
    
    if not report_data: return None

    workbook = openpyxl.Workbook()
    sheet = workbook.active
    sheet.title = "Доходы_Аренда"
    headers = ["👤 Клиент", "🚴 Велосипед", "💰 Сумма", "📅 Дата платежа", "▶️ Начало аренды", "⏹️ Конец аренды"]
    
    owner_text = {"own": "наших", "investor": "инвесторских", "all": "всех"}
    title = f"Доходы от АРЕНДЫ ({owner_text.get(owner_type, '')} велосипедов)"
    
    _create_main_header(sheet, title, len(headers))
    _create_subtitle(sheet, len(headers))
    _format_table_headers(sheet, 3, headers)
    
    total_income = 0
    for item in sorted(report_data, key=lambda x: x['payment_date']):
        sheet.append([
            item["client"], item["bike_name"], item["income"],
            item["payment_date"].strftime('%d.%m.%Y %H:%M'),
            item["start_date"], item["end_date"]
        ])
        total_income += item["income"]
        
    _format_data_rows_and_autofit(sheet, header_row=3, data_start_row=4, currency_columns=[3])
    _add_summary_block(sheet, total_income, len(report_data), len(headers))
    
    filename = os.path.join(REPORTS_PATH, f"rent_income_{today.strftime('%Y-%m')}_{owner_type}.xlsx")
    workbook.save(filename)
    return filename


async def generate_buyout_excel_report(owner_type: str) -> str | None:
    """
    Генерирует финальную версию отчета по выкупу.
    ИЗМЕНЕНО: Исключены пользователи "Тест Тестов" и "Кирилл Патрушев" с помощью
    "умного" фильтра, который работает даже при кривых данных в БД.
    """
    today = datetime.now()
    start_of_month = today.replace(day=1, hour=0, minute=0, second=0)

    owner_filter_sql = ""
    if owner_type == 'own': owner_filter_sql = "AND b.investor_id IS NULL"
    elif owner_type == 'investor': owner_filter_sql = "AND b.investor_id IS NOT NULL"
    
    sql_query = f"""
        SELECT u.first_name, u.last_name, b.name AS bike_name, bo.id AS booking_id,
               bo.payment_plan_key, bo.payments_made, bo.next_payment_date
        FROM bookings bo
        JOIN bikes b ON bo.bike_id = b.id
        JOIN users u ON bo.user_id = u.id
        WHERE bo.booking_type = 'buyout' {owner_filter_sql}
        -- === ПУЛЕНЕПРОБИВАЕМЫЙ ФИЛЬТР, КОТОРЫЙ ТОЧНО РАБОТАЕТ ===
        AND LOWER(TRIM(COALESCE(u.first_name, '') || ' ' || COALESCE(u.last_name, ''))) NOT IN ('тест тестов', 'кирилл патрушев')
    """
    
    deals = {}
    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        async with conn.execute(sql_query) as cursor:
            async for row in cursor:
                plan = BUYOUT_PLANS.get(row['payment_plan_key'])
                if not plan: continue

                payments_made = row['payments_made'] or 0
                total_payments = plan.get('total_payments', 0)
                payment_amount = plan.get('first_payment', 0)
                
                deals[row['booking_id']] = {
                    "client": f"{row['first_name'] or ''} {row['last_name'] or ''}".strip(),
                    "bike_name": row['bike_name'], "monthly_income": 0.0,
                    "next_payment": row['next_payment_date'] or 'ВЫКУПЛЕН',
                    "payments_made": payments_made, "total_payments": total_payments,
                    "payment_amount": payment_amount, "total_deal_sum": total_payments * payment_amount
                }
        
        income_cursor = await conn.execute(f"""
            SELECT bo.id as booking_id, bh.details FROM bike_history bh
            JOIN bookings bo ON bo.bike_id = bh.bike_id AND bo.user_id = bh.user_id AND bo.booking_type = 'buyout'
            WHERE bh.action IN ('Выкуп (1-й взнос)', 'Платеж по выкупу', 'Досрочное погашение')
            AND bh.timestamp >= ?
        """, (start_of_month.strftime('%Y-%m-%d %H:%M:%S'),))
        
        async for income_row in income_cursor:
            if income_row['booking_id'] in deals:
                income = _get_income_from_details(income_row['details']) or 0.0
                deals[income_row['booking_id']]['monthly_income'] += income

    if not deals: return None

    workbook = openpyxl.Workbook()
    sheet = workbook.active
    sheet.title = "Доходы_Выкуп"
    headers = ["👤 Клиент", "🚴 Велосипед", "💰 Доход (мес.)", "📅 След. платеж", "📊 Прогресс", "⏳ Остаток долга", "🎯 Сумма сделки"]
    
    owner_text = {"own": "нашим", "investor": "инвесторским", "all": "всем"}
    title = f"Доходы от ВЫКУПА по {owner_text.get(owner_type, '')} велосипедам"
    
    _create_main_header(sheet, title, len(headers))
    _create_subtitle(sheet, len(headers))
    _format_table_headers(sheet, 3, headers)
    
    total_monthly_income = 0
    for deal in sorted(deals.values(), key=lambda x: x['monthly_income'], reverse=True):
        payments_left = deal['total_payments'] - deal['payments_made']
        remaining_debt = payments_left * deal['payment_amount']
        
        sheet.append([
            deal["client"], deal["bike_name"], deal["monthly_income"],
            deal["next_payment"], f"{deal['payments_made']} из {deal['total_payments']}",
            remaining_debt if remaining_debt > 0 else 0,
            deal["total_deal_sum"]
        ])
        if deal["monthly_income"] > 0:
            total_monthly_income += deal["monthly_income"]

    _format_data_rows_and_autofit(sheet, header_row=3, data_start_row=4, currency_columns=[3, 6, 7])
    
    active_deals_count = sum(1 for d in deals.values() if d['monthly_income'] > 0)
    _add_summary_block(sheet, total_monthly_income, active_deals_count, len(headers))

    filename = os.path.join(REPORTS_PATH, f"buyout_income_{today.strftime('%Y-%m')}_{owner_type}.xlsx")
    workbook.save(filename)
    return filename



# <<< КОНЕЦ ФИНАЛЬНОГО БЛОКА КОДА >>>

# <<< КОНЕЦ ФИНАЛЬНОГО БЛОКА КОДА ДЛЯ EXCEL-ОТЧЕТОВ (ВЕРСИЯ 4.0) >>>

# <<< КОНЕЦ ФИНАЛЬНОГО БЛОКА КОДА ДЛЯ EXCEL-ОТЧЕТОВ >>>

# <<< КОНЕЦ УЛУЧШЕННОГО БЛОКА КОДА ДЛЯ EXCEL-ОТЧЕТОВ >>>


# ШАГ 3.1: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ ДЛЯ ГЕНЕРАЦИИ ДЕТАЛЬНОГО ОТЧЕТА

# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ generate_detailed_own_report НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ

# ФИНАЛЬНАЯ ВЕРСИЯ: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_detailed_own_report НА ЭТУ

# ФИНАЛЬНАЯ ВЕРСИЯ С СОРТИРОВКОЙ ПО ДОХОДУ: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ

# --- НОВАЯ ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ СБОРА ДАННЫХ ПО ВЫКУПАМ ---
# ИСПРАВЛЕННАЯ ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ: ЗАМЕНИТЕ ВАШУ НА ЭТУ

# =======================================================================================
# ФИНАЛЬНЫЙ БЛОК КОДА ДЛЯ ОТЧЕТА "НАШИ ВЕЛОСИПЕДЫ" (ВЕРСИЯ С ВЫКУПАМИ И БЕЗ ОШИБОК)
# ЗАМЕНИТЕ ВАШИ СУЩЕСТВУЮЩИЕ ФУНКЦИИ _get_buyout_data_for_report И generate_detailed_own_report НА ЭТОТ КОД
# =======================================================================================

# ФИНАЛЬНАЯ ВЕРСИЯ ВСПОМОГАТЕЛЬНОЙ ФУНКЦИИ ДЛЯ ВЫКУПОВ (РАБОТАЕТ ЧЕРЕЗ BOOKINGS)

# ФИНАЛЬНАЯ ВЕРСИЯ ВСПОМОГАТЕЛЬНОЙ ФУНКЦИИ (С КЛИЕНТОМ И ДАТОЙ ПЛАТЕЖА)

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ _get_buyout_data_for_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ _get_buyout_data_for_report НА ЭТУ ВЕРСИЮ
async def _get_buyout_data_for_report(owner_filter_sql: str, owner_filter_params: tuple):
    """
    ИСПРАВЛЕННАЯ ВЕРСЯ: Собирает данные по выкупам, включая ОБЩИЙ ВНЕСЕННЫЙ ДОХОД и доход за месяц.
    """
    stats = defaultdict(lambda: {'bikes': {}})
    today = datetime.now()
    start_of_month_str = today.replace(day=1, hour=0, minute=0, second=0).strftime('%Y-%m-%d %H:%M:%S')

    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        
        sql_deals = f"""
            SELECT b.id as bike_id, bo.id as booking_id, b.name as bike_name, 
                   u_investor.first_name as investor_fname, u_investor.last_name as investor_lname,
                   u_client.first_name as client_fname, u_client.last_name as client_lname,
                   bo.payment_plan_key, bo.payments_made, bo.next_payment_date, b.type as item_type
            FROM bookings bo
            JOIN bikes b ON bo.bike_id = b.id
            JOIN users u_client ON bo.user_id = u_client.id
            LEFT JOIN users u_investor ON b.investor_id = u_investor.id
            WHERE bo.booking_type = 'buyout' AND bo.status = 'rented' {owner_filter_sql}
        """
        async with conn.execute(sql_deals, owner_filter_params) as cursor:
            async for deal in cursor:
                plan = _get_plan_details(deal['payment_plan_key'], deal['bike_name'], deal['item_type'])
                if not plan: continue
                
                owner_name = "Компания" if "IS NULL" in owner_filter_sql else f"{deal['investor_fname'] or ''} {deal['investor_lname'] or ''}".strip()
                parsed_info = parse_bike_name_and_vin(deal['bike_name'])
                
                payments_made = deal['payments_made'] or 0
                total_payments = plan.get('total_payments', 0)
                payment_amount = plan.get('payment_amount') or plan.get('first_payment', 0)
                
                paid_amount = payments_made * payment_amount # <-- ОБЩАЯ ВНЕСЕННАЯ СУММА
                total_deal_value = total_payments * payment_amount
                monetary_progress_str = f"{paid_amount:,.0f} из {total_deal_value:,.0f} ₽".replace(",", " ")

                stats[owner_name]['bikes'][deal['bike_id']] = {
                    'id': deal['bike_id'], 'model': parsed_info['model'], 'vin': parsed_info['vin'],
                    'monthly_income': 0.0, # Доход за этот месяц, пока 0
                    'cumulative_income': paid_amount, # <-- НОВОЕ ПОЛЕ: Общий доход
                    'total_deal_value': total_deal_value,
                    'progress': f"{payments_made}/{total_payments}",
                    'monetary_progress': monetary_progress_str,
                    'client_name': f"{deal['client_fname'] or ''} {deal['client_lname'] or ''}".strip(),
                    'next_payment_date': deal['next_payment_date'] or 'ВЫКУПЛЕН'
                }

        # Запрос для подсчета дохода за ТЕКУЩИЙ МЕСЯЦ (остается без изменений)
        sql_income = f"""
            SELECT b.id as bike_id, u_investor.first_name, u_investor.last_name, bh.details
            FROM bike_history bh
            JOIN bikes b ON bh.bike_id = b.id
            LEFT JOIN users u_investor ON b.investor_id = u_investor.id
            WHERE bh.action IN ('Выкуп (1-й взнос)', 'Платеж по выкупу', 'Досрочное погашение', 'Выкуп АКБ (1-й взнос)', 'Платеж по выкупу (АКБ)')
            AND bh.timestamp >= ? {owner_filter_sql}
        """
        async with conn.execute(sql_income, (start_of_month_str,) + owner_filter_params) as cursor:
            async for row in cursor:
                owner_name = "Компания" if "IS NULL" in owner_filter_sql else f"{row['first_name'] or ''} {row['last_name'] or ''}".strip()
                if owner_name in stats and row['bike_id'] in stats[owner_name]['bikes']:
                    income = _get_income_from_details(row['details'])
                    stats[owner_name]['bikes'][row['bike_id']]['monthly_income'] += income
    return stats


# ФИНАЛЬНАЯ ВЕРСИЯ 1: ОТЧЕТ ПО "НАШИМ ВЕЛОСИПЕДАМ" (С ВЫКУПАМИ И КЛИЕНТАМИ)

# ЗАМЕНИТЕ ФУНКЦИЮ generate_detailed_own_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_detailed_own_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ФУНКЦИЮ generate_detailed_own_report НА ЭТУ ВЕРСИЮ
async def generate_detailed_own_report() -> str:
    today = datetime.now()
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            own_rent_stats, own_buyout_stats, own_rental_log = await _get_full_data_for_report("own", conn)
            total_expenses, expense_details = await _get_monthly_expense_data(conn)
    except Exception as e:
        logger.error(f"Ошибка при сборе данных для детального отчета: {e}", exc_info=True)
        return None

    workbook = openpyxl.Workbook(); sheet = workbook.active; sheet.title = "Детальный_отчет_Наши"
    _create_main_header(sheet, "Детальный отчет по велосипедам компании", 10)
    _create_subtitle(sheet, 10)
    
    current_row = 5
    # --- Таблица аренды ---
    sheet.cell(row=current_row, column=1, value="Доходы от Аренды").font = Font(size=14, bold=True, color="2F5597")
    current_row +=1
    rent_headers = ["№", "Модель", "Серийный номер", "Доход за месяц", "Дней в аренде", "Арендаторы"]
    _format_table_headers(sheet, current_row, rent_headers)
    current_row += 1
    total_rent_income = 0
    if "Компания" in own_rent_stats and own_rent_stats["Компания"]['bikes']:
        # ... (остальной код заполнения таблицы аренды без изменений)
        for item in sorted(own_rent_stats["Компания"]['bikes'].values(), key=lambda x: -x['total_income']):
            sheet.append([item["id"], item["model"], item["vin"], item["total_income"] if item["total_income"] > 0 else 0, item["days_rented"], ", ".join(sorted(item["renters"])) if item["renters"] else "—"])
        total_rent_income = own_rent_stats["Компания"]['total_income']
        _format_data_rows_and_autofit(sheet, header_row=current_row-1, data_start_row=current_row, currency_columns=[4])
        current_row = sheet.max_row + 2
    
    # --- Таблица выкупа ---
    sheet.cell(row=current_row, column=1, value="Доходы от Выкупа").font = Font(size=14, bold=True, color="2F5597")
    current_row += 1
    buyout_headers = ["№", "Модель", "Серийный номер", "Клиент", "Внесено (₽)", "Прогресс (пл.)", "Прогресс (₽)", "След. платеж"]
    _format_table_headers(sheet, current_row, buyout_headers)
    current_row += 1
    total_buyout_monthly_income = 0
    if "Компания" in own_buyout_stats and own_buyout_stats["Компания"]['bikes']:
        # ... (остальной код заполнения таблицы выкупа без изменений)
        for item in sorted(own_buyout_stats["Компания"]['bikes'].values(), key=lambda x: -x['monthly_income']):
            sheet.append([item["id"], item["model"], item["vin"], item["client_name"], item["cumulative_income"], item["progress"], item["monetary_progress"], item["next_payment_date"]])
        total_buyout_monthly_income = sum(b['monthly_income'] for b in own_buyout_stats["Компания"]['bikes'].values())
        _format_data_rows_and_autofit(sheet, header_row=current_row-1, data_start_row=current_row, currency_columns=[5])

    # --- ИТОГИ И РАСХОДЫ ---
    grand_total_income = total_rent_income + total_buyout_monthly_income
    _add_final_summary_with_expenses(sheet, grand_total_income, total_expenses, len(own_rental_log), len(buyout_headers))
    
    # --- Таблица расходов ---
    expense_start_row = sheet.max_row + 3
    sheet.cell(row=expense_start_row, column=1, value="Детализация расходов за месяц").font = Font(size=14, bold=True, color="C00000")
    expense_headers = ["Дата", "Категория", "Подкатегория", "Наименование", "Кол-во", "Сумма", "Комментарий"]
    _format_table_headers(sheet, expense_start_row + 1, expense_headers)
    for exp in expense_details:
        sheet.append([exp['created_at'][:10], exp['category'], exp['subcategory'], exp['item_name'], exp['quantity'], exp['amount'], exp['comment']])
    _format_data_rows_and_autofit(sheet, header_row=expense_start_row + 1, data_start_row=expense_start_row + 2, currency_columns=[6])

    filename = os.path.join(REPORTS_PATH, f"detailed_report_own_{today.strftime('%Y-%m')}.xlsx")
    workbook.save(filename)
    return filename

# ШАГ 3.2: ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ-ОБРАБОТЧИК

# ШАГ 4.2: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ send_detailed_report НА ЭТУ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ send_detailed_report НА ЭТУ ИСПРАВЛЕННУЮ ВЕРСИЮ

# ШАГ 2: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ send_detailed_report НА ЭТУ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ send_detailed_report НА ЭТУ ВЕРСИЮ
async def send_detailed_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Универсальный обработчик, который вызывает ЕДИНЫЙ генератор отчетов
    и отправляет файл пользователю. (ИСПРАВЛЕНА ОШИБКА РЕДАКТИРОВАНИЯ СООБЩЕНИЯ)
    """
    query = update.callback_query
    await query.answer()
    
    # === ИСПРАВЛЕНИЕ №2 ЗДЕСЬ ===
    message_to_edit = query.message # Сохраняем объект сообщения
    await message_to_edit.edit_text("⏳ Генерирую Excel-отчет, это может занять до минуты...")

    try:
        parts = query.data.split('_')
        report_type = parts[2]
        
        investor_id = None
        if len(parts) > 3 and parts[3].isdigit():
            investor_id = int(parts[3])

        filename = None
        if report_type == 'expenses':
            today = datetime.now()
            start_of_month = today.replace(day=1)
            filename = generate_expense_report(start_of_month, today)
        else:
            filename = await generate_unified_report(report_type=report_type, investor_id=investor_id)

        if filename and os.path.exists(filename):
            with open(filename, 'rb') as file:
                await context.bot.send_document(
                    chat_id=query.from_user.id,
                    document=file,
                    caption="✅ Ваш детальный отчет готов."
                )
            os.remove(filename)
            await message_to_edit.delete() # Удаляем сообщение "Генерирую..."
        else:
            await message_to_edit.edit_text("😔 В этой категории нет данных для отчета за текущий месяц.")

    except Exception as e:
        logger.error(f"Ошибка при генерации детального отчета ({query.data}): {e}", exc_info=True)
        # Используем сохраненный объект для редактирования
        await message_to_edit.edit_text(f"❌ Произошла критическая ошибка: {e}")

# ШАГ 5.1: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ

async def select_investor_for_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает список инвесторов для выбора с пагинацией.
    """
    query = update.callback_query
    await query.answer()

    # Извлекаем номер страницы из callback_data (stats_select_investor_0)
    page = int(query.data.split('_')[-1])
    PAGE_SIZE = 5 # 5 инвесторов на одной странице

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            # Считаем общее количество уникальных инвесторов
            count_cursor = await conn.execute(
                "SELECT COUNT(DISTINCT investor_id) FROM bikes WHERE investor_id IS NOT NULL"
            )
            total_items = (await count_cursor.fetchone())[0]

            if total_items == 0:
                await query.edit_message_text(
                    "Не найдено инвесторов с привязанными велосипедами.",
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Назад", callback_data="stats_investor_menu")]])
                )
                return

            # Получаем инвесторов для текущей страницы
            cursor = await conn.execute(
                """SELECT DISTINCT b.investor_id, u.first_name, u.last_name
                   FROM bikes b
                   JOIN users u ON b.investor_id = u.id
                   WHERE b.investor_id IS NOT NULL
                   ORDER BY u.last_name, u.first_name
                   LIMIT ? OFFSET ?""",
                (PAGE_SIZE, page * PAGE_SIZE)
            )
            investors = await cursor.fetchall()

        keyboard = []
        for inv in investors:
            # Формируем кнопку для каждого инвестора
            # callback_data будет содержать ID инвестора для фильтрации
            keyboard.append([InlineKeyboardButton(
                f"{inv['first_name']} {inv['last_name'] or ''}",
                callback_data=f"stats_detailed_investor_{inv['investor_id']}"
            )])

        # Логика пагинации
        total_pages = (total_items + PAGE_SIZE - 1) // PAGE_SIZE
        pagination_row = []
        if page > 0:
            pagination_row.append(InlineKeyboardButton("⬅️", callback_data=f"stats_select_investor_{page - 1}"))
        if page < total_pages - 1:
            pagination_row.append(InlineKeyboardButton("➡️", callback_data=f"stats_select_investor_{page + 1}"))
        
        if pagination_row:
            keyboard.append(pagination_row)
        
        # Кнопка "Назад" возвращает в меню выбора отчетов по инвесторам
        keyboard.append([InlineKeyboardButton("⬅️ Назад", callback_data="stats_investor_menu")])

        await query.edit_message_text(
            f"Выберите инвестора для отчета (Стр. {page + 1}/{total_pages}):",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    except Exception as e:
        logger.error(f"Ошибка при формировании списка инвесторов для отчета: {e}", exc_info=True)
        await query.edit_message_text("❌ Произошла ошибка при загрузке списка инвесторов.")

# <<< КОНЕЦ НОВОГО БЛОКА КОДА ДЛЯ EXCEL-ОТЧЕТОВ >>>
# ШАГ 4.1: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ ДЛЯ ОТЧЕТА ПО ВСЕМ ИНВЕСТОРАМ

# ФИНАЛЬНАЯ ВЕРСИЯ ДЛЯ ИНВЕСТОРОВ: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ

# ФИНАЛЬНАЯ ВЕРСИЯ ДЛЯ ИНВЕСТОРОВ С ГРУППИРОВКОЙ: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ

# ФИНАЛЬНАЯ ВЕРСИЯ ДЛЯ ИНВЕСТОРОВ С ГРУППИРОВКОЙ И ГАРАНТИРОВАННЫМ СОЗДАНИЕМ ФАЙЛА

# ФИНАЛЬНАЯ ВЕРСИЯ С ГРУППИРОВКОЙ ПО ИНВЕСТОРАМ: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ

# ФИНАЛЬНАЯ ВЕРСИЯ 2: ОТЧЕТ ПО ИНВЕСТОРАМ (С ВЫКУПАМИ И КЛИЕНТАМИ)

# ЗАМЕНИТЕ ФУНКЦИЮ generate_detailed_investor_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ФУНКЦИЮ generate_detailed_investor_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ФУНКЦИЮ generate_detailed_investor_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_detailed_investor_report НА ЭТУ ВЕРСИЮ
async def generate_detailed_investor_report(investor_id: int | None = None) -> str:
    today = datetime.now()
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            investor_rent_stats, investor_buyout_stats, investor_rental_log = await _get_full_data_for_report("investor", conn, investor_id)
            total_expenses, expense_details = await _get_monthly_expense_data(conn) # Расходы считаются общие
    except Exception as e:
        logger.error(f"Ошибка при сборе данных для отчета по инвесторам: {e}", exc_info=True)
        return None

    workbook = openpyxl.Workbook(); sheet = workbook.active
    title_text = "Детальный отчет по всем инвесторским велосипедам"
    if investor_id and (investor_rent_stats or investor_buyout_stats):
        investor_name = list(investor_rent_stats.keys())[0] if investor_rent_stats else list(investor_buyout_stats.keys())[0]
        title_text = f"Детальный отчет по велосипедам инвестора: {investor_name}"
    
    _create_main_header(sheet, title_text, 12)
    _create_subtitle(sheet, 12)
    current_row = 5
    grand_total_income = 0
    
    if not investor_rent_stats and not investor_buyout_stats:
        sheet.cell(row=current_row, column=1, value="Данные по инвесторам за этот месяц отсутствуют.")
    else:
        # ... (остальной код генерации таблиц для инвесторов без изменений) ...
        for investor_name in sorted(set(list(investor_rent_stats.keys()) + list(investor_buyout_stats.keys()))):
            sheet.merge_cells(start_row=current_row, start_column=1, end_row=current_row, end_column=8)
            group_header_cell = sheet.cell(row=current_row, column=1, value=f"Инвестор: {investor_name}")
            group_header_cell.font = Font(name='Calibri', size=14, bold=True, color='2F5597'); group_header_cell.fill = PatternFill(start_color="DDEBF7", fill_type='solid')
            current_row += 2
            
            if investor_name in investor_rent_stats and investor_rent_stats[investor_name]['bikes']:
                sheet.cell(row=current_row, column=1, value="Доходы от Аренды").font = Font(size=12, bold=True)
                current_row += 1
                rent_headers = ["№", "Модель", "Серийный номер", "Доход (факт)", "Дней в аренде", "Арендаторы"]
                _format_table_headers(sheet, current_row, rent_headers)
                current_row += 1
                for item in sorted(investor_rent_stats[investor_name]['bikes'].values(), key=lambda x: -x['total_income']):
                    sheet.append([item["id"], item["model"], item["vin"], item["total_income"] if item["total_income"] > 0 else 0, item["days_rented"], ", ".join(sorted(item["renters"])) if item["renters"] else "—"])
                _format_data_rows_and_autofit(sheet, header_row=current_row - 1, data_start_row=current_row, currency_columns=[4])
                current_row = sheet.max_row + 1

            if investor_name in investor_buyout_stats and investor_buyout_stats[investor_name]['bikes']:
                sheet.cell(row=current_row, column=1, value="Доходы от Выкупа").font = Font(size=12, bold=True)
                current_row += 1
                buyout_headers = ["№", "Модель", "Серийный номер", "Клиент", "Внесено (₽)", "Прогресс (пл.)", "Прогресс (₽)", "След. платеж"]
                _format_table_headers(sheet, current_row, buyout_headers)
                current_row += 1
                for item in sorted(investor_buyout_stats[investor_name]['bikes'].values(), key=lambda x: -x['monthly_income']):
                    sheet.append([item["id"], item["model"], item["vin"], item["client_name"], item["cumulative_income"], item["progress"], item["monetary_progress"], item["next_payment_date"]])
                _format_data_rows_and_autofit(sheet, header_row=current_row - 1, data_start_row=current_row, currency_columns=[5])
                current_row = sheet.max_row + 1

            subtotal_income = investor_rent_stats[investor_name]['total_income'] + sum(b['monthly_income'] for b in investor_buyout_stats.get(investor_name, {}).get('bikes', {}).values())
            subtotal_label = sheet.cell(row=current_row, column=3, value=f"Итого по инвестору:")
            subtotal_label.font = Font(bold=True, size=12); subtotal_label.alignment = Alignment(horizontal='right')
            subtotal_value = sheet.cell(row=current_row, column=4, value=subtotal_income)
            subtotal_value.font = Font(bold=True, size=12); subtotal_value.number_format = '#,##0.00 ₽'
            current_row += 2
            grand_total_income += subtotal_income
    
    # --- ИТОГИ И РАСХОДЫ ---
    _add_final_summary_with_expenses(sheet, grand_total_income, total_expenses, len(investor_rental_log), 8)
    
    # --- Таблица расходов ---
    expense_start_row = sheet.max_row + 3
    sheet.cell(row=expense_start_row, column=1, value="Детализация общих расходов за месяц").font = Font(size=14, bold=True, color="C00000")
    expense_headers = ["Дата", "Категория", "Подкатегория", "Наименование", "Кол-во", "Сумма", "Комментарий"]
    _format_table_headers(sheet, expense_start_row + 1, expense_headers)
    for exp in expense_details:
        sheet.append([exp['created_at'][:10], exp['category'], exp['subcategory'], exp['item_name'], exp['quantity'], exp['amount'], exp['comment']])
    _format_data_rows_and_autofit(sheet, header_row=expense_start_row + 1, data_start_row=expense_start_row + 2, currency_columns=[6])

    filename = os.path.join(REPORTS_PATH, f"detailed_report_investor_{investor_id or 'all'}_{today.strftime('%Y-%m')}.xlsx")
    workbook.save(filename)
    return filename

# ШАГ 1: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ ДЛЯ ОБЩЕГО ОТЧЕТА

# ИСПРАВЛЕННАЯ ВЕРСИЯ ОБЩЕГО ОТЧЕТА: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ

# ФИНАЛЬНАЯ ВЕРСИЯ ОБЩЕГО ОТЧЕТА: ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ НА ЭТУ

# ФИНАЛЬНАЯ ВЕРСИЯ 3: ОБЩИЙ ОТЧЕТ (С ВЫКУПАМИ И КЛИЕНТАМИ)

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_combined_detailed_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_combined_detailed_report НА ЭТУ ВЕРСИЮ
async def generate_combined_detailed_report() -> str:
    """
    ФИНАЛЬНАЯ ВЕРСИЯ: Генерирует ОБЩИЙ Excel-отчет, объединяя все данные и расходы.
    """
    today = datetime.now()
    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            own_rent_stats, own_buyout_stats, own_rental_log = await _get_full_data_for_report("own", conn)
            investor_rent_stats, investor_buyout_stats, investor_rental_log = await _get_full_data_for_report("investor", conn)
            total_expenses, expense_details = await _get_monthly_expense_data(conn)
    except Exception as e:
        logger.error(f"Ошибка при сборе данных для общего отчета: {e}", exc_info=True)
        return None

    # --- Генерация Excel ---
    workbook = openpyxl.Workbook(); sheet = workbook.active; sheet.title = "Общий_детальный_отчет"
    _create_main_header(sheet, "Общий детальный отчет по всем велосипедам", 16)
    _create_subtitle(sheet, 16)
    
    # --- Секция 1: Наши велосипеды ---
    # ... (код для вывода таблиц по "нашим" без изменений) ...
    offset_column_own = 1
    sheet.cell(row=4, column=offset_column_own, value="Велосипеды компании").font = Font(size=14, bold=True, color="2F5597")
    current_row_left = 5
    sheet.cell(row=current_row_left, column=offset_column_own, value="Доходы от Аренды").font = Font(size=12, bold=True)
    current_row_left += 1
    rent_headers = ["№", "Модель", "Серийный номер", "Доход (мес.)", "Дней в аренде", "Арендаторы"]
    _format_table_headers(sheet, current_row_left, rent_headers)
    current_row_left += 1
    total_own_rent_income = 0
    if "Компания" in own_rent_stats and own_rent_stats["Компания"]['bikes']:
        for item in sorted(own_rent_stats["Компания"]['bikes'].values(), key=lambda x: -x['total_income']):
            sheet.append([item["id"], item["model"], item["vin"], item["total_income"] if item["total_income"] > 0 else 0, item["days_rented"], ", ".join(sorted(item["renters"])) if item["renters"] else "—"])
        total_own_rent_income = own_rent_stats["Компания"]['total_income']
        _format_data_rows_and_autofit(sheet, header_row=current_row_left - 1, data_start_row=current_row_left, currency_columns=[4])
    
    current_row_left = sheet.max_row + 2
    sheet.cell(row=current_row_left, column=offset_column_own, value="Доходы от Выкупа").font = Font(size=12, bold=True)
    current_row_left += 1
    buyout_headers_own = ["№", "Модель", "Серийный номер", "Клиент", "Внесено (₽)", "Прогресс (пл.)", "Прогресс (₽)", "След. платеж"]
    _format_table_headers(sheet, current_row_left, buyout_headers_own)
    current_row_left += 1
    total_own_buyout_income = 0
    if "Компания" in own_buyout_stats and own_buyout_stats["Компания"]['bikes']:
        for item in sorted(own_buyout_stats["Компания"]['bikes'].values(), key=lambda x: -x['monthly_income']):
            sheet.cell(row=current_row_left, column=1, value=item["id"]); sheet.cell(row=current_row_left, column=2, value=item["model"])
            sheet.cell(row=current_row_left, column=3, value=item["vin"]); sheet.cell(row=current_row_left, column=4, value=item["client_name"])
            sheet.cell(row=current_row_left, column=5, value=item["cumulative_income"]); sheet.cell(row=current_row_left, column=6, value=item["progress"])
            sheet.cell(row=current_row_left, column=7, value=item["monetary_progress"]); sheet.cell(row=current_row_left, column=8, value=item["next_payment_date"])
            current_row_left += 1
        total_own_buyout_income = sum(b['monthly_income'] for b in own_buyout_stats["Компания"]['bikes'].values())
        _format_data_rows_and_autofit(sheet, header_row=current_row_left - 1, data_start_row=current_row_left - len(own_buyout_stats["Компания"]['bikes']), currency_columns=[5])

    # --- Секция 2: Инвесторские велосипеды ---
    # ... (код для вывода таблиц по инвесторам без изменений) ...
    offset_column_inv = 9
    sheet.cell(row=4, column=offset_column_inv, value="Инвесторские велосипеды").font = Font(size=14, bold=True, color="2F5597")
    current_row_right = 5
    total_investor_rent_income = 0
    total_investor_buyout_income = 0
    all_investors = sorted(set(list(investor_rent_stats.keys()) + list(investor_buyout_stats.keys())))
    for investor_name in all_investors:
        sheet.merge_cells(start_row=current_row_right, start_column=offset_column_inv, end_row=current_row_right, end_column=offset_column_inv + 7)
        group_header = sheet.cell(row=current_row_right, column=offset_column_inv, value=f"Инвестор: {investor_name}")
        group_header.font = Font(size=12, bold=True, color='2F5597'); group_header.fill = PatternFill(start_color="DDEBF7", fill_type='solid')
        current_row_right += 1

        if investor_name in investor_rent_stats and investor_rent_stats[investor_name]['bikes']:
            start_data_row = current_row_right
            for i, header in enumerate(rent_headers): sheet.cell(row=start_data_row, column=offset_column_inv + i, value=header)
            _format_table_headers(sheet, start_data_row, rent_headers)
            start_data_row += 1
            for item in sorted(investor_rent_stats[investor_name]['bikes'].values(), key=lambda x: -x['total_income']):
                for i, val in enumerate([item["id"], item["model"], item["vin"], item["total_income"] if item["total_income"] > 0 else 0, item["days_rented"], ", ".join(sorted(item["renters"])) if item["renters"] else "—"]):
                    sheet.cell(row=start_data_row, column=offset_column_inv + i, value=val)
                start_data_row += 1
            _format_data_rows_and_autofit(sheet, header_row=start_data_row - len(investor_rent_stats[investor_name]['bikes']) - 1, data_start_row=start_data_row - len(investor_rent_stats[investor_name]['bikes']), currency_columns=[offset_column_inv + 3])
            current_row_right = sheet.max_row + 1
            total_investor_rent_income += investor_rent_stats[investor_name]['total_income']

        if investor_name in investor_buyout_stats and investor_buyout_stats[investor_name]['bikes']:
            start_data_row = current_row_right
            for i, header in enumerate(buyout_headers_own): sheet.cell(row=start_data_row, column=offset_column_inv + i, value=header)
            _format_table_headers(sheet, start_data_row, buyout_headers_own)
            start_data_row += 1
            for item in sorted(investor_buyout_stats[investor_name]['bikes'].values(), key=lambda x: -x['monthly_income']):
                for i, val in enumerate([item["id"], item["model"], item["vin"], item["client_name"], item["cumulative_income"], item["progress"], item["monetary_progress"], item["next_payment_date"]]):
                    sheet.cell(row=start_data_row, column=offset_column_inv + i, value=val)
                start_data_row += 1
            _format_data_rows_and_autofit(sheet, header_row=start_data_row - len(investor_buyout_stats[investor_name]['bikes']) - 1, data_start_row=start_data_row - len(investor_buyout_stats[investor_name]['bikes']), currency_columns=[offset_column_inv + 4])
            current_row_right = sheet.max_row + 1
            total_investor_buyout_income += sum(b['monthly_income'] for b in investor_buyout_stats[investor_name]['bikes'].values())
        current_row_right += 1

    # --- ИТОГИ И РАСХОДЫ ---
    grand_total_income = total_own_rent_income + total_own_buyout_income + total_investor_rent_income + total_investor_buyout_income
    _add_final_summary_with_expenses(sheet, grand_total_income, total_expenses, len(own_rental_log) + len(investor_rental_log), 15)

    # --- Таблица расходов ---
    expense_start_row = sheet.max_row + 3
    sheet.cell(row=expense_start_row, column=1, value="Детализация общих расходов за месяц").font = Font(size=14, bold=True, color="C00000")
    expense_headers = ["Дата", "Категория", "Подкатегория", "Наименование", "Кол-во", "Сумма", "Комментарий"]
    _format_table_headers(sheet, expense_start_row + 1, expense_headers)
    for exp in expense_details:
        sheet.append([exp['created_at'][:10], exp['category'], exp['subcategory'], exp['item_name'], exp['quantity'], exp['amount'], exp['comment']])
    _format_data_rows_and_autofit(sheet, header_row=expense_start_row + 1, data_start_row=expense_start_row + 2, currency_columns=[6])
    
    filename = os.path.join(REPORTS_PATH, f"combined_detailed_report_{today.strftime('%Y-%m')}.xlsx")
    workbook.save(filename)
    return filename
# --- НОВАЯ УНИВЕРСАЛЬНАЯ ФУНКЦИЯ СБОРА ДАННЫХ ---
# ФИНАЛЬНАЯ ВЕРСИЯ ВСПОМОГАТЕЛЬНОЙ ФУНКЦИИ (ИСПРАВЛЕННАЯ)

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ _get_full_data_for_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ _get_full_data_for_report НА ЭТУ ВЕРСИЮ
async def _get_full_data_for_report(owner_type: str, conn: aiosqlite.Connection, investor_id: int | None = None):
    """
    Универсальная функция для сбора данных по аренде и выкупу.
    Принимает объект соединения с БД.
    """
    # <<< ИСПРАВЛЕНИЕ: Устанавливаем row_factory в самом начале >>>
    conn.row_factory = aiosqlite.Row
    
    today = datetime.now()
    start_of_month = today.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    end_of_month = (start_of_month.replace(day=28) + timedelta(days=4)).replace(day=1) - timedelta(days=1)
    end_of_month = end_of_month.replace(hour=23, minute=59, second=59)

    stats_rent = defaultdict(lambda: {'bikes': {}, 'total_income': 0.0})
    rental_log = []
    
    owner_filter_sql = "AND b.investor_id IS NULL" if owner_type == "own" else "AND b.investor_id IS NOT NULL"
    params = []
    if investor_id:
        owner_filter_sql += " AND b.investor_id = ?"
        params.append(investor_id)

    # Теперь bike['name'] будет работать корректно
    sql_get_bikes = f"SELECT b.id, b.name, u.first_name, u.last_name FROM bikes b LEFT JOIN users u ON b.investor_id = u.id WHERE b.type = 'bike' {owner_filter_sql}"
    cursor = await conn.execute(sql_get_bikes, params)
    for bike in await cursor.fetchall():
        owner_name = "Компания" if owner_type == 'own' else f"{bike['first_name'] or ''} {bike['last_name'] or ''}".strip()
        parsed_info = parse_bike_name_and_vin(bike['name'])
        stats_rent[owner_name]['bikes'][bike['id']] = {'id': bike['id'], 'model': parsed_info['model'], 'vin': parsed_info['vin'], 'total_income': 0.0, 'days_rented': 0, 'renters': set()}

    history_params = [start_of_month.strftime('%Y-%m-%d %H:%M:%S')]
    if investor_id: 
        history_params.append(investor_id)
        # Корректируем SQL для корректной фильтрации по investor_id в bike_history
        owner_filter_sql_history = "AND b.investor_id = ?"
    else:
        owner_filter_sql_history = owner_filter_sql

    sql_query_rent = f"""
        SELECT b.id AS bike_id, u_renter.first_name, u_renter.last_name, u_investor.first_name as investor_fname, u_investor.last_name as investor_lname, bh.details, bh.timestamp
        FROM bike_history bh 
        JOIN bikes b ON bh.bike_id = b.id 
        JOIN users u_renter ON bh.user_id = u_renter.id 
        LEFT JOIN users u_investor ON b.investor_id = u_investor.id
        WHERE b.type = 'bike' AND bh.action IN ('Оплата аренды', 'Продление аренды', 'Аренда', 'Аренда доп. АКБ') AND bh.timestamp >= ?
        {owner_filter_sql_history} 
        AND LOWER(TRIM(COALESCE(u_renter.first_name, '') || ' ' || COALESCE(u_renter.last_name, ''))) NOT IN ('тест тестов', 'кирилл патрушев')
    """
    async with conn.execute(sql_query_rent, history_params) as cursor:
        async for row in cursor:
            owner_name = "Компания" if owner_type == 'own' else f"{row['investor_fname'] or ''} {row['investor_lname'] or ''}".strip()
            bike_id = row['bike_id']
            if owner_name not in stats_rent or bike_id not in stats_rent[owner_name]['bikes']: continue
            income = _get_income_from_details(row['details'])
            stats_rent[owner_name]['bikes'][bike_id]['total_income'] += income
            stats_rent[owner_name]['total_income'] += income
            renter_name = f"{row['first_name'] or ''} {row['last_name'] or ''}".strip()
            if renter_name: stats_rent[owner_name]['bikes'][bike_id]['renters'].add(renter_name)
            payment_date = datetime.strptime(row['timestamp'], '%Y-%m-%d %H:%M:%S')
            period = _parse_period_from_details(row['details'])
            start_rent_obj, end_rent_obj = (datetime.strptime(period[0], '%d.%m.%Y'), datetime.strptime(period[1], '%d.%m.%Y')) if period else (None, None)
            if not period:
                model_key = get_bike_model_key(stats_rent[owner_name]['bikes'][bike_id]['model'] + stats_rent[owner_name]['bikes'][bike_id]['vin'])
                duration = _find_rental_period_from_price(model_key, income)
                if duration: start_rent_obj, end_rent_obj = payment_date, payment_date + timedelta(days=duration)
            if start_rent_obj and end_rent_obj:
                overlap_start, overlap_end = max(start_rent_obj, start_of_month), min(end_rent_obj, end_of_month)
                if overlap_end >= overlap_start: stats_rent[owner_name]['bikes'][bike_id]['days_rented'] += (overlap_end - overlap_start).days
            rental_log.append(1)

    buyout_filter_sql = "AND b.investor_id IS NULL" if owner_type == "own" else "AND b.investor_id IS NOT NULL"
    buyout_params = (investor_id,) if investor_id else ()
    if investor_id: buyout_filter_sql += " AND b.investor_id = ?"
    buyout_stats = await _get_buyout_data_for_report(conn, buyout_filter_sql, buyout_params)
    
    return stats_rent, buyout_stats, rental_log
# ШАГ 1.1: ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ
# ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ В ВАШ КОД
# ВСТАВЬТЕ ЭТОТ БОЛЬШОЙ БЛОК ВМЕСТО ВСЕХ СТАРЫХ ФУНКЦИЙ ГЕНЕРАЦИИ ОТЧЕТОВ

# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_unified_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_unified_report НА ЭТУ ФИНАЛЬНУЮ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_unified_report НА ЭТУ ФИНАЛЬНУЮ ВЕРСИЮ
def _get_expense_labels(category_key: str, subcategory_key: str) -> tuple[str, str]:
    """Вспомогательная функция для перевода ключей расходов в русские названия."""
    try:
        cat_info = EXPENSE_CATEGORIES.get(category_key, {})
        cat_label = cat_info.get('label', category_key)
        
        sub_info = cat_info.get('subcategories', {}).get(subcategory_key)
        if isinstance(sub_info, dict):
            sub_label = sub_info.get('label', subcategory_key)
        elif isinstance(sub_info, str):
            sub_label = sub_info
        else:
            sub_label = subcategory_key
            
        return cat_label, sub_label
    except Exception:
        return category_key, subcategory_key
# ВСТАВЬТЕ ЭТОТ БОЛЬШОЙ БЛОК ВМЕСТО ВСЕХ СТАРЫХ ФУНКЦИЙ ГЕНЕРАЦИИ ОТЧЕТОВ

# Убедитесь, что все эти импорты есть в начале вашего файла
import aiosqlite
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter
from datetime import datetime, timedelta
from collections import defaultdict
import os
import re
import logging

# =======================================================================================
# НАЧАЛО ПОЛНОЙ ФУНКЦИИ (скопируйте и вставьте этот блок целиком)
# =======================================================================================

# =======================================================================================
# ПОЛНАЯ ИСПРАВЛЕННАЯ ФУНКЦИЯ (С ФИКСОМ ШИРИНЫ СТОЛБЦОВ)
# =======================================================================================

# =======================================================================================
# ПОЛНАЯ ИСПРАВЛЕННАЯ ФУНКЦИЯ (С ФИКСОМ ШИРИНЫ СТОЛБЦОВ)
# =======================================================================================

# =======================================================================================
# ФИНАЛЬНАЯ ВЕРСИЯ С ИСПРАВЛЕНИЕМ KeyError
# =======================================================================================

# =======================================================================================
# ФИНАЛЬНАЯ ВЕРСИЯ С ИСПРАВЛЕНИЕМ KeyError (На этот раз точно)
# =======================================================================================

# =======================================================================================
# ОКОНЧАТЕЛЬНАЯ ВЕРСИЯ С ИСПРАВЛЕНИЕМ KeyError
# =======================================================================================

# =======================================================================================
# ОКОНЧАТЕЛЬНАЯ ВЕРСИЯ ОТЧЕТА С ТРЕМЯ ТАБЛИЦАМИ (ЗАМЕНИТЬ СТАРУЮ ФУНКЦИЮ)
# =======================================================================================

# =======================================================================================
# ОКОНЧАТЕЛЬНАЯ ВЕРСИЯ ФУНКЦИИ ОТЧЕТА (ЗАМЕНИТЬ СТАРУЮ)
# =======================================================================================

# =======================================================================================
# ОКОНЧАТЕЛЬНАЯ ВЕРСИЯ ФУНКЦИИ ОТЧЕТА (С ФИКСОМ ШИРИНЫ СТОЛБЦОВ)
# =======================================================================================

# =======================================================================================
# ОКОНЧАТЕЛЬНАЯ ВЕРСЯ ОТЧЕТА ПО ТВОИМ ТРЕБОВАНИЯМ (С ДИАГРАММОЙ)
# =======================================================================================
import openpyxl
from openpyxl.chart import PieChart, Reference
from openpyxl.chart.label import DataLabelList

# === НАЧАЛО БЛОКА ИСПРАВЛЕНИЯ ===

async def generate_unified_report(report_type: str, start_date: datetime, end_date: datetime, investor_id: int | None = None) -> str | None:
    """
    Генерирует детальный Excel-отчет за УКАЗАННЫЙ ПЕРИОД.
    """
    # <<< ВОТ ЭТА СТРОКА БЫЛА ПРОПУЩЕНА >>>
    today = datetime.now()
    
    start_of_period = start_date.replace(hour=0, minute=0, second=0)
    end_of_period = end_date.replace(hour=23, minute=59, second=59)

    # --- 1. СБОР ДАННЫХ ---
    all_bikes_data = defaultdict(lambda: {
        'model': '', 'vin': '', 'investor_name': 'Компания',
        'rent_income_monthly': 0.0, 'days_rented': 0, 'renters': set(),
        'buyout_monthly_income': 0.0, 'cumulative_buyout_income': 0.0,
        'total_deal_value': 0.0, 'remaining_debt': 0.0, 'progress_payments': '',
        'is_buyout': False, 'client_name': ''
    })
    total_expenses = 0.0
    expense_details = []
    occupied_bike_ids = set()

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row

            cursor = await conn.execute(
                """SELECT b.id, b.name, u.first_name, u.last_name FROM bikes b 
                   LEFT JOIN users u ON b.investor_id = u.id 
                   WHERE b.type = 'bike' AND LOWER(TRIM(b.name)) NOT LIKE 'test%'"""
            )
            for bike in await cursor.fetchall():
                parsed = parse_bike_name_and_vin(bike['name'])
                investor_name = f"{bike['first_name']} {bike['last_name'] or ''}".strip() if bike['first_name'] else 'Компания'
                all_bikes_data[bike['id']]['model'] = parsed['model']
                all_bikes_data[bike['id']]['vin'] = parsed['vin']
                all_bikes_data[bike['id']]['investor_name'] = investor_name

            sql_rent = """
                SELECT b.id as bike_id, bh.details, bh.timestamp, u.first_name, u.last_name FROM bike_history bh 
                JOIN bikes b ON bh.bike_id = b.id JOIN users u ON bh.user_id = u.id
                WHERE b.type = 'bike' AND bh.action IN ('Оплата аренды', 'Продление аренды', 'Аренда') 
                AND bh.timestamp BETWEEN ? AND ?
                AND LOWER(TRIM(COALESCE(u.first_name, '') || ' ' || COALESCE(u.last_name, ''))) NOT IN ('тест тестов', 'кирилл патрушев')
            """
            async with conn.execute(sql_rent, (start_of_period.strftime('%Y-%m-%d %H:%M:%S'), end_of_period.strftime('%Y-%m-%d %H:%M:%S'))) as cursor:
                async for row in cursor:
                    bike_id = row['bike_id']
                    if bike_id not in all_bikes_data: continue
                    occupied_bike_ids.add(bike_id)
                    income = _get_income_from_details(row['details'])
                    all_bikes_data[bike_id]['rent_income_monthly'] += income
                    all_bikes_data[bike_id]['renters'].add(f"{row['first_name'] or ''} {row['last_name'] or ''}".strip())
                    
                    payment_date = datetime.strptime(row['timestamp'], '%Y-%m-%d %H:%M:%S')
                    period = _parse_period_from_details(row['details'])
                    start_rent, end_rent = (datetime.strptime(period[0], '%d.%m.%Y'), datetime.strptime(period[1], '%d.%m.%Y')) if period else (None, None)
                    if not period:
                        model_key = get_bike_model_key(all_bikes_data[bike_id]['model'] + all_bikes_data[bike_id]['vin'])
                        duration = _find_rental_period_from_price(model_key, income)
                        if duration: start_rent, end_rent = payment_date, payment_date + timedelta(days=duration)
                    if start_rent and end_rent:
                        overlap_start = max(start_rent.date(), start_date.date())
                        overlap_end = min(end_rent.date(), end_date.date())
                        if overlap_end >= overlap_start:
                            all_bikes_data[bike_id]['days_rented'] += (overlap_end - overlap_start).days + 1
            
            sql_buyout_deals = """
                SELECT b.id as bike_id, bo.payment_plan_key, bo.payments_made, b.name as bike_name, b.type as item_type,
                       u_client.first_name as client_fname, u_client.last_name as client_lname
                FROM bookings bo 
                JOIN bikes b ON bo.bike_id = b.id
                JOIN users u_client ON bo.user_id = u_client.id
                WHERE bo.booking_type = 'buyout' AND bo.status = 'rented'
            """
            async with conn.execute(sql_buyout_deals) as cursor:
                async for deal in cursor:
                    bike_id = deal['bike_id']
                    if bike_id not in all_bikes_data: continue
                    occupied_bike_ids.add(bike_id)
                    plan = _get_plan_details(deal['payment_plan_key'], deal['bike_name'], deal['item_type'])
                    if not plan: continue
                    
                    payments_made = deal['payments_made'] or 0
                    total_payments = plan.get('total_payments', 0)
                    payment_amount = plan.get('payment_amount') or plan.get('first_payment', 0)
                    
                    all_bikes_data[bike_id]['is_buyout'] = True
                    all_bikes_data[bike_id]['client_name'] = f"{deal['client_fname'] or ''} {deal['client_lname'] or ''}".strip()
                    all_bikes_data[bike_id]['cumulative_buyout_income'] = payments_made * payment_amount
                    all_bikes_data[bike_id]['total_deal_value'] = total_payments * payment_amount
                    all_bikes_data[bike_id]['remaining_debt'] = all_bikes_data[bike_id]['total_deal_value'] - all_bikes_data[bike_id]['cumulative_buyout_income']
                    all_bikes_data[bike_id]['progress_payments'] = f"{payments_made}/{total_payments}"
            
            total_expenses, expense_details = await _get_expense_data_for_period(conn, start_date, end_date)

    except Exception as e:
        logging.error(f"Критическая ошибка при сборе данных для отчета: {e}", exc_info=True)
        return None
        
    # --- 2. ФИЛЬТРАЦИЯ И РАЗДЕЛЕНИЕ ДАННЫХ ---
    rent_report_items, buyout_report_items, free_bikes_report_items = [], [], []
    
    investor_name_filter = ""
    if investor_id:
        async with aiosqlite.connect(DB_FILE) as conn:
            cursor = await conn.execute("SELECT first_name, last_name FROM users WHERE id=?", (investor_id,))
            inv_user = await cursor.fetchone()
            if inv_user: investor_name_filter = f"{inv_user[0] or ''} {inv_user[1] or ''}".strip()

    for bike_id, data in all_bikes_data.items():
        passes_main_filter = False
        if report_type == 'own' and data['investor_name'] == 'Компания': passes_main_filter = True
        elif report_type == 'investor' and data['investor_name'] != 'Компания':
            if investor_id and data['investor_name'] == investor_name_filter: passes_main_filter = True
            elif not investor_id: passes_main_filter = True
        elif report_type == 'combined': passes_main_filter = True

        if passes_main_filter:
            if data['rent_income_monthly'] > 0:
                rent_report_items.append({'bike_id': bike_id, **data})
            if data['is_buyout']:
                buyout_report_items.append({'bike_id': bike_id, **data})
            if bike_id not in occupied_bike_ids:
                 free_bikes_report_items.append({'bike_id': bike_id, **data})

    # --- 3. ГЕНЕРАЦИЯ EXCEL ФАЙЛА ---
    if report_type == 'own':
        title = "Детальный отчет по велосипедам компании"
        filename_suffix = "own"
    elif report_type == 'investor':
        title = f"Отчет по инвестору: {investor_name_filter}" if investor_id else "Отчет по всем инвесторам"
        filename_suffix = f"investor_{investor_id or 'all'}"
    else: # combined
        title = "Общий детальный отчет"
        filename_suffix = "combined"

    workbook = openpyxl.Workbook()
    sheet = workbook.active
    _create_main_header(sheet, title, 8)
    _create_subtitle(sheet, 8)
    
    current_row = 5

    # --- ТАБЛИЦА 1: ВЫКУП ---
    if buyout_report_items:
        sheet.cell(row=current_row, column=1, value="Выкуп").font = Font(size=14, bold=True, color="1F497D")
        current_row += 1
        buyout_headers = ["№", "Владелец", "Велосипед", "Клиент", "Прогресс (пл.)", "Прогресс (₽)", "Осталось внести (₽)", "Общая сумма"]
        _format_table_headers(sheet, current_row, buyout_headers)
        current_row += 1

        buyout_report_items.sort(key=lambda x: x.get('cumulative_buyout_income', 0.0), reverse=True)
        for item in buyout_report_items:
            progress_rub = f"{item.get('cumulative_buyout_income', 0):,.0f} / {item.get('total_deal_value', 0):,.0f} ₽".replace(",", " ")
            sheet.append([
                item.get("bike_id"), item.get("investor_name"), f"{item.get('model')} {item.get('vin')}",
                item.get('client_name'), item.get('progress_payments'), progress_rub,
                item.get('remaining_debt', 0.0), item.get('total_deal_value', 0.0)
            ])
        _format_data_rows_and_autofit(sheet, header_row=current_row - 1, data_start_row=current_row, currency_columns=[7, 8])
        current_row = sheet.max_row + 3

    # --- ТАБЛИЦА 2: АРЕНДА ---
    if rent_report_items:
        sheet.cell(row=current_row, column=1, value="Аренда").font = Font(size=14, bold=True, color="1F497D")
        current_row += 1
        rent_headers = ["№", "Владелец", "Велосипед", "Клиент", "Дней в аренде (за период)", "Общий доход (факт)"]
        _format_table_headers(sheet, current_row, rent_headers)
        current_row += 1

        rent_report_items.sort(key=lambda x: x.get('days_rented', 0), reverse=True)
        for item in rent_report_items:
            sheet.append([
                item.get("bike_id"), item.get("investor_name"), f"{item.get('model')} {item.get('vin')}",
                ", ".join(item.get('renters', {'-'})), item.get('days_rented', 0), item.get('rent_income_monthly', 0.0)
            ])
        _format_data_rows_and_autofit(sheet, header_row=current_row - 1, data_start_row=current_row, currency_columns=[6])
        current_row = sheet.max_row + 3
        
    # --- ТАБЛИЦА 3: СВОБОДНЫЕ ВЕЛОСИПЕДЫ ---
    if free_bikes_report_items:
        sheet.cell(row=current_row, column=1, value="Свободные велосипеды").font = Font(size=14, bold=True, color="00B050")
        current_row += 1
        free_headers = ["№", "Владелец", "Велосипед"]
        _format_table_headers(sheet, current_row, free_headers)
        current_row += 1

        free_bikes_report_items.sort(key=lambda x: x['bike_id'])
        for item in free_bikes_report_items:
            sheet.append([
                item["bike_id"], item["investor_name"], f"{item['model']} {item['vin']}"
            ])
        _format_data_rows_and_autofit(sheet, header_row=current_row - 1, data_start_row=current_row, currency_columns=[])
        current_row = sheet.max_row + 2
    
    # --- ИТОГИ И РАСХОДЫ ---
    total_rent_monthly = sum(item.get('rent_income_monthly', 0.0) for item in rent_report_items)
    grand_total_income = total_rent_monthly
    
    _add_final_summary_with_expenses(sheet, grand_total_income, total_expenses, len(rent_report_items), 8)
    
    # --- ДИАГРАММА ---
    chart_data_row = sheet.max_row + 2
    sheet.cell(row=chart_data_row, column=1, value="Категория")
    sheet.cell(row=chart_data_row, column=2, value="Сумма")
    sheet.cell(row=chart_data_row + 1, column=1, value="Доходы")
    sheet.cell(row=chart_data_row + 1, column=2, value=grand_total_income)
    sheet.cell(row=chart_data_row + 2, column=1, value="Расходы")
    sheet.cell(row=chart_data_row + 2, column=2, value=total_expenses)
    
    pie = PieChart()
    labels = Reference(sheet, min_col=1, min_row=chart_data_row + 1, max_row=chart_data_row + 2)
    data = Reference(sheet, min_col=2, min_row=chart_data_row, max_row=chart_data_row + 2)
    pie.add_data(data, titles_from_data=True)
    pie.set_categories(labels)
    pie.title = "Соотношение Доходов и Расходов за Период"
    pie.dataLabels = DataLabelList()
    pie.dataLabels.showPercent = True
    sheet.add_chart(pie, "J" + str(sheet.max_row - 5 if sheet.max_row > 5 else 2))
    
    # --- Таблица расходов ---
    if expense_details:
        expense_start_row = sheet.max_row + 3
        if "Диаграмма" in str(sheet.cell(row=expense_start_row-1, column=1).value): # Доп отступ после диаграммы
            expense_start_row += 15 
        sheet.cell(row=expense_start_row, column=1, value="Детализация расходов за период").font = Font(size=14, bold=True, color="C00000")
        expense_headers = ["Дата", "Категория", "Подкатегория", "Наименование", "Кол-во", "Сумма", "Комментарий"]
        _format_table_headers(sheet, expense_start_row + 1, expense_headers)
        for exp in expense_details:
            category_ru, subcategory_ru = _get_expense_labels(exp['category'], exp['subcategory'])
            sheet.append([exp['created_at'][:10], category_ru, subcategory_ru, exp['item_name'], exp['quantity'], exp['amount'], exp['comment']])
        _format_data_rows_and_autofit(sheet, header_row=expense_start_row + 1, data_start_row=expense_start_row + 2, currency_columns=[6])
    
    filename = os.path.join(REPORTS_PATH, f"unified_report_{filename_suffix}_{today.strftime('%Y-%m-%d')}.xlsx")
    workbook.save(filename)
    return filename

# === КОНЕЦ БЛОКА 3 ===
async def _get_expense_data_for_period(conn: aiosqlite.Connection, start_date: datetime, end_date: datetime) -> tuple[float, list]:
    """Собирает все расходы за УКАЗАННЫЙ ПЕРИОД."""
    start_date_str = start_date.strftime('%Y-%m-%d 00:00:00')
    end_date_str = end_date.strftime('%Y-%m-%d 23:59:59')
    
    cursor = await conn.execute(
        "SELECT created_at, category, subcategory, item_name, quantity, amount, comment FROM expenses WHERE created_at BETWEEN ? AND ? ORDER BY created_at", 
        (start_date_str, end_date_str)
    )
    expense_details = await cursor.fetchall()
    total_expenses = sum(row['amount'] for row in expense_details)
    return total_expenses, expense_details
# =======================================================================================
# КОНЕЦ ПОЛНОЙ ФУНКЦИИ
# =======================================================================================
async def start_report_generator(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Запускается по команде /otchet и показывает главное меню выбора отчетов.
    Доступно только администраторам.
    """
    user_id = update.effective_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 Эта команда доступна только администраторам.")
        return

    keyboard = [
        [InlineKeyboardButton("📊 Отчет по нашим велосипедам", callback_data="report_generate_own")],
        [InlineKeyboardButton("💼 Отчет по инвесторам", callback_data="report_menu_investor")],
        [InlineKeyboardButton("🌐 Общий отчет (с расходами)", callback_data="report_generate_combined")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "📈 *Генератор отчетов*\n\n"
        "Выберите, какой отчет вы хотите сформировать за текущий месяц:",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )

def _format_right_headers(sheet, start_row: int, start_col: int, headers: list):
    """Вспомогательная функция для форматирования заголовков правой таблицы."""
    for i, header in enumerate(headers):
        cell = sheet.cell(row=start_row, column=start_col + i)
        cell.value = header
        cell.font = Font(name='Calibri', size=11, bold=True, color='FFFFFF')
        cell.fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type='solid')
        cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ statistics_menu НА ЭТУ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ statistics_menu НА ЭТУ ВЕРСИЮ
async def statistics_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Главное меню раздела 'Статистика', которое теперь запускает диалог запроса дат.
    """
    keyboard = [
        [InlineKeyboardButton("📊 Наши велосипеды (детально)", callback_data="stats_detailed_own")],
        [InlineKeyboardButton("💼 Велики Инвесторов (детально)", callback_data="stats_investor_menu")],
        [InlineKeyboardButton("🌐 Общий отчет (детально)", callback_data="stats_detailed_combined")],
        [InlineKeyboardButton("💸 Отчет по расходам (детально)", callback_data="stats_detailed_expenses")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    message_text = "Выберите тип отчета для формирования:"

    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text(message_text, reply_markup=reply_markup)
    else:
        await update.message.reply_text(message_text, reply_markup=reply_markup)

# ШАГ 2.1: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ
async def _get_monthly_expense_data(conn: aiosqlite.Connection) -> tuple[float, list]:
    """Собирает все расходы за текущий месяц."""
    start_of_month_str = datetime.now().replace(day=1, hour=0, minute=0, second=0).strftime('%Y-%m-%d %H:%M:%S')
    cursor = await conn.execute("SELECT created_at, category, subcategory, item_name, quantity, amount, comment FROM expenses WHERE created_at >= ? ORDER BY created_at", (start_of_month_str,))
    expense_details = await cursor.fetchall()
    total_expenses = sum(row['amount'] for row in expense_details)
    return total_expenses, expense_details

def _add_final_summary_with_expenses(sheet, total_income: float, total_expenses: float, num_operations: int, col_span: int):
    """Добавляет финальный блок итогов с доходами, расходами и чистой прибылью (ИСПРАВЛЕННАЯ ВЕРСИЯ)."""
    summary_row = sheet.max_row + 3
    
    # --- Общий доход ---
    label_cell_income = sheet.cell(row=summary_row, column=col_span - 1, value="ОБЩИЙ ДОХОД ЗА МЕСЯЦ:")
    label_cell_income.font = Font(name='Calibri', size=12, bold=True)
    label_cell_income.alignment = Alignment(horizontal='right')
    
    value_cell_income = sheet.cell(row=summary_row, column=col_span, value=total_income)
    value_cell_income.number_format = '#,##0.00 ₽'
    value_cell_income.font = Font(name='Calibri', size=12, bold=True)

    # --- Общие расходы ---
    label_cell_expense = sheet.cell(row=summary_row + 1, column=col_span - 1, value="ОБЩИЕ РАСХОДЫ ЗА МЕСЯЦ:")
    label_cell_expense.font = Font(name='Calibri', size=12, bold=True, color="FF0000")
    label_cell_expense.alignment = Alignment(horizontal='right')
    
    value_cell_expense = sheet.cell(row=summary_row + 1, column=col_span, value=total_expenses)
    value_cell_expense.number_format = '#,##0.00 ₽'
    value_cell_expense.font = Font(name='Calibri', size=12, bold=True, color="FF0000")

    # --- Чистая прибыль ---
    net_income = total_income - total_expenses
    label_cell_net = sheet.cell(row=summary_row + 2, column=col_span - 1, value="ЧИСТАЯ ПРИБЫЛЬ:")
    label_cell_net.font = Font(name='Calibri', size=14, bold=True, color="00B050")
    label_cell_net.alignment = Alignment(horizontal='right')
    
    value_cell_net = sheet.cell(row=summary_row + 2, column=col_span, value=net_income)
    value_cell_net.number_format = '#,##0.00 ₽'
    value_cell_net.font = Font(name='Calibri', size=14, bold=True, color="00B050")

    # === ГЛАВНОЕ ИСПРАВЛЕНИЕ ЗДЕСЬ ===
    # Рассчитываем необходимую ширину для столбцов с текстом и с суммами
    # и принудительно устанавливаем её, если она больше текущей.
    
    # Ширина для столбца с текстом
    label_col_letter = get_column_letter(col_span - 1)
    required_label_width = len("ОБЩИЙ ДОХОД ЗА МЕСЯЦ:") + 2
    if sheet.column_dimensions[label_col_letter].width < required_label_width:
        sheet.column_dimensions[label_col_letter].width = required_label_width

    # Ширина для столбца с суммами
    value_col_letter = get_column_letter(col_span)
    # Находим самое длинное число из итогов
    max_value_len = max(len(f"{total_income:,.2f}"), len(f"{total_expenses:,.2f}"), len(f"{net_income:,.2f}"))
    required_value_width = max_value_len + 5 # +5 для знака рубля и отступов
    if sheet.column_dimensions[value_col_letter].width < required_value_width:
        sheet.column_dimensions[value_col_letter].width = required_value_width
async def investor_stats_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает подменю для выбора отчета по инвесторским велосипедам:
    - По всем инвесторам сразу.
    - Выбрать конкретного инвестора.
    """
    query = update.callback_query
    await query.answer()

    keyboard = [
        # Кнопка для генерации отчета сразу по всем инвесторам
        [InlineKeyboardButton("📊 Отчет по всем инвесторам", callback_data="stats_detailed_investor_all")],
        
        # Кнопка для перехода к списку инвесторов (добавим _0 для пагинации на следующем шаге)
        [InlineKeyboardButton("👤 Выбрать конкретного инвестора", callback_data="stats_select_investor_0")], 
        
        # Кнопка "Назад" возвращает нас в главное меню статистики
        [InlineKeyboardButton("⬅️ Назад в меню статистики", callback_data="stats_back_to_main")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        "Отчеты по инвесторским велосипедам. Выберите действие:",
        reply_markup=reply_markup
    )

async def income_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Показывает подменю для выбора типа велосипедов (наши, инвесторские, все)."""
    query = update.callback_query
    await query.answer()

    income_type = query.data.split('_')[1] # 'rent' или 'buyout'

    keyboard = [
        [InlineKeyboardButton("🚲 Наши", callback_data=f"stats_report_{income_type}_own")],
        [InlineKeyboardButton("💼 Инвесторские", callback_data=f"stats_report_{income_type}_investor")],
        [InlineKeyboardButton("🌐 Все", callback_data=f"stats_report_{income_type}_all")],
        [InlineKeyboardButton("⬅️ Назад", callback_data="stats_back_to_main")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    title = "по аренде" if income_type == "rent" else "по выкупу"
    await query.edit_message_text(f"Статистика доходов {title}. \nВыберите категорию велосипедов:", reply_markup=reply_markup)


def _get_income_from_details(details: str) -> float:
    """Вспомогательная функция для извлечения суммы из строки 'details'."""
    if not details:
        return 0.0
    # Ищем число (целое или с точкой/запятой) после слова "сумма:"
    match = re.search(r'сумма:\s*([\d\.,]+)', details, re.IGNORECASE)
    if match:
        try:
            # Заменяем запятую на точку и преобразуем в float
            return float(match.group(1).replace(',', '.'))
        except (ValueError, IndexError):
            return 0.0
    return 0.0

async def show_income_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Вызывает соответствующий генератор Excel-отчетов и отправляет файл.
    """
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("⏳ Генерирую Excel-отчет, это может занять до 30 секунд...")

    try:
        parts = query.data.split('_')
        income_type = parts[2]
        owner_type = parts[3]

        filename = None
        if income_type == 'rent':
            filename = await generate_rent_excel_report(owner_type)
        else: # buyout
            filename = await generate_buyout_excel_report(owner_type)

        if filename and os.path.exists(filename):
            with open(filename, 'rb') as file:
                await context.bot.send_document(
                    chat_id=query.message.chat.id,
                    document=file,
                    caption=f"✅ Ваш отчет по доходам готов."
                )
            os.remove(filename) # Удаляем временный файл после отправки
            await query.message.delete() # Удаляем сообщение "Генерирую..."
        else:
            await query.edit_message_text("😔 В этой категории нет данных для отчета за текущий месяц.")

    except Exception as e:
        logger.error(f"Ошибка при генерации Excel-отчета: {e}", exc_info=True)
        await query.edit_message_text(f"❌ Произошла ошибка: {e}")

# <<< КОНЕЦ НОВОГО БЛОКА КОДА ДЛЯ СТАТИСТИКИ >>>    
# =======================================================================================
# НОВЫЙ МОДУЛЬ ГЕНЕРАЦИИ EXCEL-ОТЧЕТОВ С УЧЕТОМ РАСХОДОВ
# =======================================================================================
# ШАГ 2.1: ВСТАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ ДЛЯ МЕНЮ ИНВЕСТОРОВ

# =======================================================================================
# ФИНАЛЬНЫЙ БЛОК КОДА ДЛЯ НОВОГО ГЕНЕРАТОРА ОТЧЕТОВ С РАСХОДАМИ
# Вставьте этот блок в ваш код.
# =======================================================================================

# --- НОВАЯ ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ СБОРА ДАННЫХ ПО ВЫКУПАМ (версия для нового отчета) ---
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ _get_new_buyout_data_for_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ СТАРУЮ ФУНКЦИЮ _get_new_buyout_data_for_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ _get_buyout_data_for_report НА ЭТУ ВЕРСИЮ
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ _get_buyout_data_for_report НА ЭТУ ВЕРСИЮ
async def _get_buyout_data_for_report(conn: aiosqlite.Connection, owner_filter_sql: str, owner_filter_params: tuple):
    stats = defaultdict(lambda: {'bikes': {}})
    today = datetime.now()
    start_of_month_str = today.replace(day=1, hour=0, minute=0, second=0).strftime('%Y-%m-%d %H:%M:%S')
    sql_deals = f"""
        SELECT b.id as bike_id, b.name as bike_name, u_investor.first_name as investor_fname, 
               u_investor.last_name as investor_lname, bo.payment_plan_key, bo.payments_made, b.type as item_type
        FROM bookings bo JOIN bikes b ON bo.bike_id = b.id LEFT JOIN users u_investor ON b.investor_id = u_investor.id
        WHERE bo.booking_type = 'buyout' AND bo.status = 'rented' {owner_filter_sql}
    """
    async with conn.execute(sql_deals, owner_filter_params) as cursor:
        async for deal in cursor:
            plan = _get_plan_details(deal['payment_plan_key'], deal['bike_name'], deal['item_type'])
            if not plan: continue
            owner_name = "Компания" if "IS NULL" in owner_filter_sql else f"{deal['first_name'] or ''} {deal['last_name'] or ''}".strip()
            payments_made = deal['payments_made'] or 0
            total_payments = plan.get('total_payments', 0)
            payment_amount = plan.get('payment_amount') or plan.get('first_payment', 0)
            paid_amount = payments_made * payment_amount
            total_deal_value = total_payments * payment_amount
            remaining_debt = total_deal_value - paid_amount # <-- РАСЧЕТ ОСТАТКА ДОЛГА
            stats[owner_name]['bikes'][deal['bike_id']] = {
                'monthly_income': 0.0,
                'cumulative_income': paid_amount,
                'remaining_debt': remaining_debt if remaining_debt > 0 else 0, # <-- НОВОЕ ПОЛЕ
                'progress_payments': f"{payments_made}/{total_payments}"
            }
    sql_income = f"""
        SELECT b.id as bike_id, u_investor.first_name, u_investor.last_name, bh.details
        FROM bike_history bh JOIN bikes b ON bh.bike_id = b.id LEFT JOIN users u_investor ON b.investor_id = u_investor.id
        WHERE bh.action IN ('Выкуп (1-й взнос)', 'Платеж по выкупу', 'Досрочное погашение', 'Выкуп АКБ (1-й взнос)', 'Платеж по выкупу (АКБ)')
        AND bh.timestamp >= ? {owner_filter_sql}
    """
    async with conn.execute(sql_income, (start_of_month_str,) + owner_filter_params) as cursor:
        async for row in cursor:
            owner_name = "Компания" if "IS NULL" in owner_filter_sql else f"{row['first_name'] or ''} {row['last_name'] or ''}".strip()
            if owner_name in stats and row['bike_id'] in stats[owner_name]['bikes']:
                income = _get_income_from_details(row['details'])
                stats[owner_name]['bikes'][row['bike_id']]['monthly_income'] += income
    return stats


# --- НОВЫЙ УНИВЕРСАЛЬНЫЙ ГЕНЕРАТОР ОТЧЕТОВ ---
# ЗАМЕНИТЕ ВАШУ ФУНКЦИЮ generate_new_master_report НА ЭТУ ВЕРСИЮ
async def generate_new_master_report(report_type: str, investor_id: int | None = None) -> str:
    today = datetime.now()
    start_of_month_str = today.replace(day=1, hour=0, minute=0, second=0).strftime('%Y-%m-%d %H:%M:%S')

    income_data = defaultdict(lambda: {
        'rent_income': 0.0, 
        'buyout_monthly_income': 0.0, 
        'buyout_cumulative_income': 0.0, # <-- НОВОЕ ПОЛЕ
        'bike_name': '', 
        'investor_name': 'Компания'
    })
    total_expenses = 0.0

    async with aiosqlite.connect(DB_FILE) as conn:
        conn.row_factory = aiosqlite.Row
        
        # 1.1 Сбор доходов от АРЕНДЫ (без изменений)
        sql_rent_income = """
            SELECT b.id as bike_id, b.name as bike_name, bh.details, u_investor.first_name, u_investor.last_name, b.investor_id
            FROM bike_history bh JOIN bikes b ON bh.bike_id = b.id LEFT JOIN users u_investor ON b.investor_id = u_investor.id
            WHERE bh.action IN ('Оплата аренды', 'Продление аренды', 'Аренда', 'Аренда доп. АКБ') AND bh.timestamp >= ?
        """
        async with conn.execute(sql_rent_income, (start_of_month_str,)) as cursor:
            async for row in cursor:
                income = _get_income_from_details(row['details'])
                bike_id = row['bike_id']
                income_data[bike_id]['bike_name'] = row['bike_name']
                if row['investor_id']:
                    income_data[bike_id]['investor_name'] = f"{row['first_name'] or ''} {row['last_name'] or ''}".strip()
                income_data[bike_id]['rent_income'] += income

        # 1.2 Сбор доходов от ВЫКУПА (используем новую логику)
        buyout_data_inv = await _get_new_buyout_data_for_report(conn, "AND b.investor_id IS NOT NULL", ())
        buyout_data_own = await _get_new_buyout_data_for_report(conn, "AND b.investor_id IS NULL", ())
        
        all_buyout_data = {**buyout_data_inv, **buyout_data_own}
        for owner, data in all_buyout_data.items():
            for bike_id, bike_data in data['bikes'].items():
                income_data[bike_id]['buyout_monthly_income'] += bike_data['monthly_income']
                income_data[bike_id]['buyout_cumulative_income'] = bike_data['cumulative_income'] # <-- СОХРАНЯЕМ ОБЩИЙ ДОХОД
                if not income_data[bike_id]['bike_name']:
                     bike_cursor = await conn.execute("SELECT name FROM bikes where id = ?", (bike_id,))
                     bike_name_row = await bike_cursor.fetchone()
                     if bike_name_row: income_data[bike_id]['bike_name'] = bike_name_row[0]
                if owner != "Компания":
                    income_data[bike_id]['investor_name'] = owner
        
        # 1.3 Сбор расходов (без изменений)
        cursor = await conn.execute("SELECT amount FROM expenses WHERE created_at >= ?", (start_of_month_str,))
        expenses = await cursor.fetchall()
        if expenses:
            total_expenses = sum(e['amount'] for e in expenses)

    # --- Фильтрация и подготовка данных (без изменений) ---
    report_items = []
    title = ""
    filename_suffix = ""
    if report_type == 'own':
        title = "Отчет по велосипедам компании"
        filename_suffix = "own"
        for bike_id, data in income_data.items():
            if data['investor_name'] == 'Компания':
                report_items.append({'bike_id': bike_id, **data})
    elif report_type == 'investor':
        # ... (логика для инвесторов остается прежней)
        title = "Отчет по всем инвесторам"
        filename_suffix = "investors_all"
        if investor_id:
            async with aiosqlite.connect(DB_FILE) as conn:
                cursor = await conn.execute("SELECT first_name, last_name FROM users WHERE id=?", (investor_id,))
                inv_user = await cursor.fetchone()
                investor_name_filter = f"{inv_user[0] or ''} {inv_user[1] or ''}".strip()
                title = f"Отчет по инвестору: {investor_name_filter}"
                filename_suffix = f"investor_{investor_id}"
            for bike_id, data in income_data.items():
                if data['investor_name'] == investor_name_filter:
                    report_items.append({'bike_id': bike_id, **data})
        else:
            for bike_id, data in income_data.items():
                if data['investor_name'] != 'Компания':
                    report_items.append({'bike_id': bike_id, **data})
    elif report_type == 'combined':
        title = "Общий отчет по всем доходам и расходам"
        filename_suffix = "combined"
        for bike_id, data in income_data.items():
            report_items.append({'bike_id': bike_id, **data})

    # --- Генерация Excel файла ---
    workbook = openpyxl.Workbook()
    sheet = workbook.active
    headers = ["№", "Владелец", "Велосипед", "Доход от аренды", "Доход от выкупа", "Общий доход"]
    _create_main_header(sheet, title, len(headers))
    _create_subtitle(sheet, len(headers))
    _format_table_headers(sheet, 4, headers)

    total_rent = sum(item['rent_income'] for item in report_items)
    total_buyout_monthly = sum(item['buyout_monthly_income'] for item in report_items)
    
    report_items.sort(key=lambda x: x['rent_income'] + x['buyout_cumulative_income'], reverse=True)

    for item in report_items:
        # <<< ИЗМЕНЕНИЕ: В колонку "Доход от выкупа" теперь идет ОБЩАЯ СУММА >>>
        sheet.append([
            item["bike_id"], item["investor_name"], item["bike_name"],
            item["rent_income"],
            item["buyout_cumulative_income"], # <-- ИЗМЕНЕНО
            item['rent_income'] + item['buyout_cumulative_income']
        ])
    
    _format_data_rows_and_autofit(sheet, header_row=4, data_start_row=5, currency_columns=[4, 5, 6])

    # --- Блок итогов (используем доход за МЕСЯЦ) ---
    summary_row = sheet.max_row + 2
    sheet.cell(row=summary_row, column=4, value="Общий доход от аренды (за месяц):").font = Font(bold=True)
    sheet.cell(row=summary_row, column=5, value=total_rent).number_format = '#,##0.00 ₽'
    sheet.cell(row=summary_row + 1, column=4, value="Общий доход от выкупа (за месяц):").font = Font(bold=True)
    sheet.cell(row=summary_row + 1, column=5, value=total_buyout_monthly).number_format = '#,##0.00 ₽'
    sheet.cell(row=summary_row + 2, column=4, value="Общие расходы за месяц:").font = Font(bold=True, color="FF0000")
    sheet.cell(row=summary_row + 2, column=5, value=total_expenses).number_format = '#,##0.00 ₽'
    net_income = total_rent + total_buyout_monthly - total_expenses
    sheet.cell(row=summary_row + 3, column=4, value="ЧИСТАЯ ПРИБЫЛЬ (за месяц):").font = Font(bold=True, size=14, color="00B050")
    total_cell = sheet.cell(row=summary_row + 3, column=5, value=net_income)
    total_cell.font = Font(bold=True, size=14)
    total_cell.number_format = '#,##0.00 ₽'

    filename = os.path.join(REPORTS_PATH, f"new_report_{filename_suffix}_{today.strftime('%Y-%m')}.xlsx")
    workbook.save(filename)
    return filename

async def send_new_generated_report(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Универсальный обработчик для НОВОЙ системы отчетов.
    """
    query = update.callback_query
    await query.answer()
    
    parts = query.data.split('_')  # e.g., ['new', 'report', 'generate', 'own'] or ['new', 'report', 'generate', 'investor', '12345']
    report_type = parts[3]
    investor_id = int(parts[4]) if len(parts) > 4 and parts[4].isdigit() else None
    
    status_message = await query.edit_message_text("⏳ Генерирую Excel-отчет, это может занять до минуты...")

    try:
        filename = await generate_new_master_report(report_type=report_type, investor_id=investor_id)

        if filename and os.path.exists(filename):
            with open(filename, 'rb') as file:
                await context.bot.send_document(
                    chat_id=query.from_user.id,
                    document=file,
                    caption="✅ Ваш финансовый отчет готов."
                )
            os.remove(filename)
            await status_message.delete()
        else:
            await status_message.edit_message_text("😔 Данных для формирования отчета за текущий месяц не найдено.")

    except Exception as e:
        logger.error(f"Ошибка при генерации нового отчета ({report_type}): {e}", exc_info=True)
        await status_message.edit_message_text(f"❌ Произошла критическая ошибка: {e}")

async def new_report_investor_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает НОВОЕ меню для выбора отчета по инвесторам:
    - По всем инвесторам сразу.
    - Выбрать конкретного инвестора.
    """
    query = update.callback_query
    await query.answer()

    # Извлекаем номер страницы. Если его нет, начинаем с 0.
    page = int(query.data.split('_')[-1]) if query.data.startswith('new_report_inv_list_') else 0
    PAGE_SIZE = 5

    try:
        async with aiosqlite.connect(DB_FILE) as conn:
            conn.row_factory = aiosqlite.Row
            count_cursor = await conn.execute("SELECT COUNT(DISTINCT investor_id) FROM bikes WHERE investor_id IS NOT NULL")
            total_items = (await count_cursor.fetchone())[0]

            if total_items == 0:
                await query.edit_message_text(
                    "Не найдено инвесторов с привязанными велосипедами.",
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Назад", callback_data="new_report_back_to_main")]])
                )
                return

            cursor = await conn.execute(
                """SELECT DISTINCT b.investor_id, u.first_name, u.last_name
                   FROM bikes b JOIN users u ON b.investor_id = u.id
                   WHERE b.investor_id IS NOT NULL ORDER BY u.last_name, u.first_name
                   LIMIT ? OFFSET ?""",
                (PAGE_SIZE, page * PAGE_SIZE)
            )
            investors = await cursor.fetchall()

        keyboard = [
            # Кнопка для отчета по всем инвесторам
            [InlineKeyboardButton("📊 Отчет по всем инвесторам", callback_data="new_report_generate_investor_all")],
        ]
        
        # Кнопки для каждого инвестора
        for inv in investors:
            keyboard.append([InlineKeyboardButton(
                f"{inv['first_name']} {inv['last_name'] or ''}",
                callback_data=f"new_report_generate_investor_{inv['investor_id']}"
            )])

        # Пагинация
        total_pages = (total_items + PAGE_SIZE - 1) // PAGE_SIZE
        pagination_row = []
        if page > 0:
            pagination_row.append(InlineKeyboardButton("⬅️", callback_data=f"new_report_inv_list_{page - 1}"))
        if page < total_pages - 1:
            pagination_row.append(InlineKeyboardButton("➡️", callback_data=f"new_report_inv_list_{page + 1}"))
        
        if pagination_row: keyboard.append(pagination_row)
        
        # Кнопка "Назад"
        keyboard.append([InlineKeyboardButton("⬅️ Назад", callback_data="new_report_back_to_main")])

        await query.edit_message_text(
            f"Выберите инвестора для отчета или запросите отчет по всем сразу (Стр. {page + 1}/{total_pages}):",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    except Exception as e:
        logger.error(f"Ошибка при формировании списка инвесторов для нового отчета: {e}", exc_info=True)
        await query.edit_message_text("❌ Произошла ошибка при загрузке списка инвесторов.")
# ШАГ 1.1: ДОБАВЬТЕ ЭТУ НОВУЮ ФУНКЦИЮ

async def start_new_report_generator(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Запускается по команде /otchet и показывает главное меню выбора отчетов.
    Доступно только администраторам.
    """
    user_id = update.effective_user.id
    if not is_admin(user_id):
        await update.message.reply_text("🚫 Эта команда доступна только администраторам.")
        return

    keyboard = [
        [InlineKeyboardButton("📊 Отчет по нашим велосипедам", callback_data="new_report_generate_own")],
        [InlineKeyboardButton("💼 Отчет по инвесторам", callback_data="new_report_investor_menu")],
        [InlineKeyboardButton("🌐 Общий отчет", callback_data="new_report_generate_combined")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "📈 *Генератор финансовых отчетов*\n\n"
        "Выберите, какой отчет с учетом расходов вы хотите сформировать за текущий месяц:",
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
# Создаем обработчик для клиента

def main():
    # Создаем базу данных 🏗️
    setup_database()
    job_queue = JobQueue()
    
    # Сначала объявляем, что переменная application будет глобальной
    global application 
    
    # Затем присваиваем ей значение
    application = (
        Application.builder()
        .token("7393557373:AAFB6NTTd551raYDASM7d1XhvP9wAFlVmpY")
        .job_queue(job_queue)
        .post_init(post_init) 
        .build()
    )
    set_tariffs_from_card_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_set_tariffs_from_card, pattern="^set_rent_tariffs_")],
    states={
        AWAIT_RENT_TARIFFS_FROM_CARD: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_rent_tariffs_from_card)],
    },
    fallbacks=[CommandHandler("cancel", cancel_edit_bike)], # Можно использовать существующую функцию отмены
)
    application.add_handler(set_tariffs_from_card_handler)
    application.add_handler(CallbackQueryHandler(request_extension, pattern=r"^auto_prolong_"))
    application.add_handler(CallbackQueryHandler(request_extension, pattern=r"^auto_prolong_7_"))
    application.add_handler(CallbackQueryHandler(accept_extension, pattern=r"^accept_extension_"))
    manage_rentals_handler = ConversationHandler(
    entry_points=[
        MessageHandler(filters.Regex("^🗓️ Управление арендами$"), manage_rentals)
    ],
    states={
        MANAGE_RENTALS_MENU: [
            CallbackQueryHandler(show_filtered_rentals, pattern="^rental_filter_"),
            CallbackQueryHandler(poisk_start, pattern="^poisk_start$"),
            # ADD THIS LINE:
            CallbackQueryHandler(handle_search_pagination, pattern="^search_page_") 
        ],
        AWAITING_POISK_INPUT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, poisk_handle)
        ],
    },
    fallbacks=[
        CommandHandler("cancel", cancel_repair), 
        CallbackQueryHandler(cancel_repair, pattern="^cancel_repair$")
    ],
    allow_reentry=True
)
    application.add_handler(manage_rentals_handler)
    application.add_handler(CallbackQueryHandler(new_report_investor_menu, pattern="^new_report_investor_menu$|^new_report_inv_list_"))
    edit_buyout_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(edit_buyout_plan_start, pattern=r"^edit_buyout_")],
    states={
        AWAIT_TOTAL_PAYMENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_new_total_payments)],
        AWAIT_PAYMENT_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_new_payment_amount)],
        AWAIT_PERIOD_DAYS: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_updated_buyout_plan)], # <-- Используем новую финальную функцию
    },
    fallbacks=[CommandHandler("cancel", universal_cancel)], # Убедитесь, что у вас есть функция отмены
)
    
    application.add_handler(edit_buyout_handler)
    detailed_stats_handler = ConversationHandler(
        entry_points=[
            # Этот паттерн перехватит все кнопки из меню "Статистика"
            CallbackQueryHandler(start_detailed_report_date_prompt, pattern="^stats_detailed_")
        ],
        states={
            STATS_AWAIT_DATE_RANGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_detailed_report_dates)],
        },
        fallbacks=[CommandHandler("cancel", universal_cancel)],
        allow_reentry=True
    )
    application.add_handler(detailed_stats_handler)
    application.add_handler(edit_buyout_handler)
    # Обработчик для кнопки "Назад", который возвращает в главное меню нового генератора
    application.add_handler(CallbackQueryHandler(send_new_generated_report, pattern="^new_report_generate_"))
    application.add_handler(CallbackQueryHandler(start_new_report_generator, pattern="^new_report_back_to_main$"))
    application.add_handler(CallbackQueryHandler(report_investor_menu, pattern="^report_menu_investor$|^report_investor_list_"))
    
    # Обработчик для кнопки "Назад"
    application.add_handler(CallbackQueryHandler(start_report_generator, pattern="^report_back_to_main$"))
    application.add_handler(CallbackQueryHandler(select_investor_for_report, pattern="^stats_select_investor_"))
    application.add_handler(CallbackQueryHandler(send_detailed_report, pattern="^stats_detailed_"))
    application.add_handler(CallbackQueryHandler(investor_stats_menu, pattern="^stats_investor_menu$"))
    application.add_handler(CallbackQueryHandler(statistics_menu, pattern="^stats_back_to_main$"))
    expense_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^💰 Расходы$"), start_expense_logging)],
        states={
            # Старые состояния для общих расходов
            EXP_SELECT_CATEGORY: [CallbackQueryHandler(select_main_category, pattern="^exp_cat_")],
            EXP_SELECT_SUBCATEGORY: [CallbackQueryHandler(select_subcategory, pattern="^(exp_sub_|exp_back_to_main)")],
            EXP_AWAIT_ITEM_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_item_name)],
            EXP_AWAIT_QUANTITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_quantity)],
            EXP_AWAIT_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_amount)],
            EXP_AWAIT_COMMENT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, save_expense),
                CallbackQueryHandler(save_expense, pattern="^exp_skip_comment$")
            ],
            # Новые состояния для расходов на велосипеды
            BEXP_AWAIT_BIKE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_bike_name_for_expense)],
            BEXP_AWAIT_EXPENSE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_expense_name_for_bike)],
            BEXP_AWAIT_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_amount_for_bike_expense)],
            BEXP_AWAIT_COMMENT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, save_bike_specific_expense),
                CallbackQueryHandler(save_bike_specific_expense, pattern="^bexp_skip_comment$")
            ]
        },
        fallbacks=[
            CommandHandler("cancel", cancel),
            CallbackQueryHandler(lambda u,c: u.callback_query.edit_message_text("Действие отменено.") or ConversationHandler.END, pattern="^exp_cancel$"),
        ],
        allow_reentry=True
    )
    application.add_handler(expense_handler)

    # --- Обработчик для генерации отчета по расходам ---
    expense_report_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^📊 Отчеты по расходам$"), start_report_generation)],
        states={
            AWAIT_EXPENSE_REPORT_DATES: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_date_range_for_report)],
        },
        fallbacks=[
            # --- ИЗМЕНЕНИЕ: Добавлены обработчики для отмены ---
            MessageHandler(filters.Regex("^❌ Отмена$"), universal_cancel),
            CommandHandler("cancel", universal_cancel)
            # --- КОНЕЦ ИЗМЕНЕНИЯ ---
        ]
    )
    edit_payments_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(edit_payments_start, pattern=r"^edit_payments_")],
    states={
        AWAIT_NEW_PAYMENT_COUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_new_payment_count)],
    },
    fallbacks=[CommandHandler("cancel", universal_cancel)],
)
    application.add_handler(edit_payments_handler)
    cancel_buyout_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(cancel_buyout_start, pattern=r"^cancel_buyout_")],
    states={
        CONFIRM_CANCEL_BUYOUT: [CallbackQueryHandler(cancel_buyout_confirm, pattern=r"^confirm_cancel_buyout_")],
    },
    fallbacks=[CommandHandler("cancel", universal_cancel)],
)
    application.add_handler(cancel_buyout_handler)

    application.add_handler(expense_report_handler)
    application.add_handler(expense_report_handler)
    application.add_handler(CallbackQueryHandler(admin_add_extra_day, pattern="^admin_add_day_"))
    application.add_handler(CallbackQueryHandler(admin_show_payment_history, pattern="^admin_payment_history_"))

    admin_fine_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(admin_start_fine, pattern="^admin_fine_")],
        states={
            ADMIN_AWAIT_FINE_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_process_fine_amount)],
            ADMIN_AWAIT_FINE_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_process_fine_reason)],
            # Состояние ADMIN_AWAIT_FINE_DUE_DATE полностью удалено
        },
        fallbacks=[CommandHandler("cancel", cancel_fine)],
    )
    application.add_handler(admin_fine_handler)

    admin_discount_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(admin_start_discount, pattern="^admin_discount_")],
        states={
            ADMIN_AWAIT_DISCOUNT_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_process_discount_amount)],
            ADMIN_AWAIT_DISCOUNT_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_process_discount_reason)],
            ADMIN_AWAIT_DISCOUNT_DURATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_process_discount_duration)],
        },
        fallbacks=[CommandHandler("cancel", cancel_discount_process)],
    )
    application.add_handler(admin_discount_handler)
    application.add_handler(admin_discount_handler)
    application.add_handler(CallbackQueryHandler(show_filtered_rentals, pattern="^rental_filter_"))
    application.add_handler(CallbackQueryHandler(show_investor_list_details, pattern=r"^inv_list_investors_"))
    application.add_handler(CallbackQueryHandler(show_investment_stats, pattern=r"^inv_show_stats$"))
    application.add_handler(CallbackQueryHandler(investment_main_menu, pattern=r"^inv_back_to_main$"))
    application.add_handler(CallbackQueryHandler(show_filtered_bike_list, pattern="^list_bikes_category_"))
    assign_asset_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(assign_asset_start, pattern=r"^inv_assign_start$")],
    states={
        INV_AWAIT_USER_SEARCH: [MessageHandler(filters.TEXT & ~filters.COMMAND, search_user_for_assign)],
        INV_SELECT_USER: [CallbackQueryHandler(select_user_for_assign, pattern=r"^inv_assign_user_")],
        INV_AWAIT_BIKE_SEARCH: [MessageHandler(filters.TEXT & ~filters.COMMAND, search_bike_for_assign)],
        INV_SELECT_BIKE: [CallbackQueryHandler(finalize_assign, pattern=r"^inv_assign_bike_")],
    },
    fallbacks=[CommandHandler("cancel", cancel_assign)],
    allow_reentry=True
)
    application.add_handler(assign_asset_handler)
    application.add_handler(CallbackQueryHandler(list_bikes, pattern="^back_to_main_bike_list$"))
    edit_user_handler = ConversationHandler(
        entry_points=[CommandHandler("edit_user", edit_user)],
        states={
            EDIT_SELECT_USER: [
                # <<< ИЗМЕНЕНИЕ ЗДЕСЬ: Шаблон стал более точным >>>
                # Теперь он реагирует только на 'edit_select_user_' или 'edit_page_'
                CallbackQueryHandler(edit_user_handle_user_selection, pattern="^edit_(select_user_|page_)")
            ],
            EDIT_SELECT_FIELD: [CallbackQueryHandler(edit_user_handle_field_selection, pattern="^edit_")],
            EDIT_AWAIT_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_user_handle_new_value)],
            EDIT_CONFIRM_DELETE: [
                CallbackQueryHandler(edit_user_delete_confirmed, pattern="^edit_confirm_delete_yes$"),
                CallbackQueryHandler(edit_user_back_to_profile, pattern="^edit_back_to_profile$")
            ]
        },
        fallbacks=[
            # Теперь этот обработчик будет срабатывать без проблем
            CallbackQueryHandler(edit_user_cancel, pattern="^edit_cancel$"),
            CommandHandler("cancel", edit_user_cancel)
        ],
        allow_reentry=True
    )
    application.add_handler(edit_user_handler)
    class IsAdminReplyingFilter(filters.UpdateFilter):
       def filter(self, update: Update) -> bool:
        # Проверяем, что это вообще текстовое сообщение
        if not (update.message and update.message.text):
            return False

        user_id = update.message.from_user.id
        
        # Проверяем, что пишет админ
        if not is_admin(user_id):
            return False

        # --- ГЛАВНОЕ ИЗМЕНЕНИЕ ---
        # Получаем user_data для этого пользователя через глобальный объект application
        # application.user_data - это словарь, где ключи - это user_id
        if user_id in application.user_data:
            user_context_data = application.user_data[user_id]
            # Теперь проверяем наличие нашего флага
            if 'awaiting_admin_input' in user_context_data:
                return True # Фильтр сработал!

        return False # Если юзера нет в user_data или нет флага
    is_admin_replying_filter = IsAdminReplyingFilter()
    stats_date_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_stats_date_selection, pattern="^stats_date_select$")],
    states={
        STATS_AWAIT_DATE: [
            CallbackQueryHandler(start_stats_date_selection, pattern="^stats_nav_"),
            CallbackQueryHandler(process_stats_date_selection, pattern="^stats_date_"),
        ],
    },
    fallbacks=[
        CallbackQueryHandler(lambda u, c: u.callback_query.edit_message_text("Действие отменено.") or ConversationHandler.END, pattern="^stats_cancel$"),
        CommandHandler("cancel", universal_cancel)
    ],
)
    application.add_handler(stats_date_handler)
    application.add_handler(MessageHandler(is_admin_replying_filter, admin_approve_deal))
    application.add_handler(MessageHandler(filters.Regex("^(💰Аренда/Выкуп|💰Аренда/Выкуп)$"), list_bikes))
    application.add_handler(CallbackQueryHandler(start_fine_payment_user, pattern=r"^pay_fine_"))
    client_approval_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(client_handle_signature, pattern=r"^(client_sign_|client_decline_)")],
    states={}, # Состояния не нужны, все происходит в одной функции
    fallbacks=[CommandHandler('cancel', cancel_deal)]
)
# 2. Обработчик для кнопок выбора модели (Kugoo, Wenbox, AKB) и
    application.add_handler(CallbackQueryHandler(auto_prolong_rental, pattern=r"^auto_prolong_7_"))
    application.add_handler(CommandHandler("otchet", start_new_report_generator))
    application.add_handler(CallbackQueryHandler(quick_rent_akb_payment, pattern=r"^quick_rent_akb_")) 
    application.add_handler(CallbackQueryHandler(list_bikes_by_model, pattern="^show_model_"))
    application.add_handler(CallbackQueryHandler(admin_approve_deal, pattern=r"^assign_"))
    application.add_handler(client_approval_handler)
# 3. Обработчик для выбора конкретного велосипеда и возврата к категориям
    application.add_handler(CallbackQueryHandler(bike_info, pattern="^(info_|back_to_categories)"))
    application.add_handler(MessageHandler(filters.Regex("^📋 Тарифы$"), show_tariffs))
    application.add_handler(MessageHandler(filters.Regex("^📜 Правила пользования$"), show_rules))
    application.add_handler(MessageHandler(filters.Regex("^🛠️ Ремонт$"), show_repair_info))
    application.add_handler(MessageHandler(filters.Regex("^👤 Личный кабинет$"), show_profile)) # Предполагаем, что функция show_profile уже есть
    application.add_handler(MessageHandler(filters.Regex("^📞 Контакты$"), show_contacts))
    # Создаем приложение 🤖
    application.add_handler(CallbackQueryHandler(admin_accept_return, pattern=r"^return_accept_"))
    complete_repair_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(start_complete_repair, pattern=r"^complete_repair_")],
        states={
            AWAIT_REPAIR_PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_repair_price)],
            AWAIT_DELAY_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, finalize_completed_repair)],
        },
        fallbacks=[CommandHandler("cancel", cancel)], # Используем общую функцию отмены
    )
    application.add_handler(CallbackQueryHandler(mark_paid, pattern=r"^paid_"))
    application.add_handler(complete_repair_handler)
    application.add_handler(CallbackQueryHandler(view_single_repair_request, pattern=r"^view_repair_"))
    application.add_handler(CallbackQueryHandler(leave_bike, pattern="^leave_bike_"))
    application.add_handler(CallbackQueryHandler(confirm_return_item, pattern=r"^confirm_return_"))
    application.add_handler(CallbackQueryHandler(confirm_return_item, pattern=r"^cancel_return$"))
    add_product_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.Regex("^➕ Добавить велосипед$"), start_add_product)],
    states={
        SELECT_PRODUCT_TYPE: [CallbackQueryHandler(select_product_type, pattern="^add_type_")],
        ENTER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_product_name)],
        ENTER_DESCRIPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_product_description)],
        
        # Ветка Велосипеда
        ENTER_RENT_PRICES: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_rent_prices)],
        ENTER_BUYOUT_TOTAL_PAYMENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_buyout_total_payments)],
        ENTER_BUYOUT_PAYMENT_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_buyout_payment_amount)],
        ENTER_BUYOUT_PERIOD_DAYS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_buyout_period)],

        # Ветка Аккумулятора
        ENTER_BATTERY_DETAILS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_battery_details)],
        
        # Общие шаги
        ENTER_QUANTITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_product_quantity)],
        AWAIT_PHOTO: [MessageHandler(filters.PHOTO, finalize_product_add)],
    },
    fallbacks=[
        CommandHandler("cancel", cancel_add_product),
        CallbackQueryHandler(cancel_add_product, pattern="^add_type_cancel$")
    ],
)
    
    
    
    application.add_handler(add_product_handler)


    discount_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^🎁 Выдать скидку$"), start_discount_process)],
        states={
            SELECT_USER_FOR_DISCOUNT: [CallbackQueryHandler(handle_user_selection_for_discount, pattern="^discount_")],
            ENTER_DISCOUNT_PERCENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_discount_percent)],
            ENTER_DISCOUNT_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_discount_reason)],
            ENTER_DISCOUNT_DURATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_discount_duration)],
        },
        fallbacks=[CommandHandler("cancel", cancel_discount_process)],
    )
    application.add_handler(discount_handler)
    
    user_custom_extension_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_user_custom_extension, pattern=r"^user_extend_custom_start_")],
    states={
        USER_AWAIT_CUSTOM_DAYS: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_user_custom_extension)],
    },
    fallbacks=[CommandHandler("cancel", cancel)], # Убедитесь, что у вас есть функция cancel
)
    application.add_handler(user_custom_extension_handler)
    complete_repair_conv_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(complete_repair, pattern=r"^complete_repair_\d+$")],
    states={
        CHOOSE_WARRANTY_TYPE: [
            CallbackQueryHandler(handle_warranty_choice, pattern=r"^warranty_(yes|no)_\d+$")
        ],
        ENTER_DELAY_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_delay_reason)
        ]
    },
    fallbacks=[CommandHandler("cancel", back_to_main_menu)],
    allow_reentry=True
)
    manual_extension_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(start_manual_extension, pattern=r"^manual_ext_start_")],
        states={
            AWAIT_MANUAL_DAYS: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_manual_extension_days)],
        },
        fallbacks=[
            CallbackQueryHandler(cancel_manual_extension, pattern="^cancel_repair$"), # Используем существующую кнопку отмены
            CommandHandler("cancel", cancel_manual_extension)
        ],
    )
    application.add_handler(manual_extension_handler)
    application.add_handler(complete_repair_conv_handler)
    smska_handler = ConversationHandler(
        entry_points=[CommandHandler('smska', smska_command)],
        states={
            WAITING_FOR_ADMIN_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, send_message_to_admins)
            ],
        },
        fallbacks=[CommandHandler('abort', abort_smska)],
    )
    application.add_handler(smska_handler)
    rental_repair_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(poisk_start, pattern="^poisk_start$"),
            CallbackQueryHandler(process_start_repair, pattern=r"^rental_repair_\d+$"),
            CallbackQueryHandler(view_user_rentals, pattern=r"^view_rentals_\d+$"),
            CallbackQueryHandler(accept_rental, pattern=r"^accept_bike_\d+$"),
            CallbackQueryHandler(process_accept_rental, pattern=r"^rental_accept_\d+$"),
            CallbackQueryHandler(extend_rental, pattern=r"^extend_rental_\d+$"),
            CallbackQueryHandler(handle_extension_choice, pattern=r"^extend_\d+_\d+$|^extend_custom_\d+$"),
            CallbackQueryHandler(handle_payment_confirmation, pattern=r"^payment_(yes|no)_\d+_\d+(_\d+)?$"),
            MessageHandler(filters.Regex("^Вернуться в главное меню$"), electrobike_cancel_rental),
            CallbackQueryHandler(cancel_repair, pattern="^cancel_repair$")
        ],
        states={
            POISK_STATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, poisk_handle)
            ],
            RENTAL_REPAIR_REASON: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_repair_reason)
            ],
            RENTAL_REPAIR_PERSON: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_repair_person)
            ],
            RENTAL_REPAIR_WARRANTY: [
                CallbackQueryHandler(handle_warranty, pattern="^warranty_")
            ],
            RENTAL_REPAIR_WARRANTY_AMOUNT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_warranty_amount)
            ],
            RENTAL_REPAIR_ESTIMATED_DATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_estimated_date)
            ],
            CUSTOM_EXTENSION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, process_custom_extension)
            ]
        },
        # <<< ВОТ ВАЖНАЯ ЧАСТЬ >>>
        fallbacks=[
            CallbackQueryHandler(cancel_repair, pattern="^cancel_repair$"),
            # Этот обработчик должен перехватывать нажатия на кнопки меню и выходить из диалога
            MessageHandler(filters.TEXT & ~filters.COMMAND, menu_handler)
        ]
    )
    application.add_handler(rental_repair_handler)

    rent_conversation_handler = ConversationHandler(
    entry_points=[
        MessageHandler(filters.Text("🚴‍ Сдать в аренду велосипед"), electrobike_rent_start)
    ],
    states={
        ELECTROBIKE_SELECT_USER: [
            CallbackQueryHandler(electrobike_user_state_handler),
            # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
            MessageHandler(filters.Regex(r"^🏠 Вернуться в главное меню$"), electrobike_cancel_rental),
            MessageHandler(filters.TEXT & ~filters.COMMAND, electrobike_user_state_handler)
        ],
        ELECTROBIKE_SELECT_BIKE: [
            CallbackQueryHandler(electrobike_bike_state_handler),
            # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
            MessageHandler(filters.Regex(r"^🏠 Вернуться в главное меню$"), electrobike_cancel_rental),
            MessageHandler(filters.TEXT & ~filters.COMMAND, electrobike_bike_state_handler)
        ],
        ELECTROBIKE_SELECT_DAYS: [
            # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
            MessageHandler(filters.Regex(r"^🏠 Вернуться в главное меню$"), electrobike_cancel_rental),
            CallbackQueryHandler(electrobike_select_rental_days, pattern=r"^electrobike_rental_days_")
        ],
        ELECTROBIKE_YANDEX_PRO: [
            # --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
            MessageHandler(filters.Regex(r"^🏠 Вернуться в главное меню$"), electrobike_cancel_rental),
            CallbackQueryHandler(electrobike_yandex_pro_handler, pattern=r"^yandex_pro_")
        ]
    },
    fallbacks=[CommandHandler("cancel", lambda u, c: ConversationHandler.END)],
    map_to_parent={
        ConversationHandler.END: ConversationHandler.END
    }
)



    application.add_handler(MessageHandler(filters.Regex("^📊 Статистика за день$"), show_daily_stats))
    rework_verification_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_rework_verification, pattern=r'^rework_')],
    states={
        AWAIT_REWORK_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, send_rework_reason)],
    },
    fallbacks=[CommandHandler('cancel', cancel_admin_action)],
)

    reject_verification_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_reject_verification, pattern=r'^reject_verification_')],
    states={
        AWAIT_REJECT_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, send_reject_reason)],
    },
    fallbacks=[CommandHandler('cancel', cancel_admin_action)],
)
    application.add_handler(rework_verification_handler)
    application.add_handler(reject_verification_handler)
    dispute_conversation = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_dispute, pattern=r"^dispute_fine$")],
    states={
        SELECT_FINE: [CallbackQueryHandler(select_fine_for_dispute, pattern=r"^dispute_\d+$")],
        UPLOAD_MEDIA: [
            MessageHandler(
                filters.PHOTO | filters.VIDEO | filters.Document.IMAGE | filters.Document.VIDEO,
                handle_dispute_media
            ),
            MessageHandler(
                filters.ALL & ~(filters.PHOTO | filters.VIDEO | filters.Document.IMAGE | filters.Document.VIDEO | filters.COMMAND),
                lambda update, ctx: update.message.reply_text("❌ Отправьте фото/видео доказательства")
            )
        ],
        ENTER_DISPUTE_COMMENT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, save_dispute_comment)
        ]
    },
    fallbacks=[
        CommandHandler("cancel", cancel_fine),
        MessageHandler(filters.Regex(r"^Отмена$"), cancel_fine)
    ],
    allow_reentry=True
)

    application.add_handler(CallbackQueryHandler(
    pay_fine_handler,
    pattern=r"^pay_fine_\d+$"
))

    application.add_handler(CallbackQueryHandler(
    fines_menu,
    pattern="^fines_menu$"
))
    date_edit_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(start_date_edit, pattern=r"^edit_date_")],
        states={
            AWAIT_NEW_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_new_date)],
        },
        fallbacks=[CommandHandler("cancel", universal_cancel)], # Используем универсальную отмену
    )
    application.add_handler(date_edit_handler)
    # Обработчики для добавления велосипеда

    # Обработчики для добавления запчастей
    # Обработчики для добавления запчастей
    add_part_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^➕ Добавить запчасть$"), add_part)],
        states={
            1: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_part_name)],
            2: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_part_description)],
            3: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_part_quantity)],  # <- Здесь замените на новый ввод количества
        4: [MessageHandler(filters.PHOTO, set_part_photo)],  # <- Переход к шагу добавления фото
    },
    fallbacks=[],
)

    # Обработчики для редактирования запчастей
    edit_part_conv = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_editing_part, pattern=r"^edit_part_\d+$")],
    states={
        EDITING_MENU: [CallbackQueryHandler(handle_editing_menu)],
        CHANGE_STATUS: [CallbackQueryHandler(handle_status_change)],
        CHANGE_QUANTITY: [CallbackQueryHandler(handle_quantity_change)]
    },
    fallbacks=[],
    map_to_parent={ConversationHandler.END: ConversationHandler.END}
)
    
    edit_bike_tariffs_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.Regex("^🛠️ Редактировать велосипеды$"), show_bike_list_for_editing)],
    states={
        EDIT_USER_MENU: [
            CallbackQueryHandler(show_main_edit_menu, pattern="^edit_bike_"),
            CallbackQueryHandler(handle_bike_list_pagination, pattern="^edit_page_"),
            CallbackQueryHandler(request_new_value, pattern="^edit_field_(name|description)$"),
            CallbackQueryHandler(show_tariffs_menu, pattern="^edit_field_tariffs$"),
            CallbackQueryHandler(request_availability_change, pattern="^edit_field_availability$"),
            # Handler for the delete button
            CallbackQueryHandler(handle_delete_request, pattern="^edit_action_delete$"),
        ],
        EDIT_AWAIT_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_text_value)],
        EDIT_AWAIT_DESCRIPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_text_value)],
        EDIT_TARIFFS_MENU: [
            CallbackQueryHandler(start_rent_edit, pattern="^tariffs_edit_rent$"),
            CallbackQueryHandler(start_buyout_edit, pattern="^tariffs_edit_buyout$"),
            CallbackQueryHandler(show_main_edit_menu, pattern="^tariffs_back_to_main$"),
        ],
        AWAIT_RENT_PRICES: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_rent_prices)],
        AWAIT_BUYOUT_PAYMENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_buyout_payments)],
        AWAIT_BUYOUT_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_buyout_amount)],
        AWAIT_BUYOUT_PERIOD: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_buyout_plan)],
        EDIT_AVAILABILITY: [
            CallbackQueryHandler(save_availability, pattern="^set_availability_"),
            CallbackQueryHandler(show_main_edit_menu, pattern="^back_to_edit_menu$")
        ],
        # New state and its handler for deletion confirmation
        EDIT_CONFIRM_DELETE_BIKE: [
            CallbackQueryHandler(delete_bike_confirmed, pattern="^confirm_delete_bike_")
        ]
    },
    fallbacks=[
        CallbackQueryHandler(cancel_edit_bike, pattern="^edit_cancel$"),
        CallbackQueryHandler(show_bike_list_for_editing, pattern="^edit_back_to_list$")
    ],
    allow_reentry=True
)
    application.add_handler(edit_bike_tariffs_handler)

    application.add_handler(CallbackQueryHandler(start_complete_repair_user, pattern=r"^pay_repair_"))
    # Обработчики для редактирования велосипедов

    edit_bike_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_editing_bike, pattern=r"^edit_\d+$"),
        CallbackQueryHandler(navigate_edit_pages, pattern=r"^prev_edit_page$|^next_edit_page$|^start_search$|^reset_search$")
    ],
    states={
        EDIT_MENU: [
            # <<< ИЗМЕНЕНИЕ: Добавлен pattern для кнопки удаления >>>
            CallbackQueryHandler(handle_edit_choice, pattern=r"^edit_(name|description|price|available|finish)$"),
            CallbackQueryHandler(handle_delete_request, pattern=r"^edit_delete$")
        ],
        EDIT_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, save_name),
            CallbackQueryHandler(cancel_input, pattern="^cancel_input$")
        ],
        EDIT_DESCRIPTION: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, save_description),
            CallbackQueryHandler(cancel_input, pattern="^cancel_input$")
        ],
        EDIT_PRICE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, save_price),
            CallbackQueryHandler(cancel_input, pattern="^cancel_input$")
        ],
        EDIT_AVAILABLE: [
            CallbackQueryHandler(set_availability, pattern=r"^set_available_[01]$"),
            CallbackQueryHandler(show_editing_menu, pattern="^back_to_menu$")
        ],
        EDIT_SEARCH: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_search_input)
        ]
    },
    fallbacks=[
        CommandHandler("cancel", cancel_edit),
        CallbackQueryHandler(cancel_edit, pattern="^edit_finish$"),
        CallbackQueryHandler(cancel_edit, pattern="^cancel_edit$")
    ],
    allow_reentry=True
)
    application.add_handler(CallbackQueryHandler(income_menu, pattern="^stats_rent_menu$"))
    application.add_handler(CallbackQueryHandler(income_menu, pattern="^stats_buyout_menu$"))
    application.add_handler(CallbackQueryHandler(statistics_menu, pattern="^stats_back_to_main$"))
    application.add_handler(CallbackQueryHandler(show_income_report, pattern="^stats_report_"))
    application.add_handler(CallbackQueryHandler(confirm_return_item, pattern=r"^confirm_return_"))
    application.add_handler(CommandHandler("otchet", generate_report_command))
    

    new_register_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.Regex("^📝 Зарегистрироваться$"), register)],
    states={
        REG_AWAIT_INPUT: [
            CallbackQueryHandler(handle_registration_input, pattern="^reg_input_"),
            MessageHandler(filters.TEXT | filters.CONTACT, handle_registration_input),
        ],
        REG_AWAIT_COUNTRY: [
            CallbackQueryHandler(handle_country_selection, pattern="^reg_country_"),
            CallbackQueryHandler(handle_foreigner_doc_action, pattern="^reg_action_"),
        ],
        # <-- НОВЫЕ СОСТОЯНИЯ И ОБРАБОТЧИКИ -->
        REG_AWAIT_LICENSE_CHOICE: [
            CallbackQueryHandler(handle_license_choice, pattern="^reg_license_")
        ],
        REG_AWAIT_LICENSE_PHOTO: [
            MessageHandler(filters.PHOTO, handle_license_photo)
        ],
        # <-- КОНЕЦ НОВЫХ БЛОКОВ -->
        REG_AWAIT_DOCS: [
            MessageHandler(filters.PHOTO, handle_document_photos)
        ],
        REG_AWAIT_VERIFICATION: [
            CallbackQueryHandler(handle_verification_result, pattern="^reg_verify_")
        ]
    },
    fallbacks=[
        CallbackQueryHandler(handle_registration_nav, pattern="^reg_nav_"),
        CommandHandler("cancel", cancel_registration),
    ],
    allow_reentry=True
)
    application.add_handler(new_register_handler)
    application.add_handler(CallbackQueryHandler(manage_bookings_panel, pattern="^refresh_bookings_panel$"))
    battery_rent_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_battery_rent, pattern=r"^rent_battery_")],
    states={
        BATTERY_RENT_CONFIRMATION: [CallbackQueryHandler(process_battery_rent_payment, pattern=r"^(confirm|cancel)_battery_rent$")],
    },
    fallbacks=[CommandHandler("cancel", cancel_add_product)], # Используем общую функцию отмены
)
    application.add_handler(battery_rent_handler)

    battery_buyout_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_battery_buyout, pattern=r"^buyout_battery_")],
    states={
        BATTERY_BUYOUT_SELECT_PLAN: [
            # Эта функция теперь обрабатывает и выбор плана, и кнопку "Назад"
            CallbackQueryHandler(select_battery_buyout_plan, pattern=r"^select_bb_plan_"),
            # Этот обработчик сработает на кнопку "Подтвердить и оплатить"
            CallbackQueryHandler(process_battery_buyout_payment, pattern=r"^confirm_battery_buyout$"),
            # Этот обработчик сработает на кнопку "Отмена"
            CallbackQueryHandler(cancel_add_product, pattern=r"^cancel_battery_buyout$")
        ],
        # Убрали состояние BATTERY_BUYOUT_CONFIRMATION, оно больше не нужно
    },
    fallbacks=[CommandHandler("cancel", cancel_add_product)],
)
    application.add_handler(battery_buyout_handler)






    ask_support_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^📩 Поддержка$"), ask_support)],
        states={
            1: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_question)],
        },
        fallbacks=[],
    )

    answer_question_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(answer_question, pattern="^answer_")],
        states={
            1: [MessageHandler(filters.TEXT & ~filters.COMMAND, send_answer)],
        },
        fallbacks=[],
    )

    send_news_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.Regex("^📢 Рассылка новостей$"), send_news)],
    states={
        1: [MessageHandler(filters.ALL, broadcast_news)],  # Принимаем и текст, и фото
    },
    fallbacks=[],
)

# В функции main()
    application.add_handler(CommandHandler("debug", debug_bikes))
    repair_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^🛠️ Заявка на ремонт$"), request_repair)],
        states={
            WAITING_FOR_PROBLEM: [
                CallbackQueryHandler(handle_problem_selection, pattern="^repair_")
            ],
            WAITING_FOR_CUSTOM_PROBLEM: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, save_custom_problem)
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)], # Убедитесь, что у вас есть функция cancel
    )

    repair_conv_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(accept_repair_request, pattern="^accept_repair_")],
    states={
        WAITING_FOR_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_time)],
        WAITING_FOR_PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_price)],
    },
    fallbacks=[],
)

    get_photo_id_handler = ConversationHandler(
    entry_points=[CommandHandler('get_photo_id', get_photo_id_start)],
    states={
        AWAITING_PHOTO_FOR_ID: [MessageHandler(filters.PHOTO, receive_photo_for_id)],
    },
    fallbacks=[CommandHandler('cancel', cancel_get_id)],
)
    application.add_handler(get_photo_id_handler)

    date_selection_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(select_day, pattern=r"^select_day$")],
    states={
        SELECT_DATE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_date_input),
        ],
        CHOOSE_HISTORY_TYPE: [
            CallbackQueryHandler(view_bike_history, pattern=r"^history_bike$"),
            CallbackQueryHandler(view_user_history, pattern=r"^history_user$"),
            CallbackQueryHandler(display_history, pattern=r"^history_pagination_.*"),
        ]
    },
    fallbacks=[
        CommandHandler("abort", abort_operation),
        CallbackQueryHandler(abort_operation, pattern=r"^abort$")
    ],
    allow_reentry=True
)
    poisk_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(poisk_start, pattern="^poisk_start$")],
    states={
        POISK_STATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, poisk_handle)]
    },
    fallbacks=[]
)

# Добавьте обработчик в приложение
    application.add_handler(poisk_handler)

# Добавляем глобальный обработчик для кнопки сброса

    application.add_handler(CallbackQueryHandler(clear_date_filter, pattern=r"^clear_date$"))
    # Определяем состояния



    fine_conversation_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.Regex(r"^💰 Назначить штраф$"), assign_fine_start)],
    states={
        SELECT_USER: [CallbackQueryHandler(select_user_for_fine, pattern=r"^fine_(user|pagination)_\w+")],
        ENTER_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_fine_amount)],
        ENTER_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_fine_reason)],
        ENTER_DUE_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_due_date)]
    },
    fallbacks=[
        CommandHandler("cancel", cancel_fine),
        MessageHandler(filters.Regex(r"^Отмена$"), cancel_fine)
    ],
    allow_reentry=True
)

    rejecttt = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_reject, pattern=r"^reject_\d+$")
    ],
    states={
        REJECT_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_reject_reason)
        ]
    },
    fallbacks=[
        CommandHandler("cancel", cancel),
        MessageHandler(filters.Regex(r"^Отмена$"), cancel)
    ],
    map_to_parent={ConversationHandler.END: ConversationHandler.END},
    allow_reentry=True
)

    view_fines_conversation = ConversationHandler(
    entry_points=[MessageHandler(filters.Regex(r"^📋 Список штрафов$"), view_fines_menu)],
    states={
        VIEW_FINES_CATEGORY: [CallbackQueryHandler(show_fines_category)],
        REJECT_REASON: [rejecttt]  # Теперь rejecttt уже объявлен
    },
    fallbacks=[
        CommandHandler("cancel", cancel),
        MessageHandler(filters.Regex(r"^Отмена$"), cancel),
        CallbackQueryHandler(show_fines_category)
    ],
    allow_reentry=True
)

    application.add_handler(view_fines_conversation)
    search_handlers = [
    # Поиск по фамилии
    ConversationHandler(
        entry_points=[CallbackQueryHandler(search_by_surname, pattern="^search_by_surname$")],
        states={
            INPUT_SURNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_surname_input)]
        },
        fallbacks=[CommandHandler("cancel", abort_operation)],
        map_to_parent={}
    ),

    # Поиск по велосипеду
    ConversationHandler(
        entry_points=[CallbackQueryHandler(search_by_bike, pattern="^search_by_bike$")],
        states={
            INPUT_BIKE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_bike_name_input)]
        },
        fallbacks=[CommandHandler("cancel", abort_operation)],
        map_to_parent={}
    ),

    ###################

    # Поиск по ключевым словам (НОВОЕ)
    ConversationHandler(
        entry_points=[CallbackQueryHandler(search_by_keyword, pattern="^search_by_keyword$")],
        states={
            INPUT_KEYWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_keyword_input)]
        },
        fallbacks=[CommandHandler("cancel", abort_operation)],
        map_to_parent={}
    ),


    # Обработчик деталей действия (НОВОЕ)
    CallbackQueryHandler(
        show_action_details,
        pattern=r"^action_detail_\d+$"
    )
]

    ###############
    buyout_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_buyout, pattern=r"^buyout_\d+$")],
    states={
        SELECT_BUYOUT_PLAN: [CallbackQueryHandler(select_buyout_plan, pattern=r"^select_buyout_")],
        CONFIRM_BUYOUT: [
            # ВЫЗЫВАЕМ НОВУЮ ФУНКЦИЮ ДЛЯ СОЗДАНИЯ ЗАЯВКИ
            CallbackQueryHandler(confirm_buyout_request, pattern=r"^confirm_buyout_payment$"),
            CallbackQueryHandler(start_buyout, pattern=r"^buyout_\d+$") # Кнопка "назад"
        ]
    },
    fallbacks=[CommandHandler("cancel", cancel)], # Добавьте функцию cancel, если ее нет
)
    application.add_handler(buyout_handler)
    application.add_handler(CommandHandler('test_notification', send_test_notification))
    application.add_handler(CallbackQueryHandler(accept_rental, pattern=r"^accept_rental_"))
    application.add_handler(CallbackQueryHandler(
    process_accept_rental,
    pattern=r"^rental_accept_"
))
    application.add_handler(CallbackQueryHandler(
    process_start_repair,
    pattern=r"^rental_repair_"
))

    application.add_handler(CallbackQueryHandler(
    display_history,
    pattern=r"^history_pagination_(bike|user)_\d+_\d+$"
))
    application.add_handler(CallbackQueryHandler(
    navigate_edit_pages,
    pattern=r"^(prev|next)_edit_page$"
))

    application.add_handler(CallbackQueryHandler(
        view_history_menu,
        pattern="^view_history$"
    ))

    application.add_handlers(search_handlers)

    # Обработчики для кнопок "История велосипеда" и "История пользователя"
    application.add_handler(CallbackQueryHandler(show_action_details, pattern="^action_detail_"))
    application.add_handler(CallbackQueryHandler(
    handle_search_pagination,
    pattern=r"^search_(\w+)_page_(\d+)$"
))

    repar_conv_handler = ConversationHandler(
    entry_points=[
        MessageHandler(filters.Text(["⚠️ Управление статусом"]), show_bike_list)
    ],
    states={
        SELECTING_BIKE: [
            CallbackQueryHandler(bike_selected, pattern=r"^select_bike_"),
            CallbackQueryHandler(handle_repair_pagination, pattern=r"^remont_pagi_"),
            CallbackQueryHandler(start_repair_search, pattern="^repair_search$"),
            CallbackQueryHandler(cancel_repair, pattern="^cancel_repair$")
        ],
        SELECTING_ACTION: [
            CallbackQueryHandler(action_selected, pattern="^set_"),
            CallbackQueryHandler(cancel_repair, pattern="^cancel_repair$")
        ],
        ENTERING_REPAIR_PERSON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, enter_repair_person)
        ],
        ENTERING_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, enter_reason)
        ],
        ENTERING_WARRANTY: [
            CallbackQueryHandler(enter_warranty, pattern="^warranty_")
        ],
        ENTERING_WARRANTY_AMOUNT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, enter_warranty_amount)
        ],
        ENTERING_ESTIMATED_DATE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, enter_estimated_date)
        ],
        ENTERING_DELAY_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, enter_delay_reason)
        ],
        SEARCHING: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_repair_search)
        ]
    },
    fallbacks=[
        CommandHandler("cancel", cancel_repair),
        MessageHandler(filters.Text(["🏠 Вернуться в главное меню"]), cancel_repair)
    ]
)
        # Обработчик для нового меню поиска пользователей
    user_search_handler = ConversationHandler(
        entry_points=[
            # Точка входа - нажатие на кнопку "Зарегистрированные пользователи"
            MessageHandler(filters.Regex("^👥 Зарегистрированные пользователи$"), search_users)
        ],
        states={
            # В этом состоянии бот ожидает нажатия на любую из кнопок меню
            USER_SEARCH_MENU: [
                CallbackQueryHandler(handle_user_search_menu, pattern="^user_")
            ],
            # В это состояние бот переходит, когда ожидает ввод текста для поиска
            AWAITING_SEARCH_INPUT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_user_search_input)
            ]
        },
        fallbacks=[
            # Обработчик для отмены операции
            CommandHandler("cancel", cancel)
        ],
        # Позволяет повторно входить в этот диалог
        allow_reentry=True
    )
    application.add_handler(user_search_handler)
    booking_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(book_bike, pattern="^book_")],
    states={
        # Состояние ожидания выбора ДАТЫ
        SELECTING_DATE: [
            CallbackQueryHandler(calendar_callback, pattern="^select_date_")
        ],
        # Состояние ожидания выбора ВРЕМЕНИ
        SELECTING_TIME: [
            CallbackQueryHandler(time_callback, pattern="^select_time_")
        ],
        # Состояние ожидания ПОДТВЕРЖДЕНИЯ
        CONFIRMING_BOOKING: [
            CallbackQueryHandler(finalize_booking, pattern="^(accept|reject)_booking$")
        ],
    },
    # <<< НАЧАЛО ИЗМЕНЕНИЙ >>>
    fallbacks=[
        # Позволяет выйти из диалога по команде /cancel
        CommandHandler("cancel", cancel),
        # ГЛАВНОЕ: Этот обработчик "ловит" любое текстовое сообщение,
        # которое не является командой, и вызывает основную функцию меню,
        # тем самым корректно выходя из диалога бронирования.
        MessageHandler(filters.TEXT & ~filters.COMMAND, menu_handler)
    ],
    # Позволяет боту заново войти в этот диалог, даже если он был прерван.
    allow_reentry=True
    # <<< КОНЕЦ ИЗМЕНЕНИЙ >>>
)
    application.add_handler(CallbackQueryHandler(pay_next_installment, pattern=r"^pay_next_\d+$"))
    application.add_handler(CallbackQueryHandler(pay_full_amount, pattern=r"^pay_full_\d+$"))
    application.add_handler(repar_conv_handler)
    application.add_handler(CallbackQueryHandler(view_completed_repairs, pattern="^paginate_completed_"))
    application.add_handler(CallbackQueryHandler(view_accepted_repairs, pattern="^paginate_accepted_"))
    application.add_handler(CallbackQueryHandler(view_repair_requests, pattern="^paginate_requests_"))
    application.add_handler(CallbackQueryHandler(handle_noti_button, pattern="^noti_"))
    application.add_handler(CallbackQueryHandler(view_attendance_history, pattern='^attendance_page:'))
    application.add_handler(CallbackQueryHandler(shtrafpagi, pattern="^(page:|close_pagination)"))

    application.add_handler(CallbackQueryHandler(back_to_results, pattern="^back_to_results$"))
    application.add_handler(CallbackQueryHandler(close_details, pattern="^close_details$"))
    application.add_handler(CallbackQueryHandler(close_details, pattern="^close_search$"))
    application.add_handler(CallbackQueryHandler(show_action_details, pattern="^full_history_page_"))
    application.add_handler(rent_conversation_handler)
    application.add_handler(CallbackQueryHandler(view_bike_history, pattern="^history_bike$"))
    application.add_handler(CallbackQueryHandler(view_user_history, pattern="^history_user$"))
    application.add_handler(CommandHandler("rentals", manage_rentals))
    application.add_handler(CallbackQueryHandler(view_user_rentals, pattern="^view_rentals_"))
# Обработчики для пагинации
    application.add_handler(CallbackQueryHandler(show_bike_page, pattern=r"^bike_page_\d+$"))
    application.add_handler(CallbackQueryHandler(show_user_page, pattern=r"^user_page_\d+$"))
    application.add_handler(CallbackQueryHandler(view_history_menu, pattern="^history_"))
    application.add_handler(CallbackQueryHandler(handle_pagination, pattern="^list_"))
    application.add_handler(CommandHandler("snake", start_snake))
    application.add_handler(CallbackQueryHandler(handle_controls, pattern="^snake_"))
    application.add_handler(CommandHandler("test_overdue", test_overdue_rental))

    application.add_handler(repair_conv_handler)
    application.add_handler(date_selection_handler)
    application.add_handler(dispute_conversation)
    application.add_handler(fine_conversation_handler)
    application.add_handler(view_fines_conversation)
    application.add_handler(booking_handler)
    application.add_handler(repair_handler)
    application.add_handler(add_part_handler)
    application.add_handler(edit_bike_handler)
    application.add_handler(edit_part_conv)
    application.add_handler(rejecttt)
    application.add_handler(ask_support_handler)
    application.add_handler(answer_question_handler)
    application.add_handler(send_news_handler)
    application.add_handler(CommandHandler("start", start))
    # ============================================================
# 3. Command Handlers
# ============================================================
    application.add_handler(CallbackQueryHandler(confirm_agreement, pattern="^confirm_agreement$"))
    application.add_handler(CommandHandler("view_questions", view_questions))
    from bot_act_handler import get_act_handler
    application.add_handler(get_act_handler())

    application.add_handler(CommandHandler("notifications", show_notifications))
    application.add_handler(CommandHandler("mark_attendance", mark_attendance))
    application.add_handler(CommandHandler("history", view_history_menu))
    application.add_handler(CommandHandler("finish_attendance", finish_attendance))
    application.add_handler(CommandHandler("status", status))
    application.add_handler(CommandHandler("view_repair_requests", view_repair_requests))
    application.add_handler(CommandHandler("cancel_booking", cancel_booking_command))
    application.add_handler(CommandHandler("test_reminder", test_reminder))
    application.add_handler(CommandHandler("search", search_users))
    application.add_handler(CallbackQueryHandler(confirm_user_verification, pattern="^verify_"))
    application.add_handler(CallbackQueryHandler(part_info, pattern="^part_info_"))
    application.add_handler(CallbackQueryHandler(verify_user, pattern="^verify_"))
    application.add_handler(CallbackQueryHandler(confirm_booking_admin, pattern="^confirm_"))
    application.add_handler(CallbackQueryHandler(cancel_booking_admin, pattern="^cancel_"))
    application.add_handler(CallbackQueryHandler(bike_info, pattern="^info_"))
    application.add_handler(CallbackQueryHandler(calendar_callback, pattern="^select_date_"))
    application.add_handler(CallbackQueryHandler(calendar_callback, pattern="^prev_month_"))
    application.add_handler(CallbackQueryHandler(calendar_callback, pattern="^next_month_"))
    application.add_handler(CallbackQueryHandler(accept_rental, pattern="^accept_bike_"))
    application.add_handler(CallbackQueryHandler(return_bike, pattern=r"^return_bike_start$"))
    application.add_handler(CallbackQueryHandler(view_bike_history, pattern="^history_bike$"))
    application.add_handler(CallbackQueryHandler(view_user_history, pattern="^history_user$"))
    application.add_handler(CallbackQueryHandler(display_history, pattern="^(bike_history_|user_history_)"))
    application.add_handler(CallbackQueryHandler(request_attendance, pattern="^request_attendance$"))
    application.add_handler(CallbackQueryHandler(arenda, pattern=r"^arenda_\d+$"))
    application.add_handler(CallbackQueryHandler(select_day, pattern="^select_day$"))
    application.add_handler(CallbackQueryHandler(select_rental_period, pattern=r"^prolong_\d+_\d+$"))
    application.add_handler(CallbackQueryHandler(handle_extension_choice, pattern=r"extend_\d+_\d+"))
    application.add_handler(CallbackQueryHandler(accept_extension, pattern=r"accept_extension_[0-9]+_[0-9]+"))
    application.add_handler(CallbackQueryHandler(handle_join_queue, pattern="^join_queue$"))
    application.add_handler(CallbackQueryHandler(handle_view_queue, pattern="^view_queue$"))
    application.add_handler(CallbackQueryHandler(
    handle_admin_view_queue,
    pattern=r"^wowwow_page_\d+$"  # Регулярное выражение для точного совпадения
))


# Регистрируем обработчик удаления с уникальным префиксом wowwow_
    application.add_handler(CallbackQueryHandler(
    handle_admin_remove_user,
    pattern=r"^wowwow_remove_\d+_\d+$"  # wowwow_remove_123_2
))
    application.add_handler(CallbackQueryHandler(leave_bike, pattern="^leave_bike_"))
    application.add_handler(CommandHandler("otchet", generate_report_command))

    application.add_handler(CallbackQueryHandler(handle_prolong_rental, pattern="^prolong_rental_"))
    application.add_handler(CallbackQueryHandler(view_accepted_repairs, pattern="^view_accepted_repairs$"))
    application.add_handler(CallbackQueryHandler(view_completed_repairs, pattern="^view_completed_repairs$"))
    application.add_handler(CallbackQueryHandler(complete_repair, pattern="^complete_repair_"))
    application.add_handler(CallbackQueryHandler(delete_repair_request, pattern="^otmena_repair_"))
    application.add_handler(CallbackQueryHandler(delete_booking, pattern="^delete_"))
    application.add_handler(CallbackQueryHandler(cancel_booking, pattern="^cancel_booking_"))
    application.add_handler(CallbackQueryHandler(handle_accept, pattern='^accept_'))
    application.add_handler(CallbackQueryHandler(extend_rental, pattern=r"extend_rental_*"))

    # ============================================================
    # 5. Message Handlers (специфичные фильтры)
    # ============================================================
    application.add_handler(CallbackQueryHandler(mock_payment_handler, pattern="^mock_payment_"))
    application.add_handler(MessageHandler(filters.LOCATION, receive_location))
    # Обработчик для текстовых сообщений, которые не являются командами
    application.add_handler(
        MessageHandler(
            filters.TEXT & ~filters.COMMAND & filters.UpdateFilter(is_reject_reason_active),
            handle_reject_reason
        )
    )

    # Основной обработчик меню
    application.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, menu_handler)
    )
    application.add_handler(MessageHandler(filters.Regex("^🛠️ Заявки в работе"), view_accepted_repairs))
    application.add_handler(MessageHandler(filters.Regex("^💳 Ожидают оплаты"), view_completed_repairs))
    application.add_handler(MessageHandler(filters.Text(["🏠 Главное меню"]), back_to_main_menu))
    from datetime import datetime, time, timezone, timedelta
    import pytz
    from datetime import datetime, time



    moscow_tz = pytz.timezone('Europe/Moscow')
    
    # Устанавливаем время для ежедневного запуска - 20:00
    target_time = time(20, 0, 0, tzinfo=moscow_tz)

    application.job_queue.run_daily(
        callback=check_payment_reminders, # <-- Наша новая функция
        time=target_time,
        name="daily_payment_reminders_job" # Уникальное имя для задачи
    )
    
    logging.info(f"Запланирована ежедневная задача 'check_payment_reminders' на {target_time.strftime('%H:%M:%S')} по МСК.")
    # Часовой пояс Екатеринбурга
    perm_tz = pytz.timezone('Asia/Yekaterinburg')
    morning_time = perm_tz.localize(datetime.combine(datetime.today(), time(10, 0))).time()
    application.job_queue.run_daily(
    callback=morning_reminder,
    time=morning_time,
    name="daily_morning_check"
    )

    evening_time = perm_tz.localize(datetime.combine(datetime.today(), time(18, 0))).time()
    application.job_queue.run_daily(
    callback=evening_reminder,
    time=evening_time,
    name="daily_evening_check"
    )

    import pytz
    perm_tz = pytz.timezone('Asia/Yekaterinburg')
    target_time = perm_tz.localize(datetime.combine(datetime.today(), time(22, 0))).time()


    application.job_queue.run_daily(
        callback=check_rental_reminders,
        time=target_time,
        name="daily_rental_check"
    )
    # ============================================================
    # 6. Общие обработчики (должны быть последними)
    # ===========================================================
    application.run_polling()
if __name__ == "__main__":
    main()
